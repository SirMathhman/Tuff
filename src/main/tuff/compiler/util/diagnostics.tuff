// Selfhost compiler: diagnostics + per-file mutable state.
// Extracted from tuffc_lib.tuff as part of Phase 2 (mechanical split).

extern from rt::stdlib use { println, panic, stringLen, stringSlice, stringCharCodeAt };
extern from rt::vec use { vec_new, vec_len, vec_push, vec_get };

// Current file label for error messages (used by panic_at).
let mut __tuffc_current_file = "<input>";

// Diagnostics output mode.
// - "human": existing multi-line formatted messages
// - "json": one JSON object per warning; errors are thrown as a JSON object
let mut __tuffc_diag_format = "human";

// Accumulated analyzer errors (reset per file compilation).
let mut __tuffc_errors = vec_new();

// Accumulated warnings (reset per file compilation).
// Warnings do not fail compilation; they are printed after successful analysis.
let mut __tuffc_warnings = vec_new();

// Cumulative error count for project-level linting (not reset per file).
let mut __tuffc_project_error_count = 0;

// Cumulative warning count for project-level linting (not reset per file).
let mut __tuffc_project_warning_count = 0;

// Structured diagnostics for LSP integration.
// Each entry is a DiagInfo with line, col, start, end, msg, help.
let mut __tuffc_error_infos = vec_new();
let mut __tuffc_warning_infos = vec_new();

// Struct definitions for struct literals (reset per file compilation).
let mut __tuffc_struct_defs = vec_new();

class fn LineCol(line: I32, col: I32) => {}
class fn StructDef(name: String, fields: Vec<String>) => {} // name, fields(vec)

// Structured diagnostic info for LSP.
class fn DiagInfo(line: I32, col: I32, start: I32, end: I32, msg: String, help: String) => {}

out fn set_current_file(path: String) : Void => {
  __tuffc_current_file = path;
}

out fn set_diagnostics_format(format: String) : Void => {
  // Be strict so typos don't silently change output.
  if (format == "human" || format == "json") {
    __tuffc_diag_format = format;
  } else {
    panic("unknown diagnostics format: " + format);
  }
}

out fn reset_errors() : Void => {
  __tuffc_errors = vec_new();
  __tuffc_error_infos = vec_new();
}

out fn reset_warnings() : Void => {
  __tuffc_warnings = vec_new();
  __tuffc_warning_infos = vec_new();
}

out fn reset_project_errors() : Void => {
  __tuffc_project_error_count = 0;
  __tuffc_project_warning_count = 0;
}

fn errors_len() : I32 => vec_len(__tuffc_errors)

out fn has_errors() : Bool => vec_len(__tuffc_errors) > 0

out fn has_project_errors() : Bool => __tuffc_project_error_count > 0

out fn get_project_error_count() : I32 => __tuffc_project_error_count

out fn get_project_warning_count() : I32 => __tuffc_project_warning_count

fn errors_join() : String => {
  let mut out = "";
  let mut i = 0;
  while (i < vec_len(__tuffc_errors)) {
    if (i > 0) { out = out + "\n\n"; }
    out = out + vec_get(__tuffc_errors, i);
    i = i + 1;
  }
  out
}

fn warnings_join() : String => {
  let mut out = "";
  let mut i = 0;
  while (i < vec_len(__tuffc_warnings)) {
    if (i > 0) { out = out + "\n\n"; }
    out = out + vec_get(__tuffc_warnings, i);
    i = i + 1;
  }
  out
}

fn json_escape(s: String) : String => {
  // Escape only what we need for stable single-line JSON output.
  let mut out = "";
  let mut i: I32 = 0;
  while (i < stringLen(s)) {
    let ch = stringCharCodeAt(s, i);
    if (ch == 34) {
      out = out + "\\\"";
    } else {
      if (ch == 92) {
        out = out + "\\\\";
      } else {
        if (ch == 10) {
          out = out + "\\n";
        } else {
          if (ch == 13) {
            out = out + "\\r";
          } else {
            if (ch == 9) {
              out = out + "\\t";
            } else {
              out = out + stringSlice(s, i, i + 1);
            }
          }
        }
      }
    }
    i = i + 1;
  }
  out
}

fn diag_json(level: String, text: String) : String => {
  "{\"level\":\"" + level + "\",\"text\":\"" + json_escape(text) + "\"}"
}

out fn panic_if_errors() : Void => {
  if (vec_len(__tuffc_errors) > 0) {
    if (__tuffc_diag_format == "json") {
      panic(diag_json("error", errors_join()));
    }
    panic(errors_join());
  }
}

fn emit_diagnostics_vec(diagnostics: Vec<String>, severity: String, count: I32) : I32 => {
  let mut i = 0;
  while (i < vec_len(diagnostics)) {
    let msg = vec_get(diagnostics, i);
    if (__tuffc_diag_format == "json") {
      println(diag_json(severity, msg));
    } else {
      println(msg);
    }
    i = i + 1;
  }
  count + vec_len(diagnostics)
}

out fn emit_errors() : Void => {
  // Print errors without panicking. Used by linting mode (fluff).
  // Also update the project-level error count for final exit code.
  __tuffc_project_error_count = emit_diagnostics_vec(__tuffc_errors, "error", __tuffc_project_error_count);
}

out fn emit_warnings() : Void => {
  // Print warnings after a successful compile. Keep them separate from errors
  // so they don't fail compilation.
  // Also update the project-level warning count for final summary.
  __tuffc_project_warning_count = emit_diagnostics_vec(__tuffc_warnings, "warning", __tuffc_project_warning_count);
}

fn ascii_lower(ch: I32) : I32 => {
  if (ch >= 65 && ch <= 90) { yield ch + 32; }
  ch
}

fn replace_error_label_with_warning(s: String) : String => {
  // The formatter currently hardcodes " error: " in the header.
  // Rewrite the first occurrence to " warning: " for warnings.
  let needle = " error: ";
  let mut i = 0;
  while (i + stringLen(needle) <= stringLen(s)) {
    let mut ok = true;
    let mut j = 0;
    while (j < stringLen(needle)) {
      if (stringCharCodeAt(s, i + j) != stringCharCodeAt(needle, j)) { ok = false; break; }
      j = j + 1;
    }
    if (ok) {
      let before = stringSlice(s, 0, i);
      let after = stringSlice(s, i + stringLen(needle), stringLen(s));
      yield before + " warning: " + after;
    }
    i = i + 1;
  }
  s
}

fn spaces(n: I32) : String => {
  let mut s = "";
  let mut i: I32 = 0;
  while (i < n) {
    s = s + " ";
    i = i + 1;
  }
  s
}

fn carets(n: I32) : String => {
  let mut s = "";
  let mut i: I32 = 0;
  let mut k: I32 = n;
  if (k < 1) { k = 1; }
  while (i < k) {
    s = s + "^";
    i = i + 1;
  }
  s
}

out fn line_col_at(src: String, i: I32) : LineCol => {
  let mut line: I32 = 1;
  let mut col: I32 = 1;
  let mut p: I32 = 0;
  let mut limit: I32 = i;
  if (limit > stringLen(src)) { limit = stringLen(src); }
  while (p < limit) {
    let ch: I32 = stringCharCodeAt(src, p);
    if (ch == 10) {
      line = line + 1;
      col = 1;
    } else {
      col = col + 1;
    }
    p = p + 1;
  }
  LineCol(line, col)
}

out fn format_span_help(src: String, start: I32, end: I32, msg: String, help: String) : String => {
  // Clamp span for safe slicing (but still report the clamped offset at start).
  let mut s: I32 = start;
  let mut e: I32 = end;
  if (s < 0) { s = 0; }
  if (e < 0) { e = 0; }
  if (s > stringLen(src)) { s = stringLen(src); }
  if (e > stringLen(src)) { e = stringLen(src); }
  if (e < s) { e = s; }

  let lc = line_col_at(src, s);

  // Find bounds of the line containing s.
  let mut ls: I32 = s;
  while (ls > 0) {
    if (stringCharCodeAt(src, ls - 1) == 10) { break; }
    ls = ls - 1;
  }

  let mut le: I32 = s;
  while (le < stringLen(src)) {
    if (stringCharCodeAt(src, le) == 10) { break; }
    le = le + 1;
  }

  // Previous line bounds (if any)
  let mut pls: I32 = -1;
  let mut ple: I32 = -1;
  if (ls > 0) {
    ple = ls - 1;
    pls = ple;
    while (pls > 0) {
      if (stringCharCodeAt(src, pls - 1) == 10) { break; }
      pls = pls - 1;
    }
  }

  // Next line bounds (if any)
  let mut nls: I32 = -1;
  let mut nle: I32 = -1;
  if (le < stringLen(src) && stringCharCodeAt(src, le) == 10) {
    nls = le + 1;
    nle = nls;
    while (nle < stringLen(src)) {
      if (stringCharCodeAt(src, nle) == 10) { break; }
      nle = nle + 1;
    }
  }

  // Compute line number width (for nice alignment).
  let mut width = stringLen("" + lc.line);
  if (pls != -1) {
    let w = stringLen("" + (lc.line - 1));
    if (w > width) { width = w; }
  }
  if (nls != -1) {
    let w = stringLen("" + (lc.line + 1));
    if (w > width) { width = w; }
  }

  // Determine underline length (clamped to current line).
  let mut ue: I32 = e;
  if (ue > le) { ue = le; }
  let mut ulen: I32 = ue - s;
  if (ulen < 1) { ulen = 1; }

  let lineStr = ("" + lc.line);

  let header = __tuffc_current_file + ":" + lineStr + ":" + ("" + lc.col) + " (offset " + ("" + s) + ") error: " + msg;

  let mut out = header;

  if (pls != -1) {
    let prevText = stringSlice(src, pls, ple);
    let prevStr = ("" + (lc.line - 1));
    out = out + "\n" + spaces(width - stringLen(prevStr)) + prevStr + " | " + prevText;
  }

  let lineText = stringSlice(src, ls, le);
  out = out + "\n" + spaces(width - stringLen(lineStr)) + lineStr + " | " + lineText;
  out = out + "\n" + spaces(width) + " | " + spaces(lc.col - 1) + carets(ulen);

  if (nls != -1) {
    let nextText = stringSlice(src, nls, nle);
    let nextStr = ("" + (lc.line + 1));
    out = out + "\n" + spaces(width - stringLen(nextStr)) + nextStr + " | " + nextText;
  }

  if (help != "") {
    out = out + "\n" + "help: " + help;
  }

  out
}

out fn panic_span_help(src: String, start: I32, end: I32, msg: String, help: String) : Never => {
  panic(format_span_help(src, start, end, msg, help))
}

out fn error_span_help(src: String, start: I32, end: I32, msg: String, help: String) : Void => {
  // Avoid runaway cascades.
  if (vec_len(__tuffc_errors) >= 50) { yield; }
  vec_push(__tuffc_errors, format_span_help(src, start, end, msg, help));
  // Also store structured info for LSP.
  let lc = line_col_at(src, start);
  vec_push(__tuffc_error_infos, DiagInfo(lc.line, lc.col, start, end, msg, help));
}

out fn warn_span_help(src: String, start: I32, end: I32, msg: String, help: String) : Void => {
  // Avoid runaway cascades.
  if (vec_len(__tuffc_warnings) >= 200) { yield; }
  let s = format_span_help(src, start, end, msg, help);
  vec_push(__tuffc_warnings, replace_error_label_with_warning(s));
  // Also store structured info for LSP.
  let lc = line_col_at(src, start);
  vec_push(__tuffc_warning_infos, DiagInfo(lc.line, lc.col, start, end, msg, help));
}

out fn panic_at_help(src: String, i: I32, msg: String, help: String) : Never => {
  panic_span_help(src, i, i, msg, help)
}

out fn error_at_help(src: String, i: I32, msg: String, help: String) : Void => {
  error_span_help(src, i, i, msg, help);
}

out fn warn_at_help(src: String, i: I32, msg: String, help: String) : Void => {
  warn_span_help(src, i, i, msg, help);
}

out fn panic_at(src: String, i: I32, msg: String) : Never => {
  panic_at_help(src, i, msg, "")
}

out fn error_at(src: String, i: I32, msg: String) : Void => {
  error_at_help(src, i, msg, "");
}

out fn warn_at(src: String, i: I32, msg: String) : Void => {
  warn_at_help(src, i, msg, "");
}

out fn reset_struct_defs() : Void => {
  __tuffc_struct_defs = vec_new();
}

out fn add_struct_def(name: String, fields: Vec<String>) : Void => {
  // Disallow duplicate declarations (consistent with no-shadowing ethos).
  let mut si = 0;
  while (si < vec_len(__tuffc_struct_defs)) {
    let d = vec_get(__tuffc_struct_defs, si);
    if (d.name == name) { panic("duplicate struct: " + name); }
    si = si + 1;
  }
  vec_push(__tuffc_struct_defs, StructDef(name, fields));
}

out fn find_struct_fields(name: String) : Vec<String> => {
  let mut si = 0;
  while (si < vec_len(__tuffc_struct_defs)) {
    let d = vec_get(__tuffc_struct_defs, si);
    if (d.name == name) { yield d.fields; }
    si = si + 1;
  }
  panic("unknown struct: " + name)
}

// Identifier quality checks
out fn is_identifier_too_short(text: String) : Bool => {
  // This check was too noisy in practice (especially in tests and small examples).
  // It remains as a stubbed hook so call-sites don't need to change.
  false
}

out fn warn_short_identifier(src: String, startPos: I32, name: String) : Void => {
  // Intentionally disabled (see is_identifier_too_short).
  // Keep the signature so call-sites remain stable.
  // (No-op)
}

// LSP integration: retrieve structured diagnostics.
out fn get_error_infos() : Vec<DiagInfo> => __tuffc_error_infos
out fn get_warning_infos() : Vec<DiagInfo> => __tuffc_warning_infos
out fn get_current_file() : String => __tuffc_current_file
