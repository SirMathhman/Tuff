// Selfhost compiler: diagnostics + per-file mutable state.
// Extracted from tuffc_lib.tuff as part of Phase 2 (mechanical split).

extern from rt::stdlib use { println, panic, stringLen, stringSlice, stringCharCodeAt };
extern from rt::vec use { vec_new, vec_len, vec_push, vec_get };

// Current file label for error messages (used by panic_at).
let mut __tuffc_current_file = "<input>";

// Struct definitions for struct literals (reset per file compilation).
let mut __tuffc_struct_defs = vec_new();

class fn LineCol(line: I32, col: I32) => {}
class fn StructDef(name: String, fields: Vec<String>) => {} // name, fields(vec)

fn set_current_file(path: String) : Void => {
  __tuffc_current_file = path;
}

fn spaces(n: I32) : String => {
  let mut s = "";
  let mut i: I32 = 0;
  while (i < n) {
    s = s + " ";
    i = i + 1;
  }
  s
}

fn carets(n: I32) : String => {
  let mut s = "";
  let mut i: I32 = 0;
  let mut k: I32 = n;
  if (k < 1) { k = 1; }
  while (i < k) {
    s = s + "^";
    i = i + 1;
  }
  s
}

fn line_col_at(src: String, i: I32) : LineCol => {
  let mut line: I32 = 1;
  let mut col: I32 = 1;
  let mut p: I32 = 0;
  let mut limit: I32 = i;
  if (limit > stringLen(src)) { limit = stringLen(src); }
  while (p < limit) {
    let ch: I32 = stringCharCodeAt(src, p);
    if (ch == 10) {
      line = line + 1;
      col = 1;
    } else {
      col = col + 1;
    }
    p = p + 1;
  }
  LineCol(line, col)
}

fn panic_span_help(src: String, start: I32, end: I32, msg: String, help: String) : Void => {
  // Clamp span for safe slicing (but still report the clamped offset at start).
  let mut s: I32 = start;
  let mut e: I32 = end;
  if (s < 0) { s = 0; }
  if (e < 0) { e = 0; }
  if (s > stringLen(src)) { s = stringLen(src); }
  if (e > stringLen(src)) { e = stringLen(src); }
  if (e < s) { e = s; }

  let lc = line_col_at(src, s);

  // Find bounds of the line containing s.
  let mut ls: I32 = s;
  while (ls > 0) {
    if (stringCharCodeAt(src, ls - 1) == 10) { break; }
    ls = ls - 1;
  }

  let mut le: I32 = s;
  while (le < stringLen(src)) {
    if (stringCharCodeAt(src, le) == 10) { break; }
    le = le + 1;
  }

  // Previous line bounds (if any)
  let mut pls: I32 = -1;
  let mut ple: I32 = -1;
  if (ls > 0) {
    ple = ls - 1;
    pls = ple;
    while (pls > 0) {
      if (stringCharCodeAt(src, pls - 1) == 10) { break; }
      pls = pls - 1;
    }
  }

  // Next line bounds (if any)
  let mut nls: I32 = -1;
  let mut nle: I32 = -1;
  if (le < stringLen(src) && stringCharCodeAt(src, le) == 10) {
    nls = le + 1;
    nle = nls;
    while (nle < stringLen(src)) {
      if (stringCharCodeAt(src, nle) == 10) { break; }
      nle = nle + 1;
    }
  }

  // Compute line number width (for nice alignment).
  let mut width = stringLen("" + lc.line);
  if (pls != -1) {
    let w = stringLen("" + (lc.line - 1));
    if (w > width) { width = w; }
  }
  if (nls != -1) {
    let w = stringLen("" + (lc.line + 1));
    if (w > width) { width = w; }
  }

  // Determine underline length (clamped to current line).
  let mut ue: I32 = e;
  if (ue > le) { ue = le; }
  let mut ulen: I32 = ue - s;
  if (ulen < 1) { ulen = 1; }

  let lineStr = ("" + lc.line);

  let header = __tuffc_current_file + ":" + lineStr + ":" + ("" + lc.col) + " (offset " + ("" + s) + ") error: " + msg;

  let mut out = header;

  if (pls != -1) {
    let prevText = stringSlice(src, pls, ple);
    let prevStr = ("" + (lc.line - 1));
    out = out + "\n" + spaces(width - stringLen(prevStr)) + prevStr + " | " + prevText;
  }

  let lineText = stringSlice(src, ls, le);
  out = out + "\n" + spaces(width - stringLen(lineStr)) + lineStr + " | " + lineText;
  out = out + "\n" + spaces(width) + " | " + spaces(lc.col - 1) + carets(ulen);

  if (nls != -1) {
    let nextText = stringSlice(src, nls, nle);
    let nextStr = ("" + (lc.line + 1));
    out = out + "\n" + spaces(width - stringLen(nextStr)) + nextStr + " | " + nextText;
  }

  if (help != "") {
    out = out + "\n" + "help: " + help;
  }

  panic(out);
}

fn panic_at_help(src: String, i: I32, msg: String, help: String) : Void => {
  panic_span_help(src, i, i, msg, help);
}

fn panic_at(src: String, i: I32, msg: String) : Void => {
  panic_at_help(src, i, msg, "");
}

fn reset_struct_defs() : Void => {
  __tuffc_struct_defs = vec_new();
}

fn add_struct_def(name: String, fields: Vec<String>) : Void => {
  // Disallow duplicate declarations (consistent with no-shadowing ethos).
  let mut si = 0;
  while (si < vec_len(__tuffc_struct_defs)) {
    let d = vec_get(__tuffc_struct_defs, si);
    if (d.name == name) { panic("duplicate struct: " + name); }
    si = si + 1;
  }
  vec_push(__tuffc_struct_defs, StructDef(name, fields));
}

fn find_struct_fields(name: String) : Vec<String> => {
  let mut si = 0;
  while (si < vec_len(__tuffc_struct_defs)) {
    let d = vec_get(__tuffc_struct_defs, si);
    if (d.name == name) { yield d.fields; }
    si = si + 1;
  }
  panic("unknown struct: " + name)
}

// Identifier quality checks
fn is_identifier_too_short(text: String) : Bool => {
  // This check was too noisy in practice (especially in tests and small examples).
  // It remains as a stubbed hook so call-sites don't need to change.
  false
}

fn warn_short_identifier(src: String, startPos: I32, name: String) : Void => {
  // Intentionally disabled (see is_identifier_too_short).
  // Keep the signature so call-sites remain stable.
  // (No-op)
}
