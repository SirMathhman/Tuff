// Formatting / refactoring support (whitespace + comments preserving).
//
// This module provides a "formatted" parse entrypoint that returns:
// - canonical AST decls (semantic view)
// - a trivia-preserving token stream (textual view)
//
// Today, the token stream is used for round-tripping exactly and as a base for
// future formatting + refactoring operations.

extern from rt::vec use { vec_new, vec_len, vec_push, vec_get };
extern from rt::stdlib use { stringLen };

from util::diagnostics use { panic_at, reset_struct_defs };

from util::lexing use { skip_ws, starts_with_at, tokenize_with_trivia, TokenStream };

from parsing::primitives use {
  parse_keyword,
  parse_optional_semicolon,
  parse_required_semicolon,
  parse_ident
};

from parsing::types use { parse_type_expr };

from parsing::expr_stmt use { parse_expr_ast, parse_mut_opt };

from parsing::decls use {
  parse_imports_ast,
  parse_extern_decl_ast,
  parse_module_decl_ast,
  parse_fn_decl_ast2,
  parse_class_fn_decl_ast2,
  parse_struct_decl_ast,
  parse_type_union_decl_ast
};

from ast use { span, decl_let };

class fn ParsedProgramWithTrivia(decls: Any, tokenStream: TokenStream, nextPos: I32) => {}

fn parse_program_decls_ast(src: String, exportAll: Bool) : Any => {
  let decls = vec_new();
  let mut i = 0;

  // Reset per-file state used by other compiler phases.
  reset_struct_defs();

  // zero or more extern declarations
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "extern")) {
      let ex = parse_extern_decl_ast(src, i);
      vec_push(decls, ex.decl);
      i = ex.nextPos;
      continue;
    }
    break;
  }

  // zero or more imports
  let imps = parse_imports_ast(src, i);
  let mut ii = 0;
  while (ii < vec_len(imps.decls)) {
    vec_push(decls, vec_get(imps.decls, ii));
    ii = ii + 1;
  }
  i = imps.nextPos;

  // zero or more module declarations
  while (true) {
    let j = skip_ws(src, i);
    if (!starts_with_at(src, j, "module")) { break; }
    let m = parse_module_decl_ast(src, i);
    vec_push(decls, m.decl);
    i = m.nextPos;
  }

  // zero or more type / struct declarations
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "type")) {
      let td = parse_type_union_decl_ast(src, i, exportAll);
      vec_push(decls, td.decl);
      i = td.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "struct")) {
      let sd = parse_struct_decl_ast(src, i);
      vec_push(decls, sd.decl);
      i = sd.nextPos;
      continue;
    }
    break;
  }

  // zero or more let declarations
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "let")) {
      let start = skip_ws(src, i);
      i = parse_keyword(src, i, "let");
      let mutOpt = parse_mut_opt(src, i);
      i = mutOpt.nextPos;
      let name = parse_ident(src, i);
      i = name.nextPos;

      // Optional let type annotation: `let x: T = ...`
      let t0 = skip_ws(src, i);
      if (t0 < stringLen(src) && t0 >= 0) {
        // The parser primitives expose ':' checks elsewhere; here we only need to
        // avoid importing stringCharCodeAt just for a single comparison.
        // We rely on parse_type_expr to panic if called incorrectly.
      }

      // Re-check for ':' by peeking via a tiny keyword parse.
      // We do the same pattern as the main compiler: look for ':' directly.
      // NOTE: We must import stringCharCodeAt to do this precisely, but to keep
      // this module minimal for now we use a small trick: attempt to parse a type
      // only when a ':' is present. We detect ':' by parsing the keyword ":".
      // If it's not present, parse_keyword would panic, so we guard by starts_with_at.
      let colonPos = skip_ws(src, i);
      if (starts_with_at(src, colonPos, ":")) {
        let _ty = parse_type_expr(src, colonPos + 1);
        i = _ty.v1;
      }

      i = parse_keyword(src, i, "=");
      let expr = parse_expr_ast(src, i);
      i = expr.nextPos;
      i = parse_optional_semicolon(src, i);
      vec_push(decls, decl_let(span(start, i), mutOpt.ok, name.text, expr.expr));
      continue;
    }
    break;
  }

  // functions
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "fn")) {
      let f = parse_fn_decl_ast2(src, i, exportAll);
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "class")) {
      let f = parse_class_fn_decl_ast2(src, i, exportAll);
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    break;
  }

  // Ensure we consumed the whole file (except trailing trivia)
  let end = skip_ws(src, i);
  if (end < stringLen(src)) {
    panic_at(src, end, "unexpected trailing input");
  }

  // Pack decls + nextPos into a tiny record-like Vec: [decls, nextPos]
  // (We avoid tuples/structs here to keep bootstrap simple.)
  let out = vec_new();
  vec_push(out, decls);
  vec_push(out, end);
  out
}

fn parse_program_with_trivia(src: String, exportAll: Bool) : ParsedProgramWithTrivia => {
  let ts = tokenize_with_trivia(src);
  let pack = parse_program_decls_ast(src, exportAll);
  let decls = vec_get(pack, 0);
  let nextPos = vec_get(pack, 1);
  ParsedProgramWithTrivia(decls, ts, nextPos)
}
