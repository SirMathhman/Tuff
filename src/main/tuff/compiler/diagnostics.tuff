// Selfhost compiler: diagnostics + per-file mutable state.
// Extracted from tuffc_lib.tuff as part of Phase 2 (mechanical split).

extern from rt::stdlib use { println, panic, stringLen, stringSlice, stringCharCodeAt };
extern from rt::vec use { vec_new, vec_len, vec_push, vec_get };

// Current file label for error messages (used by panic_at).
let mut __tuffc_current_file = "<input>";

// Struct definitions for struct literals (reset per file compilation).
let mut __tuffc_struct_defs = vec_new();

class fn LineCol(line: I32, col: I32) => {}
class fn StructDef(name: String, fields: Vec<String>) => {} // name, fields(vec)

fn set_current_file(path: String) : Void => {
  __tuffc_current_file = path;
}

fn spaces(n: I32) : String => {
  let mut s = "";
  let mut i: I32 = 0;
  while (i < n) {
    s = s + " ";
    i = i + 1;
  }
  s
}

fn line_col_at(src: String, i: I32) : LineCol => {
  let mut line: I32 = 1;
  let mut col: I32 = 1;
  let mut p: I32 = 0;
  let mut limit: I32 = i;
  if (limit > stringLen(src)) { limit = stringLen(src); }
  while (p < limit) {
    let ch: I32 = stringCharCodeAt(src, p);
    if (ch == 10) {
      line = line + 1;
      col = 1;
    } else {
      col = col + 1;
    }
    p = p + 1;
  }
  LineCol(line, col)
}

fn panic_at(src: String, i: I32, msg: String) : Void => {
  let lc = line_col_at(src, i);

  // Find bounds of the line containing i.
  let mut pos: I32 = i;
  if (pos > stringLen(src)) { pos = stringLen(src); }

  let mut ls: I32 = pos;
  while (ls > 0) {
    if (stringCharCodeAt(src, ls - 1) == 10) { break; }
    ls = ls - 1;
  }

  let mut le: I32 = pos;
  while (le < stringLen(src)) {
    if (stringCharCodeAt(src, le) == 10) { break; }
    le = le + 1;
  }

  let lineText = stringSlice(src, ls, le);
  let header = __tuffc_current_file + ":" + ("" + lc.line) + ":" + ("" + lc.col) + " error: " + msg;
  let frame1 = "  | " + lineText;
  let frame2 = "  | " + spaces(lc.col - 1) + "^";
  panic(header + "\n" + frame1 + "\n" + frame2);
}

fn reset_struct_defs() : Void => {
  __tuffc_struct_defs = vec_new();
}

fn add_struct_def(name: String, fields: Vec<String>) : Void => {
  // Disallow duplicate declarations (consistent with no-shadowing ethos).
  let mut si = 0;
  while (si < vec_len(__tuffc_struct_defs)) {
    let d = vec_get(__tuffc_struct_defs, si);
    if (d.name == name) { panic("duplicate struct: " + name); }
    si = si + 1;
  }
  vec_push(__tuffc_struct_defs, StructDef(name, fields));
}

fn find_struct_fields(name: String) : Vec<String> => {
  let mut si = 0;
  while (si < vec_len(__tuffc_struct_defs)) {
    let d = vec_get(__tuffc_struct_defs, si);
    if (d.name == name) { yield d.fields; }
    si = si + 1;
  }
  panic("unknown struct: " + name)
}

// Identifier quality checks
fn is_identifier_too_short(text: String) : Bool => {
  // This check was too noisy in practice (especially in tests and small examples).
  // It remains as a stubbed hook so call-sites don't need to change.
  false
}

fn warn_short_identifier(src: String, startPos: I32, name: String) : Void => {
  // Intentionally disabled (see is_identifier_too_short).
  // Keep the signature so call-sites remain stable.
  // (No-op)
}
