// Self-hosted compiler (first whack)
//
// This is a *very* small compiler written in Tuff, intended to prove the loop:
//   bootstrap TS compiler -> emits JS -> JS runs and can compile a tiny subset.
//
// For now, it compiles only a restricted input shape:
//   fn main() => <number>
//   fn main() => { <number> }
//
// Output is ESM that exports `main`.
//
// NOTE: This file contains the compiler implementation.
// The CLI entrypoint lives in `selfhost/tuffc.tuff`.

extern from rt::stdlib use { println, panic, readTextFile, writeTextFile, pathDirname, pathJoin, stringLen, stringSlice, stringCharCodeAt, stringFromCharCode };

extern from rt::vec use { vec_new, vec_len, vec_push, vec_get };

from util::diagnostics use {
  set_current_file,
  panic_at,
  reset_errors,
  reset_warnings,
  panic_if_errors,
  emit_errors,
  emit_warnings,
  reset_struct_defs,
  add_struct_def,
  find_struct_fields,
  is_identifier_too_short,
  warn_short_identifier,
  get_error_infos,
  get_warning_infos,
  get_current_file,
  line_col_at,
  DiagInfo,
  LineCol
};

from util::lexing use {
  is_digit,
  is_space,
  is_ident_start,
  is_ident_part,
  skip_ws,
  starts_with_at
};

from parsing::primitives use {
  ParsedNumber,
  ParsedIdent,
  ParsedBool,
  parse_keyword,
  parse_number,
  parse_ident,
  parse_module_path,
  module_path_to_relpath,
  parse_optional_semicolon,
  parse_required_semicolon
};

from parsing::types use { ParsedType, parse_type_expr, skip_angle_brackets, skip_type_expr };

from parsing::expr_stmt_types use {
  ParsedExpr,
  ParsedMain,
  ParsedStmt,
  ParsedParams,
  ParsedExprAst
};

from parsing::expr_stmt use {
  parse_expr,
  parse_stmt,
  parse_main_body,
  parse_mut_opt,
  is_assign_stmt_start,
  is_field_assign_stmt_start,
  is_index_assign_stmt_start,
  parse_expr_ast
};

from parsing::decls_legacy use {
  ParsedImports,
  ParsedFn,
  parse_imports,
  parse_extern_decl,
  parse_module_decl,
  parse_fn_decl2,
  parse_class_fn_decl2,
  parse_struct_decl,
  parse_type_union_decl,
  parse_param_list,
  parse_fn_decl_named,
  parse_fn_decl
};

from parsing::decls use {
  ParsedDeclAst,
  ParsedDeclsAst,
  parse_imports_ast,
  parse_extern_decl_ast,
  parse_module_decl_ast,
  parse_fn_decl_ast2,
  parse_class_fn_decl_ast2,
  parse_struct_decl_ast,
  parse_type_union_decl_ast,
  parse_type_params_list_ast
};

from ast use {
  span,
  span_start,
  span_end,
  decl_let,
  decl_let_typed
};

from emit::ast_js use { emit_decl_js };
from emit::emit_helpers use { set_current_file_path, emit_runtime_vec_imports_js, decls_needs_vec_rt };

from analyzer use { analyze_program, analyze_program_with_fns, mk_fn_sig, check_file_size };

// Whitespace-preserving tooling support (formatter/refactors).
from util::formatting use { ParsedProgramWithTrivia, parse_program_with_trivia };

// LSP implementation split out of this facade.
from compile::lsp_check use { lsp_check_file_impl };
from compile::lsp_definition use { DefLocation, lsp_find_definition_impl };

from compile::string_lists use { str_list_contains, str_list_remove };
from compile::deprecation_comments use { parse_deprecated_reason_from_comment, deprecation_reason_before };

from compile::export_scan use { module_index, fnsig_lookup_by_name, scan_top_level_fn_exports };
from compile::export_scan_cache use { cached_scan_top_level_fn_exports };
from compile::paths use { workspace_root_from_path, compiler_root_from_path };
from compile::project_compile use {
  collect_module_graph_info,
  project_compile_one_module_with,
  project_lint_one_module_with
};

// NOTE: Some TypeScript tests use simple string offsets into this *source file*
// to exercise the prebuilt LSP logic. Keep a small, real "type mention in a
// signature" here so those offsets remain meaningful.
struct LspRef {
  tag: String
}

fn __lsp_type_mention_smoke(x: Vec<LspRef>) : Void => {
  // Intentionally empty.
}

// ------------------------------------------------------------
// Helpers
// ------------------------------------------------------------

fn kw_at(src: String, i: I32, kw: String) : Bool => {
  // Keyword match that rejects identifier continuations.
  if (!starts_with_at(src, i, kw)) { yield false; }
  let end = i + stringLen(kw);
  if (end < stringLen(src) && is_ident_part(stringCharCodeAt(src, end))) { yield false; }
  true
}

fn is_extern_decl_start(src: String, i: I32) : Bool => {
  // Accept:
  //   extern from ...
  //   extern type ...
  //   out extern type ...
  let j = skip_ws(src, i);
  if (kw_at(src, j, "extern")) { yield true; }
  if (kw_at(src, j, "out")) {
    let k = skip_ws(src, j + 3);
    if (kw_at(src, k, "extern")) { yield true; }
  }
  false
}

// ------------------------------------------------------------
// In-process caching (optional speed-up)
//
// Bun/Node caches ESM modules by path; our tests and tooling sometimes call
// lint/compile multiple times within the same process. Export scanning is a
// pure function of file content, and files are stable during a single run.
// ------------------------------------------------------------

// (moved to compile::export_scan_cache)

fn parse_program_with_trivia_api(src: String, exportAll: Bool) : ParsedProgramWithTrivia => {
  parse_program_with_trivia(src, exportAll)
}

fn compile_tiny2(src: String, requireMain: Bool, exportAll: Bool, filePath: String) : String =>
  compile_tiny2_with_imported_fns(src, requireMain, exportAll, filePath, vec_new())

fn compile_tiny2_with_imported_fns(src: String, requireMain: Bool, exportAll: Bool, filePath: String, importedFns: Vec<FnSig>) : String => {
  // Parse:
  //   (extern from <mod> use { <idents> };)*
  //   (from <mod> use { <idents> };)*
  //   (type <ident>(<typeparams>)? = <variants>;)*
  //   (struct <ident> { <fields> })*
  //   (let <ident> = <expr>;)*
  //   (fn <ident>(<params>) => <expr|block>)*
  let mut i = 0;

  // Reset per-file state.
  reset_struct_defs();
  reset_errors();
  reset_warnings();

  let mut out = "// compiled by selfhost tuffc\n";

  // Phase 3: parse into canonical AST decls, then emit JS.
  let decls = vec_new();

  // zero or more extern declarations
  while (true) {
    if (is_extern_decl_start(src, i)) {
      let ex = parse_extern_decl_ast(src, i);
      vec_push(decls, ex.decl);
      i = ex.nextPos;
      continue;
    }
    break;
  }

  // zero or more imports
  let imps = parse_imports_ast(src, i);
  let mut ii = 0;
  while (ii < vec_len(imps.decls)) {
    vec_push(decls, vec_get(imps.decls, ii));
    ii = ii + 1;
  }
  i = imps.nextPos;

  // Parse all declarations in any order: module, type, struct, let, fn, class fn, out fn
  let mut sawMain = false;
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "module")) {
      let m = parse_module_decl_ast(src, i);
      vec_push(decls, m.decl);
      i = m.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "type")) {
      let td = parse_type_union_decl_ast(src, i, exportAll);
      vec_push(decls, td.decl);
      i = td.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "struct")) {
      let sd = parse_struct_decl_ast(src, i);
      vec_push(decls, sd.decl);
      i = sd.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "let")) {
      let start = skip_ws(src, i);
      i = parse_keyword(src, i, "let");
      let mutOpt = parse_mut_opt(src, i);
      i = mutOpt.nextPos;
      let name = parse_ident(src, i);
      i = name.nextPos;

      // Optional let type annotation: `let x: T = ...`
      let mut tyAnn = "";
      let t0 = skip_ws(src, i);
      if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) { // ':'
        let _ty = parse_type_expr(src, t0 + 1);
        tyAnn = _ty.v0;
        i = _ty.v1;
      }

      i = parse_keyword(src, i, "=");
      let expr = parse_expr_ast(src, i);
      i = expr.nextPos;
      i = parse_optional_semicolon(src, i);
      if (tyAnn == "") {
        vec_push(decls, decl_let(span(start, i), mutOpt.ok, name.text, expr.expr));
      } else {
        vec_push(decls, decl_let_typed(span(start, i), mutOpt.ok, name.text, tyAnn, expr.expr));
      }
      continue;
    }
    if (starts_with_at(src, j, "fn")) {
      let f = parse_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "class")) {
      let f = parse_class_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DClassFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "out")) {
      // `out fn ...` or `out class fn ...`
      let k0 = parse_keyword(src, i, "out");
      let j2 = skip_ws(src, k0);
      if (starts_with_at(src, j2, "class")) {
        let f = parse_class_fn_decl_ast2(src, i, exportAll);
        if (f.decl.tag == "DClassFn" && f.decl.name == "main") { sawMain = true; }
        vec_push(decls, f.decl);
        i = f.nextPos;
        continue;
      }
      let f = parse_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    break;
  }
  if (requireMain && !sawMain) { panic_at(src, i, "expected fn main"); }

  // Phase 4 (initial): run analyzer checks before emission.
  // When compiling as part of a multi-file project, seed imported function
  // signatures so cross-file calls are validated.
  analyze_program_with_fns(src, decls, importedFns);
  panic_if_errors();
  emit_warnings();

  // Set the file path for the emitter to compute correct relative import paths
  set_current_file_path(filePath);

  // Bring in runtime vec helpers under internal aliases when the emitted JS
  // will use vec literals/indexing sugar.
  if (decls_needs_vec_rt(decls)) {
    out = out + emit_runtime_vec_imports_js();
  }

  // Emit decls in order.
  let mut di = 0;
  while (di < vec_len(decls)) {
    out = out + emit_decl_js(vec_get(decls, di), exportAll);
    di = di + 1;
  }

  out
}

fn lint_tiny2_with_imported_fns(src: String, requireMain: Bool, exportAll: Bool, importedFns: Vec<FnSig>) : Void => {
  // Parse and analyze like compile_tiny2_with_imported_fns, but do not emit JS.
  let mut i = 0;

  // Reset per-file state.
  reset_struct_defs();
  reset_errors();
  reset_warnings();

  // Check file size first (before parsing).
  check_file_size(src);

  let decls = vec_new();

  // zero or more extern declarations
  while (true) {
    if (is_extern_decl_start(src, i)) {
      let ex = parse_extern_decl_ast(src, i);
      vec_push(decls, ex.decl);
      i = ex.nextPos;
      continue;
    }
    break;
  }

  // zero or more imports
  let imps = parse_imports_ast(src, i);
  let mut ii = 0;
  while (ii < vec_len(imps.decls)) {
    vec_push(decls, vec_get(imps.decls, ii));
    ii = ii + 1;
  }
  i = imps.nextPos;

  // zero or more module declarations
  // Parse all declarations in any order: module, type, struct, let, fn, class fn, out fn
  let mut sawMain = false;
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "module")) {
      let m = parse_module_decl_ast(src, i);
      vec_push(decls, m.decl);
      i = m.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "type")) {
      let td = parse_type_union_decl_ast(src, i, exportAll);
      vec_push(decls, td.decl);
      i = td.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "struct")) {
      let sd = parse_struct_decl_ast(src, i);
      vec_push(decls, sd.decl);
      i = sd.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "let")) {
      let start = skip_ws(src, i);
      i = parse_keyword(src, i, "let");
      let mutOpt = parse_mut_opt(src, i);
      i = mutOpt.nextPos;
      let name = parse_ident(src, i);
      i = name.nextPos;

      // Optional let type annotation: `let x: T = ...`
      let mut tyAnn = "";
      let t0 = skip_ws(src, i);
      if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) { // ':'
        let _ty = parse_type_expr(src, t0 + 1);
        tyAnn = _ty.v0;
        i = _ty.v1;
      }

      i = parse_keyword(src, i, "=");
      let expr = parse_expr_ast(src, i);
      i = expr.nextPos;
      i = parse_optional_semicolon(src, i);
      if (tyAnn == "") {
        vec_push(decls, decl_let(span(start, i), mutOpt.ok, name.text, expr.expr));
      } else {
        vec_push(decls, decl_let_typed(span(start, i), mutOpt.ok, name.text, tyAnn, expr.expr));
      }
      continue;
    }
    if (starts_with_at(src, j, "fn")) {
      let f = parse_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "class")) {
      let f = parse_class_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DClassFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "out")) {
      // `out fn ...` or `out class fn ...`
      let k0 = parse_keyword(src, i, "out");
      let j2 = skip_ws(src, k0);
      if (starts_with_at(src, j2, "class")) {
        let f = parse_class_fn_decl_ast2(src, i, exportAll);
        if (f.decl.tag == "DClassFn" && f.decl.name == "main") { sawMain = true; }
        vec_push(decls, f.decl);
        i = f.nextPos;
        continue;
      }
      let f = parse_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    break;
  }
  if (requireMain && !sawMain) { panic_at(src, i, "expected fn main"); }

  analyze_program_with_fns(src, decls, importedFns);
  panic_if_errors();
  emit_warnings();
}

fn lint_tiny2_collect_with_imported_fns(src: String, requireMain: Bool, exportAll: Bool, importedFns: Vec<FnSig>) => {
  // Parse and analyze like lint_tiny2_with_imported_fns, but do not panic and
  // do not print. Instead, return structured diagnostics.
  let mut i = 0;

  // Reset per-file state.
  reset_struct_defs();
  reset_errors();
  reset_warnings();

  // Check file size first (before parsing).
  check_file_size(src);

  let decls = vec_new();

  // zero or more extern declarations
  while (true) {
    if (is_extern_decl_start(src, i)) {
      let ex = parse_extern_decl_ast(src, i);
      vec_push(decls, ex.decl);
      i = ex.nextPos;
      continue;
    }
    break;
  }

  // zero or more imports
  let imps = parse_imports_ast(src, i);
  let mut ii = 0;
  while (ii < vec_len(imps.decls)) {
    vec_push(decls, vec_get(imps.decls, ii));
    ii = ii + 1;
  }
  i = imps.nextPos;

  // Parse all declarations in any order: module, type, struct, let, fn, class fn, out fn
  let mut sawMain = false;
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "module")) {
      let m = parse_module_decl_ast(src, i);
      vec_push(decls, m.decl);
      i = m.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "type")) {
      let td = parse_type_union_decl_ast(src, i, exportAll);
      vec_push(decls, td.decl);
      i = td.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "struct")) {
      let sd = parse_struct_decl_ast(src, i);
      vec_push(decls, sd.decl);
      i = sd.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "let")) {
      let start = skip_ws(src, i);
      i = parse_keyword(src, i, "let");
      let mutOpt = parse_mut_opt(src, i);
      i = mutOpt.nextPos;
      let name = parse_ident(src, i);
      i = name.nextPos;

      // Optional let type annotation: `let x: T = ...`
      let mut tyAnn = "";
      let t0 = skip_ws(src, i);
      if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) { // ':'
        let _ty = parse_type_expr(src, t0 + 1);
        tyAnn = _ty.v0;
        i = _ty.v1;
      }

      i = parse_keyword(src, i, "=");
      let expr = parse_expr_ast(src, i);
      i = expr.nextPos;
      i = parse_optional_semicolon(src, i);
      if (tyAnn == "") {
        vec_push(decls, decl_let(span(start, i), mutOpt.ok, name.text, expr.expr));
      } else {
        vec_push(decls, decl_let_typed(span(start, i), mutOpt.ok, name.text, tyAnn, expr.expr));
      }
      continue;
    }
    if (starts_with_at(src, j, "fn")) {
      let f = parse_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "class")) {
      let f = parse_class_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DClassFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "out")) {
      // `out fn ...` or `out class fn ...`
      let k0 = parse_keyword(src, i, "out");
      let j2 = skip_ws(src, k0);
      if (starts_with_at(src, j2, "class")) {
        let f = parse_class_fn_decl_ast2(src, i, exportAll);
        if (f.decl.tag == "DClassFn" && f.decl.name == "main") { sawMain = true; }
        vec_push(decls, f.decl);
        i = f.nextPos;
        continue;
      }
      let f = parse_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    break;
  }
  if (requireMain && !sawMain) { panic_at(src, i, "expected fn main"); }

  analyze_program_with_fns(src, decls, importedFns);

  (get_error_infos(), get_warning_infos())
}

fn compile_tiny(src: String) : String => compile_tiny2(src, true, false, "main.mjs")
fn compile_module(src: String) : String => compile_tiny2(src, false, true, "module.mjs")

// ------------------------------------------------------------
// Multi-file: export tables + import validation (Phase 5)
// ------------------------------------------------------------
// (moved to compile::export_scan)

// ------------------------------------------------------------
// In-memory compilation API (Option 4 building block)
// ------------------------------------------------------------

fn mem_read(entryCode: String, moduleLookup: (String) => String, key: String) : String => {
  if (key == "entry") { yield entryCode; }
  moduleLookup(key)
}

fn mem_collect_module_graph_info(entryCode: String, moduleLookup: (String) => String, isCompilerBuild: Bool) => {
  let entryKey = "entry";

  let mut stack = vec_new();
  vec_push(stack, entryKey);

  let mut visited = vec_new();
  let mut visiting = vec_new();
  let mut order = vec_new();
  let mut moduleKeys = vec_new();
  let mut moduleOutFns = vec_new();
  let mut modulePrivateTopLevelFnNames = vec_new();

  while (vec_len(stack) > 0) {
    let item = vec_get(stack, vec_len(stack) - 1);

    // pop
    let mut newStack = vec_new();
    let mut qi = 0;
    while (qi + 1 < vec_len(stack)) {
      vec_push(newStack, vec_get(stack, qi));
      qi = qi + 1;
    }
    stack = newStack;

    if (starts_with_at(item, 0, "POST:")) {
      let key = stringSlice(item, 5, stringLen(item));
      visiting = str_list_remove(visiting, key);
      vec_push(order, key);
      continue;
    }

    let key = item;
    if (str_list_contains(visited, key)) { continue; }
    vec_push(visited, key);
    vec_push(visiting, key);

    vec_push(stack, "POST:" + key);

    let src = mem_read(entryCode, moduleLookup, key);
    set_current_file(key);

    let ex = cached_scan_top_level_fn_exports(key, src);
    vec_push(moduleKeys, key);
    if (isCompilerBuild) {
      vec_push(moduleOutFns, ex.2);
      vec_push(modulePrivateTopLevelFnNames, vec_new());
    } else {
      vec_push(moduleOutFns, ex.0);
      vec_push(modulePrivateTopLevelFnNames, ex.1);
    }

    // discover imports
    let mut scan = 0;
    while (true) {
      if (is_extern_decl_start(src, scan)) {
        let ex2 = parse_extern_decl(src, scan);
        scan = ex2.v1;
        continue;
      }
      break;
    }

    while (true) {
      let j = skip_ws(src, scan);
      if (starts_with_at(src, j, "import")) {
        panic_at(src, j, "`import` is not supported. Use `from <module> use { ... };` instead.");
      }
      if (!starts_with_at(src, j, "from")) { break; }
      scan = parse_keyword(src, scan, "from");
      let mod = parse_module_path(src, scan);
      scan = mod.nextPos;
      scan = parse_keyword(src, scan, "use");
      scan = parse_keyword(src, scan, "{");
      while (true) {
        scan = skip_ws(src, scan);
        if (!(scan < stringLen(src))) { panic_at(src, scan, "expected '}'"); }
        if (stringCharCodeAt(src, scan) == 125) { scan = scan + 1; break; }
        let id = parse_ident(src, scan);
        scan = id.nextPos;
        scan = skip_ws(src, scan);
        if (scan < stringLen(src) && stringCharCodeAt(src, scan) == 44) { scan = scan + 1; continue; }
        scan = skip_ws(src, scan);
        if (scan < stringLen(src) && stringCharCodeAt(src, scan) == 125) { scan = scan + 1; break; }
        panic_at(src, scan, "expected ',' or '}' in import list");
      }
      scan = parse_optional_semicolon(src, scan);

      let depKey = mod.text;
      if (!str_list_contains(visiting, depKey)) {
        // Allow module cycles. The graph walk uses `visited` to avoid infinite
        // recursion; here we just skip the back-edge.
        vec_push(stack, depKey);
      }
    }
  }

  (order, moduleKeys, moduleOutFns, modulePrivateTopLevelFnNames)
}

fn mem_imported_fn_sigs(src: String, key: String, isCompilerBuild: Bool, moduleKeys: Vec<String>, moduleOutFns: Vec<Vec<FnSig>>, modulePrivateTopLevelFnNames: Vec<Vec<String>>) : Vec<FnSig> => {
  let importedFns = vec_new();
  let seedImportedFns = !isCompilerBuild;

  if (!isCompilerBuild) {
    let mut scan = 0;
    while (true) {
      if (is_extern_decl_start(src, scan)) {
        let ex2 = parse_extern_decl(src, scan);
        scan = ex2.v1;
        continue;
      }
      break;
    }

    let impsAst = parse_imports_ast(src, scan);
    let mut ii = 0;
    while (ii < vec_len(impsAst.decls)) {
      let imp = vec_get(impsAst.decls, ii);
      if (imp.tag == "DImport") {
        let depKey = imp.modulePath;
        let depIdx = module_index(moduleKeys, depKey);
        if (depIdx != -1) {
          let outFns = vec_get(moduleOutFns, depIdx);
          let privateNames = vec_get(modulePrivateTopLevelFnNames, depIdx);
          let mut ni = 0;
          while (ni < vec_len(imp.names)) {
            let name = vec_get(imp.names, ni);

            let sig = fnsig_lookup_by_name(outFns, name);
            if (!(sig.name == "")) {
              if (seedImportedFns) {
                vec_push(importedFns, sig);
              }
            } else {
              if (str_list_contains(privateNames, name)) {
                panic_at(src, span_start(imp.span), "imported function '" + name + "' is not exported (missing `out fn`)");
              }
            }

            ni = ni + 1;
          }
        }
      }
      ii = ii + 1;
    }
  }

  importedFns
}

// Compile entryCode and all reachable modules via moduleLookup.
// Returns (outRelPaths, jsOutputs) aligned by index.
out fn compile_code(entryCode: String, moduleLookup: (String) => String) => {
  // For in-memory compilation we always enforce `out` visibility.
  let isCompilerBuild = false;

  let graph = mem_collect_module_graph_info(entryCode, moduleLookup, isCompilerBuild);
  let order = graph.0;
  let moduleKeys = graph.1;
  let moduleOutFns = graph.2;
  let modulePrivateTopLevelFnNames = graph.3;

  let outRelPaths = vec_new();
  let jsOutputs = vec_new();

  let mut oi = 0;
  while (oi < vec_len(order)) {
    let key = vec_get(order, oi);
    let src = mem_read(entryCode, moduleLookup, key);
    set_current_file(key);

    let importedFns = mem_imported_fn_sigs(src, key, isCompilerBuild, moduleKeys, moduleOutFns, modulePrivateTopLevelFnNames);
    let outRelPath = if (key == "entry") "entry.mjs" else (module_path_to_relpath(key) + ".mjs");

    let js = compile_tiny2_with_imported_fns(src, key == "entry", isCompilerBuild, outRelPath, importedFns);
    vec_push(outRelPaths, outRelPath);
    vec_push(jsOutputs, js);

    oi = oi + 1;
  }

  (outRelPaths, jsOutputs)
}

// Lint entryCode and all reachable modules via moduleLookup.
// Returns (allErrors, allWarnings) as Vec<DiagInfo>.
out fn lint_code(entryCode: String, moduleLookup: (String) => String) => {
  let isCompilerBuild = false;

  let graph = mem_collect_module_graph_info(entryCode, moduleLookup, isCompilerBuild);
  let order = graph.0;
  let moduleKeys = graph.1;
  let moduleOutFns = graph.2;
  let modulePrivateTopLevelFnNames = graph.3;

  let allErrors = vec_new();
  let allWarnings = vec_new();

  let mut oi = 0;
  while (oi < vec_len(order)) {
    let key = vec_get(order, oi);
    let src = mem_read(entryCode, moduleLookup, key);
    set_current_file(key);

    let importedFns = mem_imported_fn_sigs(src, key, isCompilerBuild, moduleKeys, moduleOutFns, modulePrivateTopLevelFnNames);
    let r = lint_tiny2_collect_with_imported_fns(src, key == "entry", isCompilerBuild, importedFns);

    // accumulate
    let errs = r.0;
    let warns = r.1;

    let mut ei = 0;
    while (ei < vec_len(errs)) {
      vec_push(allErrors, vec_get(errs, ei));
      ei = ei + 1;
    }
    let mut wi = 0;
    while (wi < vec_len(warns)) {
      vec_push(allWarnings, vec_get(warns, wi));
      wi = wi + 1;
    }

    oi = oi + 1;
  }

  (allErrors, allWarnings)
}

out fn compile_project(entryPath: String, outPath: String) : Void => {
  // Very small multi-file compiler:
  // - supports `from <path> use { ... };` for local file modules
  // - all module paths are resolved relative to the entry file's directory
  // - emits to the same relative path under outDir: <path>.mjs

  let outDir = pathDirname(outPath);
  let workspaceRoot = workspace_root_from_path(entryPath);
  let isCompilerBuild = stringLen(compiler_root_from_path(entryPath)) > 0;

  let graph = collect_module_graph_info(entryPath, workspaceRoot, isCompilerBuild, readTextFile);
  let order = graph.0;
  let modulePaths = graph.1;
  let moduleOutFns = graph.2;
  let modulePrivateTopLevelFnNames = graph.3;

  // Second pass: compile in topo order.
  let mut oi = 0;
  while (oi < vec_len(order)) {
    let path = vec_get(order, oi);
    set_current_file(path);
    let src = readTextFile(path);

    let r = project_compile_one_module_with(
      compile_tiny2_with_imported_fns,
      src,
      path,
      entryPath,
      outDir,
      outPath,
      workspaceRoot,
      isCompilerBuild,
      modulePaths,
      moduleOutFns,
      modulePrivateTopLevelFnNames
    );
    let outFile = r.1;
    let js = r.2;
    writeTextFile(outFile, js);

    oi = oi + 1;
  }
}

// Like compile_project, but does not write anything. Callers provide a reader
// callback for sourcing files and then can decide where/how to write.
// Returns (outFiles, jsOutputs) aligned by index.
out fn compile_project_to_outputs(entryPath: String, outPath: String, readSource: (String) => String) => {
  let outDir = pathDirname(outPath);
  let workspaceRoot = workspace_root_from_path(entryPath);
  let isCompilerBuild = stringLen(compiler_root_from_path(entryPath)) > 0;

  let graph = collect_module_graph_info(entryPath, workspaceRoot, isCompilerBuild, readSource);
  let order = graph.0;
  let modulePaths = graph.1;
  let moduleOutFns = graph.2;
  let modulePrivateTopLevelFnNames = graph.3;

  let outFiles = vec_new();
  let jsOutputs = vec_new();

  let mut oi = 0;
  while (oi < vec_len(order)) {
    let path = vec_get(order, oi);
    set_current_file(path);
    let src = readSource(path);

    let r = project_compile_one_module_with(
      compile_tiny2_with_imported_fns,
      src,
      path,
      entryPath,
      outDir,
      outPath,
      workspaceRoot,
      isCompilerBuild,
      modulePaths,
      moduleOutFns,
      modulePrivateTopLevelFnNames
    );
    let outFile = r.1;
    let js = r.2;
    vec_push(outFiles, outFile);
    vec_push(jsOutputs, js);

    oi = oi + 1;
  }

  (outFiles, jsOutputs)
}

out fn fluff_project(entryPath: String) : Void => {
  // Like compile_project, but only parse+analyze and emit warnings.
  // No JS is generated and nothing is written to disk.

  fluff_project_with_reader(entryPath, readTextFile);
}

// Like fluff_project, but the caller provides the source reader callback.
out fn fluff_project_with_reader(entryPath: String, readSource: (String) => String) : Void => {
  let workspaceRoot = workspace_root_from_path(entryPath);
  let isCompilerBuild = stringLen(compiler_root_from_path(entryPath)) > 0;

  let graph = collect_module_graph_info(entryPath, workspaceRoot, isCompilerBuild, readSource);
  let order = graph.0;
  let modulePaths = graph.1;
  let moduleOutFns = graph.2;
  let modulePrivateTopLevelFnNames = graph.3;

  // Second pass: lint in topo order.
  let mut oi = 0;
  while (oi < vec_len(order)) {
    let path = vec_get(order, oi);
    set_current_file(path);
    let src = readSource(path);

    project_lint_one_module_with(
      lint_tiny2_with_imported_fns,
      src,
      path,
      entryPath,
      workspaceRoot,
      isCompilerBuild,
      modulePaths,
      moduleOutFns,
      modulePrivateTopLevelFnNames
    );
    oi = oi + 1;
  }
}

// ------------------------------------------------------------
// LSP API: parse+analyze a single file and collect diagnostics
// without panicking. Returns false if there are errors.
// ------------------------------------------------------------

out fn lsp_check_file(src: String, filePath: String) : Bool => {
  lsp_check_file_impl(src, filePath)
}

// Re-export diagnostic accessors for TypeScript interop.
out fn lsp_get_errors() : Vec<DiagInfo> => get_error_infos()
out fn lsp_get_warnings() : Vec<DiagInfo> => get_warning_infos()
out fn lsp_line_col(src: String, offset: I32) : LineCol => line_col_at(src, offset)

// Main LSP go-to-definition API.
out fn lsp_find_definition(src: String, offset: I32, filePath: String) : DefLocation =>
  lsp_find_definition_impl(src, offset, filePath)
