// Self-hosted compiler (first whack)
//
// This is a *very* small compiler written in Tuff, intended to prove the loop:
//   bootstrap TS compiler -> emits JS -> JS runs and can compile a tiny subset.
//
// For now, it compiles only a restricted input shape:
//   fn main() => <number>
//   fn main() => { <number> }
//
// Output is ESM that exports `main`.
//
// NOTE: This file contains the compiler implementation.
// The CLI entrypoint lives in `selfhost/tuffc.tuff`.

extern from rt::stdlib use { println, panic, readTextFile, writeTextFile, pathDirname, pathJoin, stringLen, stringSlice, stringCharCodeAt, stringFromCharCode };

extern from rt::vec use { vec_new, vec_len, vec_push, vec_get };

from util::diagnostics use {
  set_current_file,
  panic_at,
  reset_struct_defs,
  add_struct_def,
  find_struct_fields,
  is_identifier_too_short,
  warn_short_identifier
};

from util::lexing use {
  is_digit,
  is_space,
  is_ident_start,
  is_ident_part,
  skip_ws,
  starts_with_at
};

from parsing::primitives use {
  ParsedNumber,
  ParsedIdent,
  ParsedBool,
  parse_keyword,
  parse_number,
  parse_ident,
  parse_module_path,
  module_path_to_relpath,
  parse_optional_semicolon,
  parse_required_semicolon
};

from parsing::types use { ParsedType, parse_type_expr, skip_angle_brackets, skip_type_expr };

from parsing::expr_stmt use {
  ParsedExpr,
  ParsedMain,
  ParsedStmt,
  ParsedParams,
  parse_expr,
  parse_stmt,
  parse_main_body,
  parse_mut_opt,
  is_assign_stmt_start,
  is_field_assign_stmt_start,
  is_index_assign_stmt_start
};

from parsing::expr_stmt use {
  ParsedExprAst,
  parse_expr_ast
};

from parsing::decls use {
  ParsedImports,
  ParsedFn,
  parse_imports,
  parse_extern_decl,
  parse_module_decl,
  parse_fn_decl2,
  parse_class_fn_decl2,
  parse_struct_decl,
  parse_type_union_decl,
  parse_param_list,
  parse_fn_decl_named,
  parse_fn_decl
};

from parsing::decls use {
  ParsedDeclAst,
  ParsedDeclsAst,
  parse_imports_ast,
  parse_extern_decl_ast,
  parse_module_decl_ast,
  parse_fn_decl_ast2,
  parse_class_fn_decl_ast2,
  parse_struct_decl_ast,
  parse_type_union_decl_ast
};

from ast use {
  span,
  decl_let,
  decl_let_typed
};

from emit::ast_js use { emit_decl_js, set_current_file_path, emit_runtime_vec_imports_js, decls_needs_vec_rt };

from analyzer use { analyze_program };

// Whitespace-preserving tooling support (formatter/refactors).
from util::formatting use { ParsedProgramWithTrivia, parse_program_with_trivia };

fn parse_program_with_trivia_api(src: String, exportAll: Bool) : ParsedProgramWithTrivia => {
  parse_program_with_trivia(src, exportAll)
}

fn compile_tiny2(src: String, requireMain: Bool, exportAll: Bool, filePath: String) : String => {
  // Parse:
  //   (extern from <mod> use { <idents> };)*
  //   (from <mod> use { <idents> };)*
  //   (type <ident>(<typeparams>)? = <variants>;)*
  //   (struct <ident> { <fields> })*
  //   (let <ident> = <expr>;)*
  //   (fn <ident>(<params>) => <expr|block>)*
  let mut i = 0;

  // Reset per-file state.
  reset_struct_defs();

  let mut out = "// compiled by selfhost tuffc\n";

  // Phase 3: parse into canonical AST decls, then emit JS.
  let decls = vec_new();

  // zero or more extern declarations
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "extern")) {
      let ex = parse_extern_decl_ast(src, i);
      vec_push(decls, ex.decl);
      i = ex.nextPos;
      continue;
    }
    break;
  }

  // zero or more imports
  let imps = parse_imports_ast(src, i);
  let mut ii = 0;
  while (ii < vec_len(imps.decls)) {
    vec_push(decls, vec_get(imps.decls, ii));
    ii = ii + 1;
  }
  i = imps.nextPos;

  // zero or more module declarations
  while (true) {
    let j = skip_ws(src, i);
    if (!starts_with_at(src, j, "module")) { break; }
    let m = parse_module_decl_ast(src, i);
    vec_push(decls, m.decl);
    i = m.nextPos;
  }

  // zero or more type / struct declarations
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "type")) {
      let td = parse_type_union_decl_ast(src, i, exportAll);
      vec_push(decls, td.decl);
      i = td.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "struct")) {
      let sd = parse_struct_decl_ast(src, i);
      vec_push(decls, sd.decl);
      i = sd.nextPos;
      continue;
    }
    break;
  }

  // zero or more let statements
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "let")) {
      let start = skip_ws(src, i);
      i = parse_keyword(src, i, "let");
      let mutOpt = parse_mut_opt(src, i);
      i = mutOpt.nextPos;
      let name = parse_ident(src, i);
      i = name.nextPos;

      // Optional let type annotation: `let x: T = ...`
      let mut tyAnn = "";
      let t0 = skip_ws(src, i);
      if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) { // ':'
        let _ty = parse_type_expr(src, t0 + 1);
        tyAnn = _ty.v0;
        i = _ty.v1;
      }

      i = parse_keyword(src, i, "=");
      let expr = parse_expr_ast(src, i);
      i = expr.nextPos;
      i = parse_optional_semicolon(src, i);
      if (tyAnn == "") {
        vec_push(decls, decl_let(span(start, i), mutOpt.ok, name.text, expr.expr));
      } else {
        vec_push(decls, decl_let_typed(span(start, i), mutOpt.ok, name.text, tyAnn, expr.expr));
      }
      continue;
    }
    break;
  }

  // main
  let mut sawMain = false;
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "fn")) {
      let f = parse_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "class")) {
      let f = parse_class_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DClassFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    break;
  }
  if (requireMain && !sawMain) { panic_at(src, i, "expected fn main"); }

  // Phase 4 (initial): run analyzer checks before emission.
  analyze_program(src, decls);

  // Set the file path for the emitter to compute correct relative import paths
  set_current_file_path(filePath);

  // Bring in runtime vec helpers under internal aliases when the emitted JS
  // will use vec literals/indexing sugar.
  if (decls_needs_vec_rt(decls)) {
    out = out + emit_runtime_vec_imports_js();
  }

  // Emit decls in order.
  let mut di = 0;
  while (di < vec_len(decls)) {
    out = out + emit_decl_js(vec_get(decls, di), exportAll);
    di = di + 1;
  }

  out
}

fn compile_tiny(src: String) : String => compile_tiny2(src, true, false, "main.tuff")
fn compile_module(src: String) : String => compile_tiny2(src, false, true, "module.tuff")

fn find_substring(hay: String, needle: String) : I32 => {
  let mut i = 0;
  while (i + stringLen(needle) <= stringLen(hay)) {
    if (starts_with_at(hay, i, needle)) { yield i; }
    i = i + 1;
  }
  -1
}

fn workspace_root_from_path(p: String) : String => {
  // Try to find a stable staging/workspace root by trimming at common anchors.
  let mut i = find_substring(p, "\\src\\");
  if (i != -1) { yield stringSlice(p, 0, i); }
  i = find_substring(p, "/src/");
  if (i != -1) { yield stringSlice(p, 0, i); }
  i = find_substring(p, "\\std\\");
  if (i != -1) { yield stringSlice(p, 0, i); }
  i = find_substring(p, "/std/");
  if (i != -1) { yield stringSlice(p, 0, i); }
  pathDirname(p)
}

fn compiler_root_from_path(p: String) : String => {
  // If we're compiling a compiler source file, resolve short module paths from
  // the compiler root: <root>/src/main/tuff/compiler/
  let needle1 = "\\src\\main\\tuff\\compiler\\";
  let mut i = find_substring(p, needle1);
  if (i != -1) { yield stringSlice(p, 0, i + stringLen(needle1)); }
  let needle2 = "/src/main/tuff/compiler/";
  i = find_substring(p, needle2);
  if (i != -1) { yield stringSlice(p, 0, i + stringLen(needle2)); }
  ""
}

fn compile_project(entryPath: String, outPath: String) : Void => {
  // Very small multi-file compiler:
  // - supports `from <path> use { ... };` for local file modules
  // - all module paths are resolved relative to the entry file's directory
  // - emits to the same relative path under outDir: <path>.mjs

  let outDir = pathDirname(outPath);
  let entryDir = pathDirname(entryPath);
  let workspaceRoot = workspace_root_from_path(entryPath);

  let mut queue = vec_new();
  vec_push(queue, entryPath);

  let mut done = vec_new();

  while (vec_len(queue) > 0) {
    let path = vec_get(queue, vec_len(queue) - 1);

    // set current file for better error messages
    set_current_file(path);
    // pop
    // (no vec_pop; emulate by shrinking via set+len conventions isn't available,
    //  so we'll use a simple index-based loop instead)
    // We'll just process the last item and rebuild the queue without it.
    let mut newQ = vec_new();
    let mut qi = 0;
    while (qi + 1 < vec_len(queue)) {
      vec_push(newQ, vec_get(queue, qi));
      qi = qi + 1;
    }
    queue = newQ;

    // skip if already done
    let mut already = false;
    let mut di = 0;
    while (di < vec_len(done)) {
      if (vec_get(done, di) == path) { already = true; break; }
      di = di + 1;
    }
    if (already) { continue; }
    vec_push(done, path);

    let src = readTextFile(path);

    // discover imports for queueing (same parsing as emitter)
    let mut scan = 0;
    // skip externs
    while (true) {
      let j = skip_ws(src, scan);
      if (starts_with_at(src, j, "extern")) {
        let ex = parse_extern_decl(src, scan);
        scan = ex.v1;
        continue;
      }
      break;
    }
    while (true) {
      let j = skip_ws(src, scan);
      if (starts_with_at(src, j, "import")) {
        panic_at(src, j, "`import` is not supported. Use `from <module> use { ... };` instead.");
      }
      if (!starts_with_at(src, j, "from")) { break; }
      scan = parse_keyword(src, scan, "from");
      let mod = parse_module_path(src, scan);
      scan = mod.nextPos;
      scan = parse_keyword(src, scan, "use");
      scan = parse_keyword(src, scan, "{");
      // consume name list
      while (true) {
        scan = skip_ws(src, scan);
        if (!(scan < stringLen(src))) { panic_at(src, scan, "expected '}'"); }
        if (stringCharCodeAt(src, scan) == 125) { scan = scan + 1; break; }
        let id = parse_ident(src, scan);
        scan = id.nextPos;
        scan = skip_ws(src, scan);
        if (scan < stringLen(src) && stringCharCodeAt(src, scan) == 44) { scan = scan + 1; continue; }
        scan = skip_ws(src, scan);
        if (scan < stringLen(src) && stringCharCodeAt(src, scan) == 125) { scan = scan + 1; break; }
        panic_at(src, scan, "expected ',' or '}' in import list");
      }
      scan = parse_optional_semicolon(src, scan);

      // queue dependency file
      let rel = module_path_to_relpath(mod.text);

      // Resolve:
      // - `src::...` and `std::...` from workspace root (staging root)
      // - compiler-internal short paths from the compiler root when applicable
      // - otherwise from the importing file's directory
      let mut baseDir = pathDirname(path);
      if (starts_with_at(mod.text, 0, "src::") || starts_with_at(mod.text, 0, "std::")) {
        baseDir = workspaceRoot;
      } else {
        let cr = compiler_root_from_path(path);
        if (stringLen(cr) > 0) { baseDir = cr; }
      }

      let depPath = pathJoin(baseDir, rel + ".tuff");
      vec_push(queue, depPath);
    }

    // Compute entry-dir-relative path for correct JS import emission.
    let mut prefixLen = stringLen(entryDir);
    let mut relStart = prefixLen;
    if (relStart < stringLen(path)) {
      let ch = stringCharCodeAt(path, relStart);
      if (ch == 47 || ch == 92) { relStart = relStart + 1; }
    }
    let relPath = stringSlice(path, relStart, stringLen(path));
    let relNoExt = stringSlice(relPath, 0, stringLen(relPath) - 5);

    // choose output name first (before emit)
    let outFile = if (path == entryPath) outPath else pathJoin(outDir, relNoExt + ".mjs");

    // Pass relPath to the emitter (not the absolute path).
    let js = if (path == entryPath) compile_tiny2(src, true, false, relPath) else compile_tiny2(src, false, true, relPath);
    writeTextFile(outFile, js);
  }
}
	