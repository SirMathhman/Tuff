// Self-hosted compiler (first whack)
//
// This is a *very* small compiler written in Tuff, intended to prove the loop:
//   bootstrap TS compiler -> emits JS -> JS runs and can compile a tiny subset.
//
// For now, it compiles only a restricted input shape:
//   fn main() => <number>
//   fn main() => { <number> }
//
// Output is ESM that exports `main`.
//
// NOTE: This file contains the compiler implementation.
// The CLI entrypoint lives in `selfhost/tuffc.tuff`.

extern from rt::stdlib use { println, panic, readTextFile, writeTextFile, pathDirname, pathJoin, stringLen, stringSlice, stringCharCodeAt, stringFromCharCode };

extern from rt::vec use { vec_new, vec_len, vec_push, vec_get };

from util::diagnostics use {
  set_current_file,
  panic_at,
  reset_errors,
  reset_warnings,
  panic_if_errors,
  emit_errors,
  emit_warnings,
  reset_struct_defs,
  add_struct_def,
  find_struct_fields,
  is_identifier_too_short,
  warn_short_identifier,
  get_error_infos,
  get_warning_infos,
  get_current_file,
  line_col_at,
  DiagInfo,
  LineCol
};

from util::lexing use {
  is_digit,
  is_space,
  is_ident_start,
  is_ident_part,
  skip_ws,
  starts_with_at
};

from parsing::primitives use {
  ParsedNumber,
  ParsedIdent,
  ParsedBool,
  parse_keyword,
  parse_number,
  parse_ident,
  parse_module_path,
  module_path_to_relpath,
  parse_optional_semicolon,
  parse_required_semicolon
};

from parsing::types use { ParsedType, parse_type_expr, skip_angle_brackets, skip_type_expr };

from parsing::expr_stmt_types use {
  ParsedExpr,
  ParsedMain,
  ParsedStmt,
  ParsedParams,
  ParsedExprAst
};

from parsing::expr_stmt use {
  parse_expr,
  parse_stmt,
  parse_main_body,
  parse_mut_opt,
  is_assign_stmt_start,
  is_field_assign_stmt_start,
  is_index_assign_stmt_start,
  parse_expr_ast
};

from parsing::decls_legacy use {
  ParsedImports,
  ParsedFn,
  parse_imports,
  parse_extern_decl,
  parse_module_decl,
  parse_fn_decl2,
  parse_class_fn_decl2,
  parse_struct_decl,
  parse_type_union_decl,
  parse_param_list,
  parse_fn_decl_named,
  parse_fn_decl
};

from parsing::decls use {
  ParsedDeclAst,
  ParsedDeclsAst,
  parse_imports_ast,
  parse_extern_decl_ast,
  parse_module_decl_ast,
  parse_fn_decl_ast2,
  parse_class_fn_decl_ast2,
  parse_struct_decl_ast,
  parse_type_union_decl_ast,
  parse_type_params_list_ast
};

from ast use {
  span,
  span_start,
  span_end,
  decl_let,
  decl_let_typed
};

from emit::ast_js use { emit_decl_js };
from emit::emit_helpers use { set_current_file_path, emit_runtime_vec_imports_js, decls_needs_vec_rt };


// Single-file compilation operations.
from compile::single_file_ops use {
  compile_tiny2_with_imported_fns,
  lint_tiny2_with_imported_fns,
  lint_tiny2_collect_with_imported_fns
};

from analyzer use { analyze_program, analyze_program_with_fns, mk_fn_sig, check_file_size };

// Whitespace-preserving tooling support (formatter/refactors).
from util::formatting use { ParsedProgramWithTrivia, parse_program_with_trivia };

// LSP implementation split out of this facade.
from compile::lsp_check use { lsp_check_file_impl };
from compile::lsp_definition use { DefLocation, lsp_find_definition_impl };

from compile::string_lists use { str_list_contains, str_list_remove };
from compile::deprecation_comments use { parse_deprecated_reason_from_comment, deprecation_reason_before };

from compile::export_scan use { module_index, fnsig_lookup_by_name, scan_top_level_fn_exports };
from compile::export_scan_cache use { cached_scan_top_level_fn_exports };
from compile::paths use { workspace_root_from_path, compiler_root_from_path };
from compile::project_compile use {
  collect_module_graph_info,
  project_compile_one_module_with,
  project_lint_one_module_with
};
from compile::in_memory use { compile_code_with, lint_code_with };

// NOTE: Some TypeScript tests use simple string offsets into this *source file*
// to exercise the prebuilt LSP logic. Keep a small, real "type mention in a
// signature" here so those offsets remain meaningful.
struct LspRefLib {
  tag: String
}

fn __lsp_type_mention_smoke(x: Vec<LspRefLib>) : Void => {
  // Intentionally empty.
}

// ------------------------------------------------------------
// Helpers
// ------------------------------------------------------------

fn kw_at(src: String, i: I32, kw: String) : Bool => {
  // Keyword match that rejects identifier continuations.
  if (!starts_with_at(src, i, kw)) { yield false; }
  let end = i + stringLen(kw);
  if (end < stringLen(src) && is_ident_part(stringCharCodeAt(src, end))) { yield false; }
  true
}

fn is_extern_decl_start(src: String, i: I32) : Bool => {
  // Accept:
  //   extern from ...
  //   extern type ...
  //   out extern type ...
  // NOT extern fn (handled by fn parser)
  let j = skip_ws(src, i);
  if (kw_at(src, j, "extern")) {
    let k = skip_ws(src, j + 6);
    if (kw_at(src, k, "fn")) { yield false; }
    if (kw_at(src, k, "out")) { yield false; }
    if (kw_at(src, k, "class")) { yield false; }
    if (kw_at(src, k, "extern")) { yield false; }
    yield true;
  }
  if (kw_at(src, j, "out")) {
    let k = skip_ws(src, j + 3);
    if (kw_at(src, k, "extern")) {
      let m = skip_ws(src, k + 6);
      if (kw_at(src, m, "fn")) { yield false; }
      if (kw_at(src, m, "class")) { yield false; }
      if (kw_at(src, m, "extern")) { yield false; }
      yield true;
    }
  }
  false
}

// ------------------------------------------------------------
// In-process caching (optional speed-up)
//
// Bun/Node caches ESM modules by path; our tests and tooling sometimes call
// lint/compile multiple times within the same process. Export scanning is a
// pure function of file content, and files are stable during a single run.
// ------------------------------------------------------------

// (moved to compile::export_scan_cache)

fn parse_program_with_trivia_api(src: String, exportAll: Bool) : ParsedProgramWithTrivia => {
  parse_program_with_trivia(src, exportAll)
}

// ------------------------------------------------------------
// Multi-file: export tables + import validation (Phase 5)
// ------------------------------------------------------------
// (moved to compile::export_scan)

// ------------------------------------------------------------
// In-memory compilation API (Option 4 building block)
// ------------------------------------------------------------

// Compile entryCode and all reachable modules via moduleLookup.
// Returns (outRelPaths, jsOutputs) aligned by index.
out fn compile_code(entryCode: String, moduleLookup: (String) => String) =>
  compile_code_with(compile_tiny2_with_imported_fns, entryCode, moduleLookup)

// Lint entryCode and all reachable modules via moduleLookup.
// Returns (allErrors, allWarnings) as Vec<DiagInfo>.
out fn lint_code(entryCode: String, moduleLookup: (String) => String) =>
  lint_code_with(lint_tiny2_collect_with_imported_fns, entryCode, moduleLookup)

// Single-file compilation API (backwards compatibility with existing tests).
out fn compile_tiny(src: String) : String =>
  compile_tiny2_with_imported_fns(src, true, false, "main.mjs", vec_new())

out fn compile_module(src: String) : String =>
  compile_tiny2_with_imported_fns(src, false, true, "module.mjs", vec_new())

out fn compile_project(entryPath: String, outPath: String) : Void => {
  // Very small multi-file compiler:
  // - supports `from <path> use { ... };` for local file modules
  // - all module paths are resolved relative to the entry file's directory
  // - emits to the same relative path under outDir: <path>.mjs

  let outDir = pathDirname(outPath);
  let workspaceRoot = workspace_root_from_path(entryPath);
  let isCompilerBuild = stringLen(compiler_root_from_path(entryPath)) > 0;

  let graph = collect_module_graph_info(entryPath, workspaceRoot, isCompilerBuild, readTextFile);
  let order = graph.0;
  let modulePaths = graph.1;
  let moduleOutFns = graph.2;
  let modulePrivateTopLevelFnNames = graph.3;

  // Second pass: compile in topo order.
  let mut oi = 0;
  while (oi < vec_len(order)) {
    let path = vec_get(order, oi);
    set_current_file(path);
    let src = readTextFile(path);

    let r = project_compile_one_module_with(
      compile_tiny2_with_imported_fns,
      src,
      path,
      entryPath,
      outDir,
      outPath,
      workspaceRoot,
      isCompilerBuild,
      modulePaths,
      moduleOutFns,
      modulePrivateTopLevelFnNames
    );
    let outFile = r.1;
    let js = r.2;
    writeTextFile(outFile, js);

    oi = oi + 1;
  }
}

// Like compile_project, but does not write anything. Callers provide a reader
// callback for sourcing files and then can decide where/how to write.
// Returns (outFiles, jsOutputs) aligned by index.
out fn compile_project_to_outputs(entryPath: String, outPath: String, readSource: (String) => String) => {
  let outDir = pathDirname(outPath);
  let workspaceRoot = workspace_root_from_path(entryPath);
  let isCompilerBuild = stringLen(compiler_root_from_path(entryPath)) > 0;

  let graph = collect_module_graph_info(entryPath, workspaceRoot, isCompilerBuild, readSource);
  let order = graph.0;
  let modulePaths = graph.1;
  let moduleOutFns = graph.2;
  let modulePrivateTopLevelFnNames = graph.3;

  let outFiles = vec_new();
  let jsOutputs = vec_new();

  let mut oi = 0;
  while (oi < vec_len(order)) {
    let path = vec_get(order, oi);
    set_current_file(path);
    let src = readSource(path);

    let r = project_compile_one_module_with(
      compile_tiny2_with_imported_fns,
      src,
      path,
      entryPath,
      outDir,
      outPath,
      workspaceRoot,
      isCompilerBuild,
      modulePaths,
      moduleOutFns,
      modulePrivateTopLevelFnNames
    );
    let outFile = r.1;
    let js = r.2;
    vec_push(outFiles, outFile);
    vec_push(jsOutputs, js);

    oi = oi + 1;
  }

  (outFiles, jsOutputs)
}

out fn fluff_project(entryPath: String) : Void => {
  // Like compile_project, but only parse+analyze and emit warnings.
  // No JS is generated and nothing is written to disk.

  fluff_project_with_reader(entryPath, readTextFile);
}

// Like fluff_project, but the caller provides the source reader callback.
out fn fluff_project_with_reader(entryPath: String, readSource: (String) => String) : Void => {
  let workspaceRoot = workspace_root_from_path(entryPath);
  let isCompilerBuild = stringLen(compiler_root_from_path(entryPath)) > 0;

  let graph = collect_module_graph_info(entryPath, workspaceRoot, isCompilerBuild, readSource);
  let order = graph.0;
  let modulePaths = graph.1;
  let moduleOutFns = graph.2;
  let modulePrivateTopLevelFnNames = graph.3;

  // Second pass: lint in topo order.
  let mut oi = 0;
  while (oi < vec_len(order)) {
    let path = vec_get(order, oi);
    set_current_file(path);
    let src = readSource(path);

    project_lint_one_module_with(
      lint_tiny2_with_imported_fns,
      src,
      path,
      entryPath,
      workspaceRoot,
      isCompilerBuild,
      modulePaths,
      moduleOutFns,
      modulePrivateTopLevelFnNames
    );
    oi = oi + 1;
  }
}

// Like fluff_project_with_reader, but only lints the provided file list.
//
// This is useful for pre-commit hooks and other workflows where we want fast,
// targeted linting without walking/linting the entire module graph.
//
// Note: We still build an export table for the union of the module graphs so
// imported function signatures can be seeded correctly.
out fn fluff_files_with_reader(filePaths: Vec<String>, readSource: (String) => String) : Void => {
  if (vec_len(filePaths) == 0) { yield; }

  let entryPath = vec_get(filePaths, 0);
  let workspaceRoot = workspace_root_from_path(entryPath);
  let isCompilerBuild = stringLen(compiler_root_from_path(entryPath)) > 0;

  // Build a merged export table for all target roots (and their deps).
  let mut modulePaths = vec_new();
  let mut moduleOutFns = vec_new();
  let mut modulePrivateTopLevelFnNames = vec_new();

  let mut fi = 0;
  while (fi < vec_len(filePaths)) {
    let rootPath = vec_get(filePaths, fi);
    let graph = collect_module_graph_info(rootPath, workspaceRoot, isCompilerBuild, readSource);
    let gPaths = graph.1;
    let gOutFns = graph.2;
    let gPrivate = graph.3;

    let mut gi = 0;
    while (gi < vec_len(gPaths)) {
      let p = vec_get(gPaths, gi);
      if (module_index(modulePaths, p) == -1) {
        vec_push(modulePaths, p);
        vec_push(moduleOutFns, vec_get(gOutFns, gi));
        vec_push(modulePrivateTopLevelFnNames, vec_get(gPrivate, gi));
      }
      gi = gi + 1;
    }

    fi = fi + 1;
  }

  // Lint only the requested files. We pass entryPath="" so requireMain is false.
  let mut ti = 0;
  while (ti < vec_len(filePaths)) {
    let path = vec_get(filePaths, ti);
    set_current_file(path);
    let src = readSource(path);
    project_lint_one_module_with(
      lint_tiny2_with_imported_fns,
      src,
      path,
      "",
      workspaceRoot,
      isCompilerBuild,
      modulePaths,
      moduleOutFns,
      modulePrivateTopLevelFnNames
    );
    ti = ti + 1;
  }
}

// ------------------------------------------------------------
// LSP API: parse+analyze a single file and collect diagnostics
// without panicking. Returns false if there are errors.
// ------------------------------------------------------------

out fn lsp_check_file(src: String, filePath: String) : Bool => {
  lsp_check_file_impl(src, filePath)
}

// Re-export diagnostic accessors for TypeScript interop.
out fn lsp_get_errors() : Vec<DiagInfo> => get_error_infos()
out fn lsp_get_warnings() : Vec<DiagInfo> => get_warning_infos()
out fn lsp_line_col(src: String, offset: I32) : LineCol => line_col_at(src, offset)

// Main LSP go-to-definition API.
out fn lsp_find_definition(src: String, offset: I32, filePath: String) : DefLocation =>
  lsp_find_definition_impl(src, offset, filePath)
