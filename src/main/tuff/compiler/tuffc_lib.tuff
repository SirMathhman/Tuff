// Self-hosted compiler (first whack)
//
// This is a *very* small compiler written in Tuff, intended to prove the loop:
//   bootstrap TS compiler -> emits JS -> JS runs and can compile a tiny subset.
//
// For now, it compiles only a restricted input shape:
//   fn main() => <number>
//   fn main() => { <number> }
//
// Output is ESM that exports `main`.
//
// NOTE: This file contains the compiler implementation.
// The CLI entrypoint lives in `selfhost/tuffc.tuff`.

extern from rt::stdlib use { println, panic, readTextFile, writeTextFile, pathDirname, pathJoin, stringLen, stringSlice, stringCharCodeAt, stringFromCharCode };

extern from rt::vec use { vec_new, vec_len, vec_push, vec_get };

from util::diagnostics use {
  set_current_file,
  panic_at,
  reset_errors,
  reset_warnings,
  panic_if_errors,
  emit_errors,
  emit_warnings,
  reset_struct_defs,
  add_struct_def,
  find_struct_fields,
  is_identifier_too_short,
  warn_short_identifier,
  get_error_infos,
  get_warning_infos,
  get_current_file,
  line_col_at,
  DiagInfo,
  LineCol
};

from util::lexing use {
  is_digit,
  is_space,
  is_ident_start,
  is_ident_part,
  skip_ws,
  starts_with_at
};

from parsing::primitives use {
  ParsedNumber,
  ParsedIdent,
  ParsedBool,
  parse_keyword,
  parse_number,
  parse_ident,
  parse_module_path,
  module_path_to_relpath,
  parse_optional_semicolon,
  parse_required_semicolon
};

from parsing::types use { ParsedType, parse_type_expr, skip_angle_brackets, skip_type_expr };

from parsing::expr_stmt use {
  ParsedExpr,
  ParsedMain,
  ParsedStmt,
  ParsedParams,
  parse_expr,
  parse_stmt,
  parse_main_body,
  parse_mut_opt,
  is_assign_stmt_start,
  is_field_assign_stmt_start,
  is_index_assign_stmt_start
};

from parsing::expr_stmt use {
  ParsedExprAst,
  parse_expr_ast
};

from parsing::decls_legacy use {
  ParsedImports,
  ParsedFn,
  parse_imports,
  parse_extern_decl,
  parse_module_decl,
  parse_fn_decl2,
  parse_class_fn_decl2,
  parse_struct_decl,
  parse_type_union_decl,
  parse_param_list,
  parse_fn_decl_named,
  parse_fn_decl
};

from parsing::decls use {
  ParsedDeclAst,
  ParsedDeclsAst,
  parse_imports_ast,
  parse_extern_decl_ast,
  parse_module_decl_ast,
  parse_fn_decl_ast2,
  parse_class_fn_decl_ast2,
  parse_struct_decl_ast,
  parse_type_union_decl_ast,
  parse_type_params_list_ast
};

from ast use {
  span,
  span_start,
  span_end,
  decl_let,
  decl_let_typed
};

from emit::ast_js use { emit_decl_js };
from emit::emit_helpers use { set_current_file_path, emit_runtime_vec_imports_js, decls_needs_vec_rt };

from analyzer use { analyze_program, analyze_program_with_fns, mk_fn_sig, check_file_size };

// Whitespace-preserving tooling support (formatter/refactors).
from util::formatting use { ParsedProgramWithTrivia, parse_program_with_trivia };

// ------------------------------------------------------------
// Helpers
// ------------------------------------------------------------

fn kw_at(src: String, i: I32, kw: String) : Bool => {
  // Keyword match that rejects identifier continuations.
  if (!starts_with_at(src, i, kw)) { yield false; }
  let end = i + stringLen(kw);
  if (end < stringLen(src) && is_ident_part(stringCharCodeAt(src, end))) { yield false; }
  true
}

fn is_extern_decl_start(src: String, i: I32) : Bool => {
  // Accept:
  //   extern from ...
  //   extern type ...
  //   out extern type ...
  let j = skip_ws(src, i);
  if (kw_at(src, j, "extern")) { yield true; }
  if (kw_at(src, j, "out")) {
    let k = skip_ws(src, j + 3);
    if (kw_at(src, k, "extern")) { yield true; }
  }
  false
}

// ------------------------------------------------------------
// In-process caching (optional speed-up)
//
// Bun/Node caches ESM modules by path; our tests and tooling sometimes call
// lint/compile multiple times within the same process. Export scanning is a
// pure function of file content, and files are stable during a single run.
// ------------------------------------------------------------

let mut __tuffc_scan_cache = vec_new();

class fn ScanCacheEntry(path: String, outSigs: Vec<FnSig>, privateNames: Vec<String>, allSigs: Vec<FnSig>) => {}

fn cached_scan_top_level_fn_exports(path: String, src: String) => {
  let mut i = 0;
  while (i < vec_len(__tuffc_scan_cache)) {
    let e = vec_get(__tuffc_scan_cache, i);
    if (e.path == path) {
      yield (e.outSigs, e.privateNames, e.allSigs);
    }
    i = i + 1;
  }

  let ex = scan_top_level_fn_exports(src);
  vec_push(__tuffc_scan_cache, ScanCacheEntry(path, ex.0, ex.1, ex.2));
  ex
}

fn parse_program_with_trivia_api(src: String, exportAll: Bool) : ParsedProgramWithTrivia => {
  parse_program_with_trivia(src, exportAll)
}

fn compile_tiny2(src: String, requireMain: Bool, exportAll: Bool, filePath: String) : String =>
  compile_tiny2_with_imported_fns(src, requireMain, exportAll, filePath, vec_new())

fn compile_tiny2_with_imported_fns(src: String, requireMain: Bool, exportAll: Bool, filePath: String, importedFns: Vec<FnSig>) : String => {
  // Parse:
  //   (extern from <mod> use { <idents> };)*
  //   (from <mod> use { <idents> };)*
  //   (type <ident>(<typeparams>)? = <variants>;)*
  //   (struct <ident> { <fields> })*
  //   (let <ident> = <expr>;)*
  //   (fn <ident>(<params>) => <expr|block>)*
  let mut i = 0;

  // Reset per-file state.
  reset_struct_defs();
  reset_errors();
  reset_warnings();

  let mut out = "// compiled by selfhost tuffc\n";

  // Phase 3: parse into canonical AST decls, then emit JS.
  let decls = vec_new();

  // zero or more extern declarations
  while (true) {
    if (is_extern_decl_start(src, i)) {
      let ex = parse_extern_decl_ast(src, i);
      vec_push(decls, ex.decl);
      i = ex.nextPos;
      continue;
    }
    break;
  }

  // zero or more imports
  let imps = parse_imports_ast(src, i);
  let mut ii = 0;
  while (ii < vec_len(imps.decls)) {
    vec_push(decls, vec_get(imps.decls, ii));
    ii = ii + 1;
  }
  i = imps.nextPos;

  // Parse all declarations in any order: module, type, struct, let, fn, class fn, out fn
  let mut sawMain = false;
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "module")) {
      let m = parse_module_decl_ast(src, i);
      vec_push(decls, m.decl);
      i = m.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "type")) {
      let td = parse_type_union_decl_ast(src, i, exportAll);
      vec_push(decls, td.decl);
      i = td.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "struct")) {
      let sd = parse_struct_decl_ast(src, i);
      vec_push(decls, sd.decl);
      i = sd.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "let")) {
      let start = skip_ws(src, i);
      i = parse_keyword(src, i, "let");
      let mutOpt = parse_mut_opt(src, i);
      i = mutOpt.nextPos;
      let name = parse_ident(src, i);
      i = name.nextPos;

      // Optional let type annotation: `let x: T = ...`
      let mut tyAnn = "";
      let t0 = skip_ws(src, i);
      if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) { // ':'
        let _ty = parse_type_expr(src, t0 + 1);
        tyAnn = _ty.v0;
        i = _ty.v1;
      }

      i = parse_keyword(src, i, "=");
      let expr = parse_expr_ast(src, i);
      i = expr.nextPos;
      i = parse_optional_semicolon(src, i);
      if (tyAnn == "") {
        vec_push(decls, decl_let(span(start, i), mutOpt.ok, name.text, expr.expr));
      } else {
        vec_push(decls, decl_let_typed(span(start, i), mutOpt.ok, name.text, tyAnn, expr.expr));
      }
      continue;
    }
    if (starts_with_at(src, j, "fn")) {
      let f = parse_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "class")) {
      let f = parse_class_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DClassFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "out")) {
      // `out fn ...` or `out class fn ...`
      let k0 = parse_keyword(src, i, "out");
      let j2 = skip_ws(src, k0);
      if (starts_with_at(src, j2, "class")) {
        let f = parse_class_fn_decl_ast2(src, i, exportAll);
        if (f.decl.tag == "DClassFn" && f.decl.name == "main") { sawMain = true; }
        vec_push(decls, f.decl);
        i = f.nextPos;
        continue;
      }
      let f = parse_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    break;
  }
  if (requireMain && !sawMain) { panic_at(src, i, "expected fn main"); }

  // Phase 4 (initial): run analyzer checks before emission.
  // When compiling as part of a multi-file project, seed imported function
  // signatures so cross-file calls are validated.
  analyze_program_with_fns(src, decls, importedFns);
  panic_if_errors();
  emit_warnings();

  // Set the file path for the emitter to compute correct relative import paths
  set_current_file_path(filePath);

  // Bring in runtime vec helpers under internal aliases when the emitted JS
  // will use vec literals/indexing sugar.
  if (decls_needs_vec_rt(decls)) {
    out = out + emit_runtime_vec_imports_js();
  }

  // Emit decls in order.
  let mut di = 0;
  while (di < vec_len(decls)) {
    out = out + emit_decl_js(vec_get(decls, di), exportAll);
    di = di + 1;
  }

  out
}

fn lint_tiny2_with_imported_fns(src: String, requireMain: Bool, exportAll: Bool, importedFns: Vec<FnSig>) : Void => {
  // Parse and analyze like compile_tiny2_with_imported_fns, but do not emit JS.
  let mut i = 0;

  // Reset per-file state.
  reset_struct_defs();
  reset_errors();
  reset_warnings();

  // Check file size first (before parsing).
  check_file_size(src);

  let decls = vec_new();

  // zero or more extern declarations
  while (true) {
    if (is_extern_decl_start(src, i)) {
      let ex = parse_extern_decl_ast(src, i);
      vec_push(decls, ex.decl);
      i = ex.nextPos;
      continue;
    }
    break;
  }

  // zero or more imports
  let imps = parse_imports_ast(src, i);
  let mut ii = 0;
  while (ii < vec_len(imps.decls)) {
    vec_push(decls, vec_get(imps.decls, ii));
    ii = ii + 1;
  }
  i = imps.nextPos;

  // zero or more module declarations
  // Parse all declarations in any order: module, type, struct, let, fn, class fn, out fn
  let mut sawMain = false;
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "module")) {
      let m = parse_module_decl_ast(src, i);
      vec_push(decls, m.decl);
      i = m.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "type")) {
      let td = parse_type_union_decl_ast(src, i, exportAll);
      vec_push(decls, td.decl);
      i = td.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "struct")) {
      let sd = parse_struct_decl_ast(src, i);
      vec_push(decls, sd.decl);
      i = sd.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "let")) {
      let start = skip_ws(src, i);
      i = parse_keyword(src, i, "let");
      let mutOpt = parse_mut_opt(src, i);
      i = mutOpt.nextPos;
      let name = parse_ident(src, i);
      i = name.nextPos;

      // Optional let type annotation: `let x: T = ...`
      let mut tyAnn = "";
      let t0 = skip_ws(src, i);
      if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) { // ':'
        let _ty = parse_type_expr(src, t0 + 1);
        tyAnn = _ty.v0;
        i = _ty.v1;
      }

      i = parse_keyword(src, i, "=");
      let expr = parse_expr_ast(src, i);
      i = expr.nextPos;
      i = parse_optional_semicolon(src, i);
      if (tyAnn == "") {
        vec_push(decls, decl_let(span(start, i), mutOpt.ok, name.text, expr.expr));
      } else {
        vec_push(decls, decl_let_typed(span(start, i), mutOpt.ok, name.text, tyAnn, expr.expr));
      }
      continue;
    }
    if (starts_with_at(src, j, "fn")) {
      let f = parse_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "class")) {
      let f = parse_class_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DClassFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "out")) {
      // `out fn ...` or `out class fn ...`
      let k0 = parse_keyword(src, i, "out");
      let j2 = skip_ws(src, k0);
      if (starts_with_at(src, j2, "class")) {
        let f = parse_class_fn_decl_ast2(src, i, exportAll);
        if (f.decl.tag == "DClassFn" && f.decl.name == "main") { sawMain = true; }
        vec_push(decls, f.decl);
        i = f.nextPos;
        continue;
      }
      let f = parse_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    break;
  }
  if (requireMain && !sawMain) { panic_at(src, i, "expected fn main"); }

  analyze_program_with_fns(src, decls, importedFns);
  panic_if_errors();
  emit_warnings();
}

fn compile_tiny(src: String) : String => compile_tiny2(src, true, false, "main.mjs")
fn compile_module(src: String) : String => compile_tiny2(src, false, true, "module.mjs")

fn find_substring(hay: String, needle: String) : I32 => {
  let mut i = 0;
  while (i + stringLen(needle) <= stringLen(hay)) {
    if (starts_with_at(hay, i, needle)) { yield i; }
    i = i + 1;
  }
  -1
}

fn workspace_root_from_path(p: String) : String => {
  // Try to find a stable staging/workspace root by trimming at common anchors.
  let mut i = find_substring(p, "\\src\\");
  if (i != -1) { yield stringSlice(p, 0, i); }
  i = find_substring(p, "/src/");
  if (i != -1) { yield stringSlice(p, 0, i); }
  i = find_substring(p, "\\std\\");
  if (i != -1) { yield stringSlice(p, 0, i); }
  i = find_substring(p, "/std/");
  if (i != -1) { yield stringSlice(p, 0, i); }
  pathDirname(p)
}

fn compiler_root_from_path(p: String) : String => {
  // If we're compiling a compiler source file, resolve short module paths from
  // the compiler root: <root>/src/main/tuff/compiler/
  let needle1 = "\\src\\main\\tuff\\compiler\\";
  let mut i = find_substring(p, needle1);
  if (i != -1) { yield stringSlice(p, 0, i + stringLen(needle1)); }
  let needle2 = "/src/main/tuff/compiler/";
  i = find_substring(p, needle2);
  if (i != -1) { yield stringSlice(p, 0, i + stringLen(needle2)); }
  ""
}

// ------------------------------------------------------------
// Multi-file: export tables + import validation (Phase 5)
// ------------------------------------------------------------

fn str_list_contains(xs: Vec<String>, s: String) : Bool => {
  let mut i = 0;
  while (i < vec_len(xs)) {
    if (vec_get(xs, i) == s) { yield true; }
    i = i + 1;
  }
  false
}

fn str_list_remove(xs: Vec<String>, s: String) : Vec<String> => {
  let out = vec_new();
  let mut i = 0;
  while (i < vec_len(xs)) {
    let v = vec_get(xs, i);
    if (!(v == s)) { vec_push(out, v); }
    i = i + 1;
  }
  out
}

// ------------------------------------------------------------
// Deprecation markers (comment-based)
//
// Supported forms:
//   // `deprecated - <reason>`
//   /* `deprecated - <reason>` */
// ------------------------------------------------------------

fn is_ascii_ws(ch: I32) : Bool => ch == 32 || ch == 9 || ch == 10 || ch == 13
fn is_ascii_space_tab(ch: I32) : Bool => ch == 32 || ch == 9

fn ascii_lower(ch: I32) : I32 => {
  if (ch >= 65 && ch <= 90) { yield ch + 32; }
  ch
}

fn trim_ascii_ws(s: String) : String => {
  let mut start = 0;
  let mut end = stringLen(s);
  while (start < end && is_ascii_ws(stringCharCodeAt(s, start))) { start = start + 1; }
  while (end > start && is_ascii_ws(stringCharCodeAt(s, end - 1))) { end = end - 1; }
  stringSlice(s, start, end)
}

fn starts_with_deprecated_ci(s: String) : Bool => {
  if (stringLen(s) < 10) { yield false; }
  let mut i = 0;
  while (i < 10) {
    let ch = ascii_lower(stringCharCodeAt(s, i));
    let want = stringCharCodeAt("deprecated", i);
    if (ch != want) { yield false; }
    i = i + 1;
  }
  true
}

fn parse_deprecated_reason_from_comment(commentText: String) : String => {
  let t0 = trim_ascii_ws(commentText);
  if (!starts_with_deprecated_ci(t0)) { yield ""; }

  let mut i = 10;
  while (i < stringLen(t0) && is_ascii_ws(stringCharCodeAt(t0, i))) { i = i + 1; }
  if (i >= stringLen(t0)) { yield ""; }
  let sep = stringCharCodeAt(t0, i);
  if (!(sep == 45 || sep == 58)) { yield ""; }
  i = i + 1;
  while (i < stringLen(t0) && is_ascii_ws(stringCharCodeAt(t0, i))) { i = i + 1; }
  trim_ascii_ws(stringSlice(t0, i, stringLen(t0)))
}

fn skip_ws_back(src: String, pos: I32) : I32 => {
  let mut i = pos;
  while (i > 0 && is_ascii_ws(stringCharCodeAt(src, i - 1))) { i = i - 1; }
  i
}

fn line_start(src: String, pos: I32) : I32 => {
  let mut i = pos;
  while (i > 0 && stringCharCodeAt(src, i - 1) != 10) { i = i - 1; }
  i
}

fn line_end(src: String, pos: I32) : I32 => {
  let mut i = pos;
  while (i < stringLen(src) && stringCharCodeAt(src, i) != 10) { i = i + 1; }
  i
}

fn block_comment_start(src: String, endStarPos: I32) : I32 => {
  let mut i = endStarPos;
  while (i >= 2) {
    if (stringCharCodeAt(src, i - 2) == 47 && stringCharCodeAt(src, i - 1) == 42) { yield i - 2; }
    i = i - 1;
  }
  -1
}

fn deprecation_reason_before(src: String, pos: I32) : String => {
  let mut k = pos;
  while (true) {
    k = skip_ws_back(src, k);
    if (k <= 0) { yield ""; }

    if (k >= 2 && stringCharCodeAt(src, k - 2) == 42 && stringCharCodeAt(src, k - 1) == 47) {
      let start = block_comment_start(src, k - 2);
      if (start == -1) { yield ""; }
      let inner = stringSlice(src, start + 2, k - 2);
      let reason = parse_deprecated_reason_from_comment(inner);
      if (reason != "") { yield reason; }
      k = start;
      continue;
    }

    let ls = line_start(src, k);
    let mut p = ls;
    while (p < k && is_ascii_space_tab(stringCharCodeAt(src, p))) { p = p + 1; }
    if (p + 1 < stringLen(src) && stringCharCodeAt(src, p) == 47 && stringCharCodeAt(src, p + 1) == 47) {
      let le = line_end(src, p + 2);
      let inner = stringSlice(src, p + 2, le);
      let reason = parse_deprecated_reason_from_comment(inner);
      if (reason != "") { yield reason; }
      k = ls;
      continue;
    }

    yield "";
  }
}

fn module_index(modulePaths: Vec<String>, path: String) : I32 => {
  let mut i = 0;
  while (i < vec_len(modulePaths)) {
    if (vec_get(modulePaths, i) == path) { yield i; }
    i = i + 1;
  }
  -1
}

fn fnsig_lookup_by_name(fns: Vec<FnSig>, name: String) : FnSig => {
  let mut i = 0;
  while (i < vec_len(fns)) {
    let s = vec_get(fns, i);
    if (s.name == name) { yield s; }
    i = i + 1;
  }
  // sentinel: empty name means missing
  mk_fn_sig("", "", vec_new(), vec_new(), vec_new(), "")
}

fn scan_top_level_fn_exports(src: String) => {
  // Parse enough of the file to collect top-level function declarations.
  // Returns (outFnSigs, privateTopLevelFnNames, allTopLevelFnSigs).

  let outSigs = vec_new();
  let privateNames = vec_new();
  let allSigs = vec_new();

  let mut decls = vec_new();
  let mut i = 0;

  // externs
  while (true) {
    if (is_extern_decl_start(src, i)) {
      let ex = parse_extern_decl_ast(src, i);
      vec_push(decls, ex.decl);
      i = ex.nextPos;
      continue;
    }
    break;
  }

  // imports
  let imps = parse_imports_ast(src, i);
  let mut ii = 0;
  while (ii < vec_len(imps.decls)) {
    vec_push(decls, vec_get(imps.decls, ii));
    ii = ii + 1;
  }
  i = imps.nextPos;

  // module decls
  while (true) {
    let j = skip_ws(src, i);
    if (!starts_with_at(src, j, "module")) { break; }
    let m = parse_module_decl_ast(src, i);
    vec_push(decls, m.decl);
    i = m.nextPos;
  }

  // type / struct decls
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "module")) {
      let m = parse_module_decl_ast(src, i);
      vec_push(decls, m.decl);
      i = m.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "type")) {
      let td = parse_type_union_decl_ast(src, i, false);
      vec_push(decls, td.decl);
      i = td.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "struct")) {
      let sd = parse_struct_decl_ast(src, i);
      vec_push(decls, sd.decl);
      i = sd.nextPos;
      continue;
    }
    break;
  }

  // let decls (skip)
  while (true) {
    let j = skip_ws(src, i);
    if (!starts_with_at(src, j, "let")) { break; }
    let start = skip_ws(src, i);
    i = parse_keyword(src, i, "let");
    let mutOpt = parse_mut_opt(src, i);
    i = mutOpt.nextPos;
    let name = parse_ident(src, i);
    i = name.nextPos;

    let mut tyAnn = "";
    let t0 = skip_ws(src, i);
    if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) {
      let _ty = parse_type_expr(src, t0 + 1);
      tyAnn = _ty.v0;
      i = _ty.v1;
    }

    i = parse_keyword(src, i, "=");
    let expr = parse_expr_ast(src, i);
    i = expr.nextPos;
    i = parse_optional_semicolon(src, i);
    if (tyAnn == "") {
      vec_push(decls, decl_let(span(start, i), mutOpt.ok, name.text, expr.expr));
    } else {
      vec_push(decls, decl_let_typed(span(start, i), mutOpt.ok, name.text, tyAnn, expr.expr));
    }
  }

  // fns (top-level only)
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "fn")) {
      let f = parse_fn_decl_ast2(src, i, false);
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "class")) {
      let f = parse_class_fn_decl_ast2(src, i, false);
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "out")) {
      // `out fn ...` or `out class fn ...`
      let k0 = parse_keyword(src, i, "out");
      let j2 = skip_ws(src, k0);
      if (starts_with_at(src, j2, "class")) {
        let f = parse_class_fn_decl_ast2(src, i, false);
        vec_push(decls, f.decl);
        i = f.nextPos;
        continue;
      }
      let f = parse_fn_decl_ast2(src, i, false);
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    break;
  }

  // Collect top-level fn signatures.
  let mut di = 0;
  while (di < vec_len(decls)) {
    let d = vec_get(decls, di);
    if (d.tag == "DFn") {
      let depReason = deprecation_reason_before(src, span_start(d.span));
      let sig = mk_fn_sig(d.name, depReason, d.typeParams, d.params, d.paramTyAnns, d.retTyAnn);
      vec_push(allSigs, sig);
      if (d.isOut) { vec_push(outSigs, sig); }
      else { vec_push(privateNames, d.name); }
    }
    if (d.tag == "DClassFn") {
      let depReason = deprecation_reason_before(src, span_start(d.span));
      let sig = mk_fn_sig(d.name, depReason, d.typeParams, d.params, d.paramTyAnns, d.retTyAnn);
      vec_push(allSigs, sig);
      if (d.isOut) { vec_push(outSigs, sig); }
      else { vec_push(privateNames, d.name); }
    }
    di = di + 1;
  }

  (outSigs, privateNames, allSigs)
}

// ------------------------------------------------------------
// Project compilation helpers (separating logic from file I/O)
// ------------------------------------------------------------

fn project_imported_fn_sigs(src: String, path: String, workspaceRoot: String, isCompilerBuild: Bool, modulePaths: Vec<String>, moduleOutFns: Vec<Vec<FnSig>>, modulePrivateTopLevelFnNames: Vec<Vec<String>>) : Vec<FnSig> => {
  // Build imported function signatures and validate `out` visibility.
  // Keep behavior consistent with compile_project/fluff_project.

  let importedFns = vec_new();

  // For compile_project (project build): allow imported fn signature seeding
  // except for compiler-rooted modules (placeholder type annotations).
  let seedImportedFns = !(stringLen(compiler_root_from_path(path)) > 0);

  if (!isCompilerBuild) {
    let mut scan = 0;
    while (true) {
      if (is_extern_decl_start(src, scan)) {
        let ex2 = parse_extern_decl(src, scan);
        scan = ex2.v1;
        continue;
      }
      break;
    }

    let impsAst = parse_imports_ast(src, scan);
    let mut ii = 0;
    while (ii < vec_len(impsAst.decls)) {
      let imp = vec_get(impsAst.decls, ii);
      if (imp.tag == "DImport") {
        let rel = module_path_to_relpath(imp.modulePath);
        let mut baseDir = pathDirname(path);
        let compilerSrcPrefix = "src::main::tuff::compiler::";
        let mut rel2 = rel;
        if (starts_with_at(imp.modulePath, 0, compilerSrcPrefix)) {
          let compilerRootDir = pathJoin(workspaceRoot, "src/main/tuff/compiler");
          baseDir = compilerRootDir;
          let rest = stringSlice(imp.modulePath, stringLen(compilerSrcPrefix), stringLen(imp.modulePath));
          rel2 = module_path_to_relpath(rest);
        } else {
          if (starts_with_at(imp.modulePath, 0, "src::") || starts_with_at(imp.modulePath, 0, "std::")) {
            baseDir = workspaceRoot;
          } else {
            let cr = compiler_root_from_path(path);
            if (stringLen(cr) > 0) { baseDir = cr; }
          }
        }
        let depPath = pathJoin(baseDir, rel2 + ".tuff");

        let depIdx = module_index(modulePaths, depPath);
        if (depIdx != -1) {
          let outFns = vec_get(moduleOutFns, depIdx);
          let privateNames = vec_get(modulePrivateTopLevelFnNames, depIdx);
          let mut ni = 0;
          while (ni < vec_len(imp.names)) {
            let name = vec_get(imp.names, ni);

            let sig = fnsig_lookup_by_name(outFns, name);
            if (!(sig.name == "")) {
              if (seedImportedFns) {
                vec_push(importedFns, sig);
              }
            } else {
              // If it's a top-level function but not exported, hard error.
              if (str_list_contains(privateNames, name)) {
                panic_at(src, span_start(imp.span), "imported function '" + name + "' is not exported (missing `out fn`)");
              }
              // Otherwise, assume it's a module/type/struct/etc and let later
              // phases handle it.
            }

            ni = ni + 1;
          }
        }
      }
      ii = ii + 1;
    }
  }

  importedFns
}

fn project_out_paths(path: String, entryPath: String, outDir: String, outPath: String, workspaceRoot: String) => {
  // Compute a stable source-relative path for output layout.
  let crHere = compiler_root_from_path(path);
  let relRoot = if (stringLen(crHere) > 0) crHere else workspaceRoot;

  let mut prefixLen = stringLen(relRoot);
  let mut relStart = prefixLen;
  if (relStart < stringLen(path)) {
    let ch = stringCharCodeAt(path, relStart);
    if (ch == 47 || ch == 92) { relStart = relStart + 1; }
  }
  let relSrcPath = stringSlice(path, relStart, stringLen(path));
  let relNoExt = stringSlice(relSrcPath, 0, stringLen(relSrcPath) - 5);

  let outRelPath = if (path == entryPath) {
    let mut pfx = stringLen(outDir);
    let mut s = pfx;
    if (s < stringLen(outPath)) {
      let ch2 = stringCharCodeAt(outPath, s);
      if (ch2 == 47 || ch2 == 92) { s = s + 1; }
    }
    stringSlice(outPath, s, stringLen(outPath))
  } else {
    relNoExt + ".mjs"
  };

  let outFile = if (path == entryPath) outPath else pathJoin(outDir, relNoExt + ".mjs");

  (outRelPath, outFile)
}

fn project_compile_one_module(src: String, path: String, entryPath: String, outDir: String, outPath: String, workspaceRoot: String, isCompilerBuild: Bool, modulePaths: Vec<String>, moduleOutFns: Vec<Vec<FnSig>>, modulePrivateTopLevelFnNames: Vec<Vec<String>>) => {
  let importedFns = project_imported_fn_sigs(src, path, workspaceRoot, isCompilerBuild, modulePaths, moduleOutFns, modulePrivateTopLevelFnNames);
  let paths = project_out_paths(path, entryPath, outDir, outPath, workspaceRoot);
  let outRelPath = paths.0;
  let outFile = paths.1;

  // For project compilation, exports are controlled via `out` (plus `main`).
  // For compiler bootstrapping, keep legacy `exportAll` to avoid churn.
  let js = compile_tiny2_with_imported_fns(src, path == entryPath, isCompilerBuild, outRelPath, importedFns);
  (outRelPath, outFile, js)
}

fn project_lint_one_module(src: String, path: String, entryPath: String, workspaceRoot: String, isCompilerBuild: Bool, modulePaths: Vec<String>, moduleOutFns: Vec<Vec<FnSig>>, modulePrivateTopLevelFnNames: Vec<Vec<String>>) : Void => {
  // Fluff uses slightly different seeding rules:
  let importedFns = vec_new();
  let seedImportedFns = !isCompilerBuild && !(stringLen(compiler_root_from_path(path)) > 0);

  if (!isCompilerBuild) {
    let mut scan = 0;
    while (true) {
      if (is_extern_decl_start(src, scan)) {
        let ex2 = parse_extern_decl(src, scan);
        scan = ex2.v1;
        continue;
      }
      break;
    }

    let impsAst = parse_imports_ast(src, scan);
    let mut ii = 0;
    while (ii < vec_len(impsAst.decls)) {
      let imp = vec_get(impsAst.decls, ii);
      if (imp.tag == "DImport") {
        let rel = module_path_to_relpath(imp.modulePath);
        let mut baseDir = pathDirname(path);
        let compilerSrcPrefix = "src::main::tuff::compiler::";
        let mut rel2 = rel;
        if (starts_with_at(imp.modulePath, 0, compilerSrcPrefix)) {
          let compilerRootDir = pathJoin(workspaceRoot, "src/main/tuff/compiler");
          baseDir = compilerRootDir;
          let rest = stringSlice(imp.modulePath, stringLen(compilerSrcPrefix), stringLen(imp.modulePath));
          rel2 = module_path_to_relpath(rest);
        } else {
          if (starts_with_at(imp.modulePath, 0, "src::") || starts_with_at(imp.modulePath, 0, "std::")) {
            baseDir = workspaceRoot;
          } else {
            let cr = compiler_root_from_path(path);
            if (stringLen(cr) > 0) { baseDir = cr; }
          }
        }
        let depPath = pathJoin(baseDir, rel2 + ".tuff");

        let depIdx = module_index(modulePaths, depPath);
        if (depIdx != -1) {
          let outFns = vec_get(moduleOutFns, depIdx);
          let privateNames = vec_get(modulePrivateTopLevelFnNames, depIdx);
          let mut ni = 0;
          while (ni < vec_len(imp.names)) {
            let name = vec_get(imp.names, ni);

            let sig = fnsig_lookup_by_name(outFns, name);
            if (!(sig.name == "")) {
              if (seedImportedFns) {
                vec_push(importedFns, sig);
              }
            } else {
              if (str_list_contains(privateNames, name)) {
                panic_at(src, span_start(imp.span), "imported function '" + name + "' is not exported (missing `out fn`)");
              }
            }

            ni = ni + 1;
          }
        }
      }
      ii = ii + 1;
    }
  }

  lint_tiny2_with_imported_fns(src, path == entryPath, isCompilerBuild, importedFns);
}

// ------------------------------------------------------------
// In-memory compilation API (Option 4 building block)
// ------------------------------------------------------------

fn mem_read(entryCode: String, moduleLookup: (String) => String, key: String) : String => {
  if (key == "entry") { yield entryCode; }
  moduleLookup(key)
}

fn mem_collect_module_graph_info(entryCode: String, moduleLookup: (String) => String, isCompilerBuild: Bool) => {
  let entryKey = "entry";

  let mut stack = vec_new();
  vec_push(stack, entryKey);

  let mut visited = vec_new();
  let mut visiting = vec_new();
  let mut order = vec_new();
  let mut moduleKeys = vec_new();
  let mut moduleOutFns = vec_new();
  let mut modulePrivateTopLevelFnNames = vec_new();

  while (vec_len(stack) > 0) {
    let item = vec_get(stack, vec_len(stack) - 1);

    // pop
    let mut newStack = vec_new();
    let mut qi = 0;
    while (qi + 1 < vec_len(stack)) {
      vec_push(newStack, vec_get(stack, qi));
      qi = qi + 1;
    }
    stack = newStack;

    if (starts_with_at(item, 0, "POST:")) {
      let key = stringSlice(item, 5, stringLen(item));
      visiting = str_list_remove(visiting, key);
      vec_push(order, key);
      continue;
    }

    let key = item;
    if (str_list_contains(visited, key)) { continue; }
    vec_push(visited, key);
    vec_push(visiting, key);

    vec_push(stack, "POST:" + key);

    let src = mem_read(entryCode, moduleLookup, key);
    set_current_file(key);

    let ex = cached_scan_top_level_fn_exports(key, src);
    vec_push(moduleKeys, key);
    if (isCompilerBuild) {
      vec_push(moduleOutFns, ex.2);
      vec_push(modulePrivateTopLevelFnNames, vec_new());
    } else {
      vec_push(moduleOutFns, ex.0);
      vec_push(modulePrivateTopLevelFnNames, ex.1);
    }

    // discover imports
    let mut scan = 0;
    while (true) {
      if (is_extern_decl_start(src, scan)) {
        let ex2 = parse_extern_decl(src, scan);
        scan = ex2.v1;
        continue;
      }
      break;
    }

    while (true) {
      let j = skip_ws(src, scan);
      if (starts_with_at(src, j, "import")) {
        panic_at(src, j, "`import` is not supported. Use `from <module> use { ... };` instead.");
      }
      if (!starts_with_at(src, j, "from")) { break; }
      scan = parse_keyword(src, scan, "from");
      let mod = parse_module_path(src, scan);
      scan = mod.nextPos;
      scan = parse_keyword(src, scan, "use");
      scan = parse_keyword(src, scan, "{");
      while (true) {
        scan = skip_ws(src, scan);
        if (!(scan < stringLen(src))) { panic_at(src, scan, "expected '}'"); }
        if (stringCharCodeAt(src, scan) == 125) { scan = scan + 1; break; }
        let id = parse_ident(src, scan);
        scan = id.nextPos;
        scan = skip_ws(src, scan);
        if (scan < stringLen(src) && stringCharCodeAt(src, scan) == 44) { scan = scan + 1; continue; }
        scan = skip_ws(src, scan);
        if (scan < stringLen(src) && stringCharCodeAt(src, scan) == 125) { scan = scan + 1; break; }
        panic_at(src, scan, "expected ',' or '}' in import list");
      }
      scan = parse_optional_semicolon(src, scan);

      let depKey = mod.text;
      if (str_list_contains(visiting, depKey)) {
        panic_at(src, j, "circular dependency detected");
      }
      vec_push(stack, depKey);
    }
  }

  (order, moduleKeys, moduleOutFns, modulePrivateTopLevelFnNames)
}

fn mem_imported_fn_sigs(src: String, key: String, isCompilerBuild: Bool, moduleKeys: Vec<String>, moduleOutFns: Vec<Vec<FnSig>>, modulePrivateTopLevelFnNames: Vec<Vec<String>>) : Vec<FnSig> => {
  let importedFns = vec_new();
  let seedImportedFns = !isCompilerBuild;

  if (!isCompilerBuild) {
    let mut scan = 0;
    while (true) {
      if (is_extern_decl_start(src, scan)) {
        let ex2 = parse_extern_decl(src, scan);
        scan = ex2.v1;
        continue;
      }
      break;
    }

    let impsAst = parse_imports_ast(src, scan);
    let mut ii = 0;
    while (ii < vec_len(impsAst.decls)) {
      let imp = vec_get(impsAst.decls, ii);
      if (imp.tag == "DImport") {
        let depKey = imp.modulePath;
        let depIdx = module_index(moduleKeys, depKey);
        if (depIdx != -1) {
          let outFns = vec_get(moduleOutFns, depIdx);
          let privateNames = vec_get(modulePrivateTopLevelFnNames, depIdx);
          let mut ni = 0;
          while (ni < vec_len(imp.names)) {
            let name = vec_get(imp.names, ni);

            let sig = fnsig_lookup_by_name(outFns, name);
            if (!(sig.name == "")) {
              if (seedImportedFns) {
                vec_push(importedFns, sig);
              }
            } else {
              if (str_list_contains(privateNames, name)) {
                panic_at(src, span_start(imp.span), "imported function '" + name + "' is not exported (missing `out fn`)");
              }
            }

            ni = ni + 1;
          }
        }
      }
      ii = ii + 1;
    }
  }

  importedFns
}

// Compile entryCode and all reachable modules via moduleLookup.
// Returns (outRelPaths, jsOutputs) aligned by index.
out fn compile_code(entryCode: String, moduleLookup: (String) => String) => {
  // For in-memory compilation we always enforce `out` visibility.
  let isCompilerBuild = false;

  let graph = mem_collect_module_graph_info(entryCode, moduleLookup, isCompilerBuild);
  let order = graph.0;
  let moduleKeys = graph.1;
  let moduleOutFns = graph.2;
  let modulePrivateTopLevelFnNames = graph.3;

  let outRelPaths = vec_new();
  let jsOutputs = vec_new();

  let mut oi = 0;
  while (oi < vec_len(order)) {
    let key = vec_get(order, oi);
    let src = mem_read(entryCode, moduleLookup, key);
    set_current_file(key);

    let importedFns = mem_imported_fn_sigs(src, key, isCompilerBuild, moduleKeys, moduleOutFns, modulePrivateTopLevelFnNames);
    let outRelPath = if (key == "entry") "entry.mjs" else (module_path_to_relpath(key) + ".mjs");

    let js = compile_tiny2_with_imported_fns(src, key == "entry", isCompilerBuild, outRelPath, importedFns);
    vec_push(outRelPaths, outRelPath);
    vec_push(jsOutputs, js);

    oi = oi + 1;
  }

  (outRelPaths, jsOutputs)
}

out fn compile_project(entryPath: String, outPath: String) : Void => {
  // Very small multi-file compiler:
  // - supports `from <path> use { ... };` for local file modules
  // - all module paths are resolved relative to the entry file's directory
  // - emits to the same relative path under outDir: <path>.mjs

  let outDir = pathDirname(outPath);
  let workspaceRoot = workspace_root_from_path(entryPath);
  let isCompilerBuild = stringLen(compiler_root_from_path(entryPath)) > 0;

  let graph = collect_module_graph_info(entryPath, workspaceRoot, isCompilerBuild, readTextFile);
  let order = graph.0;
  let modulePaths = graph.1;
  let moduleOutFns = graph.2;
  let modulePrivateTopLevelFnNames = graph.3;

  // Second pass: compile in topo order.
  let mut oi = 0;
  while (oi < vec_len(order)) {
    let path = vec_get(order, oi);
    set_current_file(path);
    let src = readTextFile(path);

    let r = project_compile_one_module(src, path, entryPath, outDir, outPath, workspaceRoot, isCompilerBuild, modulePaths, moduleOutFns, modulePrivateTopLevelFnNames);
    let outFile = r.1;
    let js = r.2;
    writeTextFile(outFile, js);

    oi = oi + 1;
  }
}

// Shared helper: walk the module graph (DFS) to
//   1) detect circular dependencies (hard error)
//   2) collect per-module export info (top-level out fns)
//   3) compute a safe compilation order (deps before importers)
//
// This is the first step toward separating file I/O from compilation logic.
// Callers inject the source reader function.
fn collect_module_graph_info(
  entryPath: String,
  workspaceRoot: String,
  isCompilerBuild: Bool,
  readSource: (String) => String
) => {
  let mut stack = vec_new();
  vec_push(stack, entryPath);

  let mut visited = vec_new();
  let mut visiting = vec_new();
  let mut order = vec_new();
  let mut modulePaths = vec_new();
  let mut moduleOutFns = vec_new();
  let mut modulePrivateTopLevelFnNames = vec_new();

  while (vec_len(stack) > 0) {
    let item = vec_get(stack, vec_len(stack) - 1);

    // pop
    let mut newStack = vec_new();
    let mut qi = 0;
    while (qi + 1 < vec_len(stack)) {
      vec_push(newStack, vec_get(stack, qi));
      qi = qi + 1;
    }
    stack = newStack;

    if (starts_with_at(item, 0, "POST:")) {
      let path = stringSlice(item, 5, stringLen(item));
      visiting = str_list_remove(visiting, path);
      vec_push(order, path);
      continue;
    }

    let path = item;
    if (str_list_contains(visited, path)) { continue; }
    vec_push(visited, path);
    vec_push(visiting, path);

    // push post marker, then dependencies (LIFO)
    vec_push(stack, "POST:" + path);

    set_current_file(path);
    let src = readSource(path);

    // export table for this module
    let ex = cached_scan_top_level_fn_exports(path, src);
    vec_push(modulePaths, path);
    if (isCompilerBuild) {
      // Preserve legacy behavior for compiling the compiler itself: allow
      // cross-module imports without requiring `out` on every helper.
      vec_push(moduleOutFns, ex.2);
      vec_push(modulePrivateTopLevelFnNames, vec_new());
    } else {
      vec_push(moduleOutFns, ex.0);
      vec_push(modulePrivateTopLevelFnNames, ex.1);
    }

    // discover imports for graph walk
    let mut scan = 0;
    // skip externs
    while (true) {
      if (is_extern_decl_start(src, scan)) {
        let ex2 = parse_extern_decl(src, scan);
        scan = ex2.v1;
        continue;
      }
      break;
    }

    while (true) {
      let j = skip_ws(src, scan);
      if (starts_with_at(src, j, "import")) {
        panic_at(src, j, "`import` is not supported. Use `from <module> use { ... };` instead.");
      }
      if (!starts_with_at(src, j, "from")) { break; }
      scan = parse_keyword(src, scan, "from");
      let mod = parse_module_path(src, scan);
      scan = mod.nextPos;
      scan = parse_keyword(src, scan, "use");
      scan = parse_keyword(src, scan, "{");
      // consume name list
      while (true) {
        scan = skip_ws(src, scan);
        if (!(scan < stringLen(src))) { panic_at(src, scan, "expected '}'"); }
        if (stringCharCodeAt(src, scan) == 125) { scan = scan + 1; break; }
        let id = parse_ident(src, scan);
        scan = id.nextPos;
        scan = skip_ws(src, scan);
        if (scan < stringLen(src) && stringCharCodeAt(src, scan) == 44) { scan = scan + 1; continue; }
        scan = skip_ws(src, scan);
        if (scan < stringLen(src) && stringCharCodeAt(src, scan) == 125) { scan = scan + 1; break; }
        panic_at(src, scan, "expected ',' or '}' in import list");
      }
      scan = parse_optional_semicolon(src, scan);

      // resolve dependency file
      let compilerSrcPrefix = "src::main::tuff::compiler::";
      let mut rel = module_path_to_relpath(mod.text);
      let mut baseDir = pathDirname(path);
      if (starts_with_at(mod.text, 0, compilerSrcPrefix)) {
        // Treat these as compiler-root imports to match internal compiler layout.
        let compilerRootDir = pathJoin(workspaceRoot, "src/main/tuff/compiler");
        baseDir = compilerRootDir;
        let rest = stringSlice(mod.text, stringLen(compilerSrcPrefix), stringLen(mod.text));
        rel = module_path_to_relpath(rest);
      } else {
        if (starts_with_at(mod.text, 0, "src::") || starts_with_at(mod.text, 0, "std::")) {
          baseDir = workspaceRoot;
        } else {
          let cr = compiler_root_from_path(path);
          if (stringLen(cr) > 0) { baseDir = cr; }
        }
      }
      let depPath = pathJoin(baseDir, rel + ".tuff");

      if (str_list_contains(visiting, depPath)) {
        panic_at(src, j, "circular dependency detected");
      }

      vec_push(stack, depPath);
    }
  }

  (order, modulePaths, moduleOutFns, modulePrivateTopLevelFnNames)
}

out fn fluff_project(entryPath: String) : Void => {
  // Like compile_project, but only parse+analyze and emit warnings.
  // No JS is generated and nothing is written to disk.

  let workspaceRoot = workspace_root_from_path(entryPath);
  let isCompilerBuild = stringLen(compiler_root_from_path(entryPath)) > 0;

  let graph = collect_module_graph_info(entryPath, workspaceRoot, isCompilerBuild, readTextFile);
  let order = graph.0;
  let modulePaths = graph.1;
  let moduleOutFns = graph.2;
  let modulePrivateTopLevelFnNames = graph.3;

  // Second pass: lint in topo order.
  let mut oi = 0;
  while (oi < vec_len(order)) {
    let path = vec_get(order, oi);
    set_current_file(path);
    let src = readTextFile(path);

    project_lint_one_module(src, path, entryPath, workspaceRoot, isCompilerBuild, modulePaths, moduleOutFns, modulePrivateTopLevelFnNames);
    oi = oi + 1;
  }
}

// ------------------------------------------------------------
// LSP API: parse+analyze a single file and collect diagnostics
// without panicking. Returns false if there are errors.
// ------------------------------------------------------------

out fn lsp_check_file(src: String, filePath: String) : Bool => {
  // Reset per-file state.
  reset_struct_defs();
  reset_errors();
  reset_warnings();
  set_current_file(filePath);

  let decls = vec_new();
  let mut i = 0;

  // zero or more extern declarations
  while (true) {
    if (is_extern_decl_start(src, i)) {
      let ex = parse_extern_decl_ast(src, i);
      vec_push(decls, ex.decl);
      i = ex.nextPos;
      continue;
    }
    break;
  }

  // zero or more imports
  let imps = parse_imports_ast(src, i);
  let mut ii = 0;
  while (ii < vec_len(imps.decls)) {
    vec_push(decls, vec_get(imps.decls, ii));
    ii = ii + 1;
  }
  i = imps.nextPos;

  // Parse all declarations in any order: module, type, struct, let, fn, class fn, out fn
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "module")) {
      let m = parse_module_decl_ast(src, i);
      vec_push(decls, m.decl);
      i = m.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "type")) {
      let td = parse_type_union_decl_ast(src, i, false);
      vec_push(decls, td.decl);
      i = td.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "struct")) {
      let sd = parse_struct_decl_ast(src, i);
      vec_push(decls, sd.decl);
      i = sd.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "let")) {
      let start = skip_ws(src, i);
      i = parse_keyword(src, i, "let");
      let mutOpt = parse_mut_opt(src, i);
      i = mutOpt.nextPos;
      let name = parse_ident(src, i);
      i = name.nextPos;

      let mut tyAnn = "";
      let t0 = skip_ws(src, i);
      if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) {
        let _ty = parse_type_expr(src, t0 + 1);
        tyAnn = _ty.v0;
        i = _ty.v1;
      }

      i = parse_keyword(src, i, "=");
      let expr = parse_expr_ast(src, i);
      i = expr.nextPos;
      i = parse_optional_semicolon(src, i);
      if (tyAnn == "") {
        vec_push(decls, decl_let(span(start, i), mutOpt.ok, name.text, expr.expr));
      } else {
        vec_push(decls, decl_let_typed(span(start, i), mutOpt.ok, name.text, tyAnn, expr.expr));
      }
      continue;
    }
    if (starts_with_at(src, j, "fn")) {
      let f = parse_fn_decl_ast2(src, i, false);
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "class")) {
      let f = parse_class_fn_decl_ast2(src, i, false);
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "out")) {
      let k0 = parse_keyword(src, i, "out");
      let j2 = skip_ws(src, k0);
      if (starts_with_at(src, j2, "class")) {
        let f = parse_class_fn_decl_ast2(src, i, false);
        vec_push(decls, f.decl);
        i = f.nextPos;
        continue;
      }
      let f = parse_fn_decl_ast2(src, i, false);
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    break;
  }

  // Run analyzer (won't panic, just collects errors)
  analyze_program(src, decls);

  // Return true if no errors
  vec_len(get_error_infos()) == 0
}

// Re-export diagnostic accessors for TypeScript interop.
out fn lsp_get_errors() : Vec<DiagInfo> => get_error_infos()
out fn lsp_get_warnings() : Vec<DiagInfo> => get_warning_infos()
out fn lsp_line_col(src: String, offset: I32) : LineCol => line_col_at(src, offset)

// ------------------------------------------------------------
// LSP helpers: Module path to file path resolution
// ------------------------------------------------------------

// Resolve a module path (e.g., "util::diagnostics") to an absolute file path.
// Uses the same logic as compile_project for resolving imports.
fn lsp_resolve_module_path(modulePath: String, currentFilePath: String) : String => {
  let workspaceRoot = workspace_root_from_path(currentFilePath);
  let rel = module_path_to_relpath(modulePath);
  let mut baseDir = pathDirname(currentFilePath);
  let compilerSrcPrefix = "src::main::tuff::compiler::";
  let mut rel2 = rel;

  if (starts_with_at(modulePath, 0, compilerSrcPrefix)) {
    let compilerRootDir = pathJoin(workspaceRoot, "src/main/tuff/compiler");
    baseDir = compilerRootDir;
    let rest = stringSlice(modulePath, stringLen(compilerSrcPrefix), stringLen(modulePath));
    rel2 = module_path_to_relpath(rest);
  } else {
    if (starts_with_at(modulePath, 0, "src::") || starts_with_at(modulePath, 0, "std::")) {
      baseDir = workspaceRoot;
    } else {
      let cr = compiler_root_from_path(currentFilePath);
      if (stringLen(cr) > 0) { baseDir = cr; }
    }
  }

  pathJoin(baseDir, rel2 + ".tuff")
}

// ------------------------------------------------------------
// LSP: Go-to-definition support
// ------------------------------------------------------------

// Definition entry for the simple symbol table
struct LspDef {
  tag: String,
  name: String,
  defStart: I32,
  defEnd: I32,
  kind: String,
  defFile: String
}

// Symbol reference with resolved definition
struct LspRef {
  tag: String,
  refStart: I32,
  refEnd: I32,
  defStart: I32,
  defEnd: I32,
  defFile: String
}

// Result of a go-to-definition lookup.
class fn DefLocation(found: Bool, defStart: I32, defEnd: I32, defFile: String) => {}

fn lsp_def(name: String, defStart: I32, defEnd: I32, kind: String) : LspDef =>
  LspDef { "LspDef", name, defStart, defEnd, kind, "" }

fn lsp_def_ext(name: String, defStart: I32, defEnd: I32, kind: String, defFile: String) : LspDef =>
  LspDef { "LspDef", name, defStart, defEnd, kind, defFile }

fn lsp_ref(refStart: I32, refEnd: I32, defStart: I32, defEnd: I32) : LspRef =>
  LspRef { "LspRef", refStart, refEnd, defStart, defEnd, "" }

fn lsp_ref_ext(refStart: I32, refEnd: I32, defStart: I32, defEnd: I32, defFile: String) : LspRef =>
  LspRef { "LspRef", refStart, refEnd, defStart, defEnd, defFile }

// Simple scoped symbol table
fn lsp_lookup(defs: Vec<LspDef>, name: String) : LspDef => {
  // Search from end (most recent) to handle scoping
  let mut i = vec_len(defs) - 1;
  while (i >= 0) {
    let d = vec_get(defs, i);
    if (d.name == name) { yield d; }
    i = i - 1;
  }
  lsp_def("", -1, -1, "")
}

fn lsp_lookup_type(defs: Vec<LspDef>, name: String) : LspDef => {
  let mut i = vec_len(defs) - 1;
  while (i >= 0) {
    let d = vec_get(defs, i);
    if (d.name == name && (d.kind == "struct" || d.kind == "type")) { yield d; }
    i = i - 1;
  }
  lsp_def("", -1, -1, "")
}

fn lsp_lookup_field(defs: Vec<LspDef>, structName: String, fieldName: String) : LspDef => {
  let fullName = structName + "." + fieldName;
  let mut i = 0;
  while (i < vec_len(defs)) {
    let d = vec_get(defs, i);
    if (d.name == fullName && d.kind == "field") { yield d; }
    i = i + 1;
  }
  lsp_def("", -1, -1, "")
}

// Check if offset is in range [start, end)
fn lsp_in_range(offset: I32, start: I32, end: I32) : Bool => offset >= start && offset < end

// Collect declarations from decls into defs
fn lsp_collect_decls(decls: Vec<Decl>, defs: Vec<LspDef>, filePath: String) : Void => {
  let mut i = 0;
  while (i < vec_len(decls)) {
    lsp_collect_decl(vec_get(decls, i), defs, filePath);
    i = i + 1;
  }
}

fn lsp_collect_decl(d: Decl, defs: Vec<LspDef>, filePath: String) : Void => {
  if (d.tag == "DExternFrom") {
    let mut ni = 0;
    while (ni < vec_len(d.names)) {
      vec_push(defs, lsp_def(vec_get(d.names, ni), span_start(d.span), span_end(d.span), "extern"));
      ni = ni + 1;
    }
  }
  if (d.tag == "DImport") {
    // Resolve the module path to a file path for cross-file navigation
    let targetFile = lsp_resolve_module_path(d.modulePath, filePath);
    let mut ni = 0;
    while (ni < vec_len(d.names)) {
      // For imported names, store the target file and position 0 (we don't parse the target file yet)
      vec_push(defs, lsp_def_ext(vec_get(d.names, ni), 0, 0, "import", targetFile));
      ni = ni + 1;
    }
  }
  if (d.tag == "DLet") {
    vec_push(defs, lsp_def(d.name, span_start(d.span), span_end(d.span), "var"));
  }
  if (d.tag == "DFn") {
    vec_push(defs, lsp_def(d.name, span_start(d.span), span_end(d.span), "fn"));
  }
  if (d.tag == "DClassFn") {
    vec_push(defs, lsp_def(d.name, span_start(d.span), span_end(d.span), "fn"));
  }
  if (d.tag == "DStruct") {
    vec_push(defs, lsp_def(d.name, span_start(d.span), span_end(d.span), "struct"));
    // Register fields.
    // NOTE: In the canonical AST, `DStruct.fields` is a `Vec<String>` (names only).
    // We don't currently have per-field spans, so map fields to the struct span.
    let mut fi = 0;
    while (fi < vec_len(d.fields)) {
      let fieldName = vec_get(d.fields, fi);
      vec_push(defs, lsp_def(d.name + "." + fieldName, span_start(d.span), span_end(d.span), "field"));
      fi = fi + 1;
    }
  }
  if (d.tag == "DTypeUnion") {
    vec_push(defs, lsp_def(d.name, span_start(d.span), span_end(d.span), "type"));
    let mut vi = 0;
    while (vi < vec_len(d.variants)) {
      let v = vec_get(d.variants, vi);
      vec_push(defs, lsp_def(v.name, span_start(v.span), span_end(v.span), "variant"));
      vi = vi + 1;
    }
  }
  if (d.tag == "DModule") {
    vec_push(defs, lsp_def(d.name, span_start(d.span), span_end(d.span), "module"));
    lsp_collect_decls(d.decls, defs, filePath);
  }
}

// Resolve references in expressions. Returns inferred type name for field access.
fn lsp_resolve_expr(e: Expr, defs: Vec<LspDef>, refs: Vec<LspRef>) : String => {
  if (e.tag == "EIdent") {
    let d = lsp_lookup(defs, e.name);
    if (d.defStart >= 0 || stringLen(d.defFile) > 0) {
      vec_push(refs, lsp_ref_ext(span_start(e.span), span_end(e.span), d.defStart, d.defEnd, d.defFile));
    }
    yield "";
  }
  
  if (e.tag == "EStructLit") {
    // Struct name is a type reference.
    // Canonical AST stores it as `nameExpr`.
    let mut structName = "";
    let mut nameSpan = e.span;
    if (e.nameExpr.tag == "EIdent") {
      structName = e.nameExpr.name;
      nameSpan = e.nameExpr.span;
    }
    if (e.nameExpr.tag == "EPath") {
      // Use the last path segment as the type name.
      if (vec_len(e.nameExpr.parts) > 0) {
        structName = vec_get(e.nameExpr.parts, vec_len(e.nameExpr.parts) - 1);
        nameSpan = e.nameExpr.span;
      }
    }

    if (stringLen(structName) > 0) {
      let tyDef = lsp_lookup_type(defs, structName);
      if (tyDef.defStart >= 0 || stringLen(tyDef.defFile) > 0) {
        vec_push(refs, lsp_ref_ext(span_start(nameSpan), span_end(nameSpan), tyDef.defStart, tyDef.defEnd, tyDef.defFile));
      }
    }
    let mut vi = 0;
    while (vi < vec_len(e.values)) {
      lsp_resolve_expr(vec_get(e.values, vi), defs, refs);
      vi = vi + 1;
    }
    yield structName;
  }
  
  if (e.tag == "EField") {
    let baseTy = lsp_resolve_expr(e.base, defs, refs);
    if (stringLen(baseTy) > 0) {
      let fieldDef = lsp_lookup_field(defs, baseTy, e.field);
      if (fieldDef.defStart >= 0) {
        // Field reference starts after the dot
        let fieldStart = span_end(e.base.span) + 1;
        vec_push(refs, lsp_ref_ext(fieldStart, span_end(e.span), fieldDef.defStart, fieldDef.defEnd, fieldDef.defFile));
      }
    }
    yield "";
  }
  
  if (e.tag == "ECall") {
    lsp_resolve_expr(e.callee, defs, refs);
    let mut ai = 0;
    while (ai < vec_len(e.args)) {
      lsp_resolve_expr(vec_get(e.args, ai), defs, refs);
      ai = ai + 1;
    }
  }
  
  if (e.tag == "EBinary") {
    lsp_resolve_expr(e.left, defs, refs);
    lsp_resolve_expr(e.right, defs, refs);
  }
  
  if (e.tag == "EUnary") {
    lsp_resolve_expr(e.expr, defs, refs);
  }
  
  if (e.tag == "EIf") {
    lsp_resolve_expr(e.cond, defs, refs);
    lsp_resolve_expr(e.thenExpr, defs, refs);
    lsp_resolve_expr(e.elseExpr, defs, refs);
  }
  
  if (e.tag == "EBlock") {
    lsp_resolve_stmts(e.body, defs, refs);
    lsp_resolve_expr(e.tail, defs, refs);
  }
  
  if (e.tag == "ELambda") {
    let mut pi = 0;
    while (pi < vec_len(e.params)) {
      vec_push(defs, lsp_def(vec_get(e.params, pi), span_start(e.span), span_end(e.span), "param"));
      pi = pi + 1;
    }
    lsp_resolve_expr(e.body, defs, refs);
  }
  
  if (e.tag == "EMatch") {
    lsp_resolve_expr(e.scrut, defs, refs);
    let mut mi = 0;
    while (mi < vec_len(e.arms)) {
      let arm = vec_get(e.arms, mi);
      let mut bi = 0;
      while (bi < vec_len(arm.bindings)) {
        vec_push(defs, lsp_def(vec_get(arm.bindings, bi), span_start(arm.span), span_end(arm.span), "binding"));
        bi = bi + 1;
      }
      lsp_resolve_expr(arm.expr, defs, refs);
      mi = mi + 1;
    }
  }
  
  if (e.tag == "EIndex") {
    lsp_resolve_expr(e.base, defs, refs);
    lsp_resolve_expr(e.index, defs, refs);
  }
  
  if (e.tag == "ETupleIndex") {
    lsp_resolve_expr(e.base, defs, refs);
  }
  
  if (e.tag == "EVecLit") {
    let mut ii = 0;
    while (ii < vec_len(e.items)) {
      lsp_resolve_expr(vec_get(e.items, ii), defs, refs);
      ii = ii + 1;
    }
  }
  
  if (e.tag == "ETupleLit") {
    let mut ii = 0;
    while (ii < vec_len(e.items)) {
      lsp_resolve_expr(vec_get(e.items, ii), defs, refs);
      ii = ii + 1;
    }
  }
  
  ""
}

fn lsp_resolve_stmt(s: Stmt, defs: Vec<LspDef>, refs: Vec<LspRef>) : Void => {
  if (s.tag == "SLet") {
    lsp_resolve_expr(s.init, defs, refs);
    vec_push(defs, lsp_def(s.name, span_start(s.span), span_end(s.span), "var"));
  }
  
  if (s.tag == "SAssign") {
    let d = lsp_lookup(defs, s.name);
    if (d.defStart >= 0) {
      vec_push(refs, lsp_ref(span_start(s.span), span_start(s.span) + stringLen(s.name), d.defStart, d.defEnd));
    }
    lsp_resolve_expr(s.value, defs, refs);
  }
  
  if (s.tag == "SExpr") {
    lsp_resolve_expr(s.expr, defs, refs);
  }
  
  if (s.tag == "SYield") {
    lsp_resolve_expr(s.expr, defs, refs);
  }
  
  if (s.tag == "SWhile") {
    lsp_resolve_expr(s.cond, defs, refs);
    lsp_resolve_stmts(s.body, defs, refs);
  }
  
  if (s.tag == "SIf") {
    lsp_resolve_expr(s.cond, defs, refs);
    lsp_resolve_stmts(s.thenBody, defs, refs);
    if (s.hasElse) {
      lsp_resolve_stmts(s.elseBody, defs, refs);
    }
  }
  
  if (s.tag == "SIndexAssign") {
    lsp_resolve_expr(s.base, defs, refs);
    lsp_resolve_expr(s.index, defs, refs);
    lsp_resolve_expr(s.value, defs, refs);
  }
  
  if (s.tag == "SFieldAssign") {
    lsp_resolve_expr(s.base, defs, refs);
    lsp_resolve_expr(s.value, defs, refs);
  }
}

fn lsp_resolve_stmts(stmts: Vec<Stmt>, defs: Vec<LspDef>, refs: Vec<LspRef>) : Void => {
  let mut i = 0;
  while (i < vec_len(stmts)) {
    lsp_resolve_stmt(vec_get(stmts, i), defs, refs);
    i = i + 1;
  }
}

fn lsp_resolve_decl(d: Decl, defs: Vec<LspDef>, refs: Vec<LspRef>) : Void => {
  if (d.tag == "DLet") {
    lsp_resolve_expr(d.init, defs, refs);
  }
  
  if (d.tag == "DFn") {
    let mut pi = 0;
    while (pi < vec_len(d.params)) {
      vec_push(defs, lsp_def(vec_get(d.params, pi), span_start(d.span), span_end(d.span), "param"));
      pi = pi + 1;
    }
    lsp_resolve_stmts(d.body, defs, refs);
    lsp_resolve_expr(d.tail, defs, refs);
  }
  
  if (d.tag == "DClassFn") {
    let mut pi = 0;
    while (pi < vec_len(d.params)) {
      vec_push(defs, lsp_def(vec_get(d.params, pi), span_start(d.span), span_end(d.span), "param"));
      pi = pi + 1;
    }
    lsp_resolve_stmts(d.body, defs, refs);
    lsp_resolve_expr(d.tail, defs, refs);
  }
  
  if (d.tag == "DModule") {
    lsp_resolve_decls(d.decls, defs, refs);
  }
}

fn lsp_resolve_decls(decls: Vec<Decl>, defs: Vec<LspDef>, refs: Vec<LspRef>) : Void => {
  let mut i = 0;
  while (i < vec_len(decls)) {
    lsp_resolve_decl(vec_get(decls, i), defs, refs);
    i = i + 1;
  }
}

fn lsp_find_ref_at(refs: Vec<LspRef>, offset: I32) : LspRef => {
  let mut i = 0;
  while (i < vec_len(refs)) {
    let r = vec_get(refs, i);
    if (lsp_in_range(offset, r.refStart, r.refEnd)) { yield r; }
    i = i + 1;
  }
  lsp_ref_ext(-1, -1, -1, -1, "")
}

// Fallback: extract identifier under (or just left of) the cursor.
// Used for go-to-definition in places that are not tracked as Expr refs
// (e.g. import lists, type annotation strings).
fn lsp_ident_at(src: String, offset: I32) : String => {
  if (offset < 0 || offset >= stringLen(src)) { yield ""; }

  let mut i = offset;
  if (!is_ident_part(stringCharCodeAt(src, i)) && i > 0 && is_ident_part(stringCharCodeAt(src, i - 1))) {
    i = i - 1;
  }
  if (!is_ident_part(stringCharCodeAt(src, i))) { yield ""; }

  let mut start = i;
  while (start > 0 && is_ident_part(stringCharCodeAt(src, start - 1))) { start = start - 1; }
  if (!is_ident_start(stringCharCodeAt(src, start))) { yield ""; }

  let mut end = i + 1;
  while (end < stringLen(src) && is_ident_part(stringCharCodeAt(src, end))) { end = end + 1; }

  stringSlice(src, start, end)
}

fn lsp_has_double_colon(s: String) : Bool => {
  let mut i = 0;
  while (i + 1 < stringLen(s)) {
    if (stringCharCodeAt(s, i) == 58 && stringCharCodeAt(s, i + 1) == 58) { yield true; }
    i = i + 1;
  }
  false
}

fn lsp_is_module_path_part(code: I32) : Bool => is_ident_part(code) || code == 58

// Fallback: extract module path (containing ::) under the cursor.
fn lsp_module_path_at(src: String, offset: I32) : String => {
  if (offset < 0 || offset >= stringLen(src)) { yield ""; }
  let mut i = offset;

  if (!lsp_is_module_path_part(stringCharCodeAt(src, i)) && i > 0 && lsp_is_module_path_part(stringCharCodeAt(src, i - 1))) {
    i = i - 1;
  }
  if (!lsp_is_module_path_part(stringCharCodeAt(src, i))) { yield ""; }

  let mut start = i;
  while (start > 0 && lsp_is_module_path_part(stringCharCodeAt(src, start - 1))) { start = start - 1; }
  let mut end = i + 1;
  while (end < stringLen(src) && lsp_is_module_path_part(stringCharCodeAt(src, end))) { end = end + 1; }

  let mut s = stringSlice(src, start, end);

  // trim leading/trailing ':'
  while (stringLen(s) > 0 && stringCharCodeAt(s, 0) == 58) {
    s = stringSlice(s, 1, stringLen(s));
  }
  while (stringLen(s) > 0 && stringCharCodeAt(s, stringLen(s) - 1) == 58) {
    s = stringSlice(s, 0, stringLen(s) - 1);
  }

  if (!lsp_has_double_colon(s)) { yield ""; }
  s
}

// Main LSP go-to-definition API.
out fn lsp_find_definition(src: String, offset: I32, filePath: String) : DefLocation => {
  reset_struct_defs();
  reset_errors();
  reset_warnings();
  set_current_file(filePath);

  let decls = lsp_parse_file(src);
  
  let defs = vec_new();
  let refs = vec_new();
  
  // Pass 1: collect all declarations
  lsp_collect_decls(decls, defs, filePath);
  
  // Pass 2: resolve references
  lsp_resolve_decls(decls, defs, refs);
  
  // Find reference at offset
  let r = lsp_find_ref_at(refs, offset);
  if (r.refStart < 0) {
    // Fallback for non-expression positions.
    let modulePath = lsp_module_path_at(src, offset);
    if (stringLen(modulePath) > 0) {
      let targetFile = lsp_resolve_module_path(modulePath, filePath);
      yield DefLocation(true, 0, 0, targetFile);
    }

    let ident = lsp_ident_at(src, offset);
    if (stringLen(ident) > 0) {
      let d = lsp_lookup(defs, ident);
      if (d.defStart >= 0 || stringLen(d.defFile) > 0) {
        yield DefLocation(true, d.defStart, d.defEnd, d.defFile);
      }
    }

    yield DefLocation(false, 0, 0, "");
  }
  
  DefLocation(true, r.defStart, r.defEnd, r.defFile)
}

// Helper: parse file into decls
fn lsp_parse_file(src: String) : Vec<Decl> => {
  let decls = vec_new();
  let mut i = 0;

  // zero or more extern declarations
  while (true) {
    if (is_extern_decl_start(src, i)) {
      let ex = parse_extern_decl_ast(src, i);
      vec_push(decls, ex.decl);
      i = ex.nextPos;
      continue;
    }
    break;
  }

  // zero or more imports
  let imps = parse_imports_ast(src, i);
  let mut ii = 0;
  while (ii < vec_len(imps.decls)) {
    vec_push(decls, vec_get(imps.decls, ii));
    ii = ii + 1;
  }
  i = imps.nextPos;

  // Parse all declarations in any order: module, type, struct, let, fn, class fn, out fn
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "module")) {
      let m = parse_module_decl_ast(src, i);
      vec_push(decls, m.decl);
      i = m.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "type")) {
      let td = parse_type_union_decl_ast(src, i, false);
      vec_push(decls, td.decl);
      i = td.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "struct")) {
      let sd = parse_struct_decl_ast(src, i);
      vec_push(decls, sd.decl);
      i = sd.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "let")) {
      let start = skip_ws(src, i);
      i = parse_keyword(src, i, "let");
      let mutOpt = parse_mut_opt(src, i);
      i = mutOpt.nextPos;
      let name = parse_ident(src, i);
      i = name.nextPos;

      let mut tyAnn = "";
      let t0 = skip_ws(src, i);
      if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) {
        let _ty = parse_type_expr(src, t0 + 1);
        tyAnn = _ty.v0;
        i = _ty.v1;
      }

      i = parse_keyword(src, i, "=");
      let expr = parse_expr_ast(src, i);
      i = expr.nextPos;
      i = parse_optional_semicolon(src, i);
      if (tyAnn == "") {
        vec_push(decls, decl_let(span(start, i), mutOpt.ok, name.text, expr.expr));
      } else {
        vec_push(decls, decl_let_typed(span(start, i), mutOpt.ok, name.text, tyAnn, expr.expr));
      }
      continue;
    }
    if (starts_with_at(src, j, "fn")) {
      let f = parse_fn_decl_ast2(src, i, false);
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "class")) {
      let f = parse_class_fn_decl_ast2(src, i, false);
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "out")) {
      let k0 = parse_keyword(src, i, "out");
      let j2 = skip_ws(src, k0);
      if (starts_with_at(src, j2, "class")) {
        let f = parse_class_fn_decl_ast2(src, i, false);
        vec_push(decls, f.decl);
        i = f.nextPos;
        continue;
      }
      let f = parse_fn_decl_ast2(src, i, false);
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    break;
  }

  decls
}
