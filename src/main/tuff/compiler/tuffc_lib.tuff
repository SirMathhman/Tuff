// Self-hosted compiler (first whack)
//
// This is a *very* small compiler written in Tuff, intended to prove the loop:
//   bootstrap TS compiler -> emits JS -> JS runs and can compile a tiny subset.
//
// For now, it compiles only a restricted input shape:
//   fn main() => <number>
//   fn main() => { <number> }
//
// Output is ESM that exports `main`.
//
// NOTE: This file contains the compiler implementation.
// The CLI entrypoint lives in `selfhost/tuffc.tuff`.

extern from rt::stdlib use { println, panic, readTextFile, writeTextFile, pathDirname, pathJoin, stringLen, stringSlice, stringCharCodeAt, stringFromCharCode };

extern from rt::vec use { vec_new, vec_len, vec_push, vec_get };

from diagnostics use {
  set_current_file,
  panic_at,
  reset_struct_defs,
  add_struct_def,
  find_struct_fields,
  is_identifier_too_short,
  warn_short_identifier
};

from lexing use {
  is_digit,
  is_space,
  is_ident_start,
  is_ident_part,
  skip_ws,
  starts_with_at
};

from parsing_primitives use {
  ParsedNumber,
  ParsedIdent,
  ParsedBool,
  parse_keyword,
  parse_number,
  parse_ident,
  parse_module_path,
  module_path_to_relpath,
  parse_optional_semicolon,
  parse_required_semicolon
};

from parsing_types use { ParsedType, parse_type_expr, skip_angle_brackets, skip_type_expr };

from parsing_expr_stmt use {
  ParsedExpr,
  ParsedMain,
  ParsedStmt,
  ParsedParams,
  parse_expr,
  parse_stmt,
  parse_main_body,
  parse_mut_opt,
  is_assign_stmt_start,
  is_field_assign_stmt_start,
  is_index_assign_stmt_start
};

from parsing_expr_stmt use {
  ParsedExprAst,
  parse_expr_ast
};

from parsing_decls use {
  ParsedImports,
  ParsedFn,
  parse_imports,
  parse_extern_decl,
  parse_module_decl,
  parse_fn_decl2,
  parse_class_fn_decl2,
  parse_struct_decl,
  parse_type_union_decl,
  parse_param_list,
  parse_fn_decl_named,
  parse_fn_decl
};

from parsing_decls use {
  ParsedDeclAst,
  ParsedDeclsAst,
  parse_imports_ast,
  parse_extern_decl_ast,
  parse_module_decl_ast,
  parse_fn_decl_ast2,
  parse_class_fn_decl_ast2,
  parse_struct_decl_ast,
  parse_type_union_decl_ast
};

from ast use {
  span,
  decl_let
};

from emit_ast_js use { emit_decl_js };

from analyzer use { analyze_program };

// Whitespace-preserving tooling support (formatter/refactors).
from formatting use { ParsedProgramWithTrivia, parse_program_with_trivia };

fn parse_program_with_trivia_api(src: String, exportAll: Bool) : ParsedProgramWithTrivia => {
  parse_program_with_trivia(src, exportAll)
}

fn compile_tiny2(src: String, requireMain: Bool, exportAll: Bool) : String => {
  // Parse:
  //   (extern from <mod> use { <idents> };)*
  //   (from <mod> use { <idents> };)*
  //   (type <ident>(<typeparams>)? = <variants>;)*
  //   (struct <ident> { <fields> })*
  //   (let <ident> = <expr>;)*
  //   (fn <ident>(<params>) => <expr|block>)*
  let mut i = 0;

  // Reset per-file state.
  reset_struct_defs();

  let mut out = "// compiled by selfhost tuffc\n";

  // Phase 3: parse into canonical AST decls, then emit JS.
  let decls = vec_new();

  // zero or more extern declarations
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "extern")) {
      let ex = parse_extern_decl_ast(src, i);
      vec_push(decls, ex.decl);
      i = ex.nextPos;
      continue;
    }
    break;
  }

  // zero or more imports
  let imps = parse_imports_ast(src, i);
  let mut ii = 0;
  while (ii < vec_len(imps.decls)) {
    vec_push(decls, vec_get(imps.decls, ii));
    ii = ii + 1;
  }
  i = imps.nextPos;

  // zero or more module declarations
  while (true) {
    let j = skip_ws(src, i);
    if (!starts_with_at(src, j, "module")) { break; }
    let m = parse_module_decl_ast(src, i);
    vec_push(decls, m.decl);
    i = m.nextPos;
  }

  // zero or more type / struct declarations
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "type")) {
      let td = parse_type_union_decl_ast(src, i, exportAll);
      vec_push(decls, td.decl);
      i = td.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "struct")) {
      let sd = parse_struct_decl_ast(src, i);
      vec_push(decls, sd.decl);
      i = sd.nextPos;
      continue;
    }
    break;
  }

  // zero or more let statements
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "let")) {
      let start = skip_ws(src, i);
      i = parse_keyword(src, i, "let");
      let mutOpt = parse_mut_opt(src, i);
      i = mutOpt.nextPos;
      let name = parse_ident(src, i);
      i = name.nextPos;

      // Optional let type annotation: `let x: T = ...`
      let t0 = skip_ws(src, i);
      if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) { // ':'
        let _ty = parse_type_expr(src, t0 + 1);
        i = _ty.v1;
      }

      i = parse_keyword(src, i, "=");
      let expr = parse_expr_ast(src, i);
      i = expr.nextPos;
      i = parse_optional_semicolon(src, i);
      vec_push(decls, decl_let(span(start, i), mutOpt.ok, name.text, expr.expr));
      continue;
    }
    break;
  }

  // main
  let mut sawMain = false;
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "fn")) {
      let f = parse_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "class")) {
      let f = parse_class_fn_decl_ast2(src, i, exportAll);
      if (f.decl.tag == "DClassFn" && f.decl.name == "main") { sawMain = true; }
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    break;
  }
  if (requireMain && !sawMain) { panic_at(src, i, "expected fn main"); }

  // Phase 4 (initial): run analyzer checks before emission.
  analyze_program(src, decls);

  // Emit decls in order.
  let mut di = 0;
  while (di < vec_len(decls)) {
    out = out + emit_decl_js(vec_get(decls, di), exportAll);
    di = di + 1;
  }

  out
}

fn compile_tiny(src: String) : String => compile_tiny2(src, true, false)
fn compile_module(src: String) : String => compile_tiny2(src, false, true)

fn compile_project(entryPath: String, outPath: String) : Void => {
  // Very small multi-file compiler:
  // - supports `from <path> use { ... };` for local file modules
  // - resolves to <path>.tuff relative to the importing file
  // - emits to the same relative path under outDir: <path>.mjs

  let outDir = pathDirname(outPath);

  let mut queue = vec_new();
  vec_push(queue, entryPath);

  let mut done = vec_new();

  while (vec_len(queue) > 0) {
    let path = vec_get(queue, vec_len(queue) - 1);

    // set current file for better error messages
    set_current_file(path);
    // pop
    // (no vec_pop; emulate by shrinking via set+len conventions isn't available,
    //  so we'll use a simple index-based loop instead)
    // We'll just process the last item and rebuild the queue without it.
    let mut newQ = vec_new();
    let mut qi = 0;
    while (qi + 1 < vec_len(queue)) {
      vec_push(newQ, vec_get(queue, qi));
      qi = qi + 1;
    }
    queue = newQ;

    // skip if already done
    let mut already = false;
    let mut di = 0;
    while (di < vec_len(done)) {
      if (vec_get(done, di) == path) { already = true; break; }
      di = di + 1;
    }
    if (already) { continue; }
    vec_push(done, path);

    let src = readTextFile(path);

    // discover imports for queueing (same parsing as emitter)
    let mut scan = 0;
    // skip externs
    while (true) {
      let j = skip_ws(src, scan);
      if (starts_with_at(src, j, "extern")) {
        let ex = parse_extern_decl(src, scan);
        scan = ex.v1;
        continue;
      }
      break;
    }
    while (true) {
      let j = skip_ws(src, scan);
      if (starts_with_at(src, j, "import")) {
        panic_at(src, j, "`import` is not supported. Use `from <module> use { ... };` instead.");
      }
      if (!starts_with_at(src, j, "from")) { break; }
      scan = parse_keyword(src, scan, "from");
      let mod = parse_module_path(src, scan);
      scan = mod.nextPos;
      scan = parse_keyword(src, scan, "use");
      scan = parse_keyword(src, scan, "{");
      // consume name list
      while (true) {
        scan = skip_ws(src, scan);
        if (!(scan < stringLen(src))) { panic_at(src, scan, "expected '}'"); }
        if (stringCharCodeAt(src, scan) == 125) { scan = scan + 1; break; }
        let id = parse_ident(src, scan);
        scan = id.nextPos;
        scan = skip_ws(src, scan);
        if (scan < stringLen(src) && stringCharCodeAt(src, scan) == 44) { scan = scan + 1; continue; }
        scan = skip_ws(src, scan);
        if (scan < stringLen(src) && stringCharCodeAt(src, scan) == 125) { scan = scan + 1; break; }
        panic_at(src, scan, "expected ',' or '}' in import list");
      }
      scan = parse_optional_semicolon(src, scan);

      // queue dependency file
      let baseDir = pathDirname(path);
      let rel = module_path_to_relpath(mod.text);
      let depPath = pathJoin(baseDir, rel + ".tuff");
      vec_push(queue, depPath);
    }

    let js = if (path == entryPath) compile_tiny(src) else compile_module(src);
    // choose output name
    let outFile = if (path == entryPath) outPath else {
      // Preserve relative path under outDir.
      // Example: <base>/std/test.tuff -> <outDir>/std/test.mjs
      // We compute the filename only and keep directories by slicing from baseDir.
      let baseDir = pathDirname(entryPath);
      let mut prefixLen = stringLen(baseDir);
      // If the baseDir doesn't end with a separator, allow one separator.
      let mut relStart = prefixLen;
      if (relStart < stringLen(path)) {
        let ch = stringCharCodeAt(path, relStart);
        if (ch == 47 || ch == 92) { relStart = relStart + 1; }
      }
      let relPath = stringSlice(path, relStart, stringLen(path));
      // relPath ends with .tuff; replace with .mjs
      let relNoExt = stringSlice(relPath, 0, stringLen(relPath) - 5);
      pathJoin(outDir, relNoExt + ".mjs")
    };
    writeTextFile(outFile, js);
  }
}
	