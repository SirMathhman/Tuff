// Self-hosted compiler (first whack)
//
// This is a *very* small compiler written in Tuff, intended to prove the loop:
//   bootstrap TS compiler -> emits JS -> JS runs and can compile a tiny subset.
//
// For now, it compiles only a restricted input shape:
//   fn main() => <number>
//   fn main() => { <number> }
//
// Output is ESM that exports `main`.
//
// NOTE: This file contains the compiler implementation.
// The CLI entrypoint lives in `selfhost/tuffc.tuff`.

extern from rt::stdlib use { println, panic, readTextFile, writeTextFile, pathDirname, pathJoin, stringLen, stringSlice, stringCharCodeAt, stringFromCharCode };

extern from rt::vec use { vec_new, vec_len, vec_push, vec_get };

from diagnostics use {
  set_current_file,
  panic_at,
  reset_struct_defs,
  add_struct_def,
  find_struct_fields,
  is_identifier_too_short,
  warn_short_identifier
};

from lexing use {
  is_digit,
  is_space,
  is_ident_start,
  is_ident_part,
  skip_ws,
  starts_with_at
};

// Tiny record type used to return two values from parsing helpers.
class fn ParsedNumber(value: String, nextPos: I32) => {}
class fn ParsedIdent(text: String, startPos: I32, nextPos: I32) => {}
class fn ParsedExpr(v0: String, v1: I32) => {}
class fn ParsedMain(body: String, expr: String, v1: I32) => {}
class fn ParsedBool(ok: Bool, nextPos: I32) => {}
class fn ParsedStmt(v0: String, v1: I32) => {}
class fn ParsedParams(v0: String, v1: I32) => {}
class fn ParsedType(v0: String, v1: I32) => {}
class fn ParsedImports(v0: String, v1: I32) => {}
class fn ParsedFn(v0: String, v1: String, v2: I32) => {}
class fn ParsedModule(v0: String, v1: I32) => {}

fn parse_keyword(src: String, i: I32, lit: String) : I32 => {
  let j = skip_ws(src, i);
  if (!starts_with_at(src, j, lit)) {
    let mut end = j + 16;
    if (end > stringLen(src)) { end = stringLen(src); }
    panic_at(src, j, "expected keyword: " + lit + " but got '" + stringSlice(src, j, end) + "'");
  }
  j + stringLen(lit)
}

fn parse_number(src: String, i: I32) : ParsedNumber => {
  let mut j = skip_ws(src, i);
  let mut acc = 0;
  let mut saw = false;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (!is_digit(c)) { break; }
    saw = true;
    acc = acc * 10 + (c - 48);
    j = j + 1;
  }
  if (!saw) {
    panic_at(src, j, "expected number");
  }
  ParsedNumber(acc, j)
}

fn parse_ident(src: String, i: I32) : ParsedIdent => {
  let mut j = skip_ws(src, i);
  if (!(j < stringLen(src))) { panic_at(src, j, "expected identifier"); }
  let c0 = stringCharCodeAt(src, j);
  if (!is_ident_start(c0)) { panic_at(src, j, "expected identifier"); }
  let start = j;
  j = j + 1;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (!is_ident_part(c)) { break; }
    j = j + 1;
  }
  ParsedIdent(stringSlice(src, start, j), start, j)
}

fn parse_module_path(src: String, i: I32) : ParsedIdent => {
  let mut j = skip_ws(src, i);
  let start = j;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (is_space(c) || c == 59) { break; }
    j = j + 1;
  }
  if (start == j) { panic_at(src, j, "expected module path"); }
  ParsedIdent(stringSlice(src, start, j), start, j)
}

fn module_path_to_relpath(p: String) : String => {
  // Convert `a::b::c` to `a/b/c` for filesystem + ESM relative imports.
  let mut out = "";
  let mut i = 0;
  while (i < stringLen(p)) {
    if (i + 1 < stringLen(p) && stringCharCodeAt(p, i) == 58 && stringCharCodeAt(p, i + 1) == 58) {
      out = out + "/";
      i = i + 2;
      continue;
    }
    out = out + stringFromCharCode(stringCharCodeAt(p, i));
    i = i + 1;
  }
  out
}

fn parse_expr(src: String, i: I32) : ParsedExpr => parse_or(src, i)

fn parse_or(src: String, i: I32) : ParsedExpr => {
  let mut left = parse_and(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j + 1 < stringLen(src))) { break; }
    if (stringCharCodeAt(src, j) == 124 && stringCharCodeAt(src, j + 1) == 124) { // '||'
      let rhs = parse_and(src, j + 2);
      left = ParsedExpr("(" + left.v0 + " || " + rhs.v0 + ")", rhs.v1);
      j = left.v1;
      continue;
    }
    break;
  }
  left
}

fn parse_and(src: String, i: I32) : ParsedExpr => {
  let mut left = parse_cmp(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j + 1 < stringLen(src))) { break; }
    if (stringCharCodeAt(src, j) == 38 && stringCharCodeAt(src, j + 1) == 38) { // '&&'
      let rhs = parse_cmp(src, j + 2);
      left = ParsedExpr("(" + left.v0 + " && " + rhs.v0 + ")", rhs.v1);
      j = left.v1;
      continue;
    }
    break;
  }
  left
}

fn parse_cmp(src: String, i: I32) : ParsedExpr => {
  // comparisons: == != < <= > >=
  let mut left = parse_add(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }

    let c0 = stringCharCodeAt(src, j);
    let c1 = if (j + 1 < stringLen(src)) stringCharCodeAt(src, j + 1) else 0;

    let mut op = "";
    let mut adv = 0;

    // ==
    if (c0 == 61 && c1 == 61) { op = "=="; adv = 2; }
    // !=
    if (op == "" && c0 == 33 && c1 == 61) { op = "!="; adv = 2; }
    // <=
    if (op == "" && c0 == 60 && c1 == 61) { op = "<="; adv = 2; }
    // >=
    if (op == "" && c0 == 62 && c1 == 61) { op = ">="; adv = 2; }
    // <
    if (op == "" && c0 == 60) { op = "<"; adv = 1; }
    // >
    if (op == "" && c0 == 62) { op = ">"; adv = 1; }

    if (op == "") { break; }

    let rhs = parse_add(src, j + adv);
    left = ParsedExpr("(" + left.v0 + " " + op + " " + rhs.v0 + ")", rhs.v1);
    j = left.v1;
  }
  left
}

fn parse_add(src: String, i: I32) : ParsedExpr => {
  let mut left = parse_mul(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }
    let op = stringCharCodeAt(src, j);
    if (!(op == 43 || op == 45)) { break; } // '+' or '-'
    let rhs = parse_mul(src, j + 1);
    let opStr = if (op == 43) "+" else "-";
    left = ParsedExpr("(" + left.v0 + " " + opStr + " " + rhs.v0 + ")", rhs.v1);
    j = left.v1;
  }
  left
}

fn parse_mul(src: String, i: I32) : ParsedExpr => {
  let mut left = parse_unary(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }
    let op = stringCharCodeAt(src, j);
    if (!(op == 42 || op == 47)) { break; } // '*' or '/'
    let rhs = parse_unary(src, j + 1);
    let opStr = if (op == 42) "*" else "/";
    left = ParsedExpr("(" + left.v0 + " " + opStr + " " + rhs.v0 + ")", rhs.v1);
    j = left.v1;
  }
  left
}

fn parse_unary(src: String, i: I32) : ParsedExpr => {
  let j = skip_ws(src, i);
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 33) { // '!'
    let inner = parse_unary(src, j + 1);
    yield ParsedExpr("(!" + inner.v0 + ")", inner.v1);
  }
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 45) { // '-'
    let inner = parse_unary(src, j + 1);
    yield ParsedExpr("(-" + inner.v0 + ")", inner.v1);
  }
  parse_postfix(src, i)
}

fn parse_postfix(src: String, i: I32) : ParsedExpr => {
  let mut left = parse_primary(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);

    // Generic call sugar: f<T>(...) or obj.f<T>(...).
    // Only treat `<...>` as type args if it is balanced and followed by `(`.
    if (j < stringLen(src) && stringCharCodeAt(src, j) == 60) { // '<'
      let skipped = try_skip_type_args_for_call(src, j);
      if (skipped.ok) {
        j = skipped.nextPos;
        continue;
      }
    }

    if (j < stringLen(src) && stringCharCodeAt(src, j) == 40) { // '('
      let args = parse_arg_list(src, j);
      left = ParsedExpr(left.v0 + "(" + args.v0 + ")", args.v1);
      j = left.v1;
      continue;
    }
    if (j < stringLen(src) && stringCharCodeAt(src, j) == 46) { // '.'
      // tuple access: expr.0 => expr[0]
      let t = skip_ws(src, j + 1);
      if (t < stringLen(src) && is_digit(stringCharCodeAt(src, t))) {
        let n = parse_number(src, t);
        left = ParsedExpr(left.v0 + "[" + ("" + n.value) + "]", n.nextPos);
        j = left.v1;
        continue;
      }

      let next = parse_ident(src, j + 1);
      left = ParsedExpr(left.v0 + "." + next.text, next.nextPos);
      j = left.v1;
      continue;
    }
    if (j < stringLen(src) && stringCharCodeAt(src, j) == 91) { // '['
      let mut k = parse_keyword(src, j, "[");
      let idx = parse_expr(src, k);
      k = idx.v1;
      k = skip_ws(src, k);
      if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 93)) { panic("expected ']' "); }
      left = ParsedExpr("vec_get(" + left.v0 + ", " + idx.v0 + ")", k + 1);
      j = left.v1;
      continue;
    }
    break;
  }
  left
}

fn try_skip_type_args_for_call(src: String, i: I32) : ParsedBool => {
  // Returns ParsedBool(true, endIndexAfterGreaterThan) if `<...>` is balanced
  // and followed by `(` (after ws). Otherwise ParsedBool(false, i).
  let mut k = skip_ws(src, i);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 60)) { // '<'
    yield ParsedBool(false, i);
  }
  let mut p = k + 1;
  let mut depth = 1;
  while (p < stringLen(src)) {
    let ch = stringCharCodeAt(src, p);
    if (ch == 60) { depth = depth + 1; p = p + 1; continue; } // '<'
    if (ch == 62) { // '>'
      depth = depth - 1;
      p = p + 1;
      if (depth == 0) {
        let after = skip_ws(src, p);
        if (after < stringLen(src) && stringCharCodeAt(src, after) == 40) { // '('
          yield ParsedBool(true, p);
        }
        yield ParsedBool(false, i);
      }
      continue;
    }
    p = p + 1;
  }
  ParsedBool(false, i)
}

fn parse_arg_list(src: String, i: I32) : ParsedParams => {
  // parses: '(' (expr (',' expr)*)? ')'
  let mut k = skip_ws(src, i);
  k = parse_keyword(src, k, "(");

  k = skip_ws(src, k);
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
    yield ParsedParams("", k + 1);
  }

  let mut out = "";
  let mut first = true;
  while (true) {
    let e = parse_expr(src, k);
    k = e.v1;
    if (first) { out = out + e.v0; } else { out = out + ", " + e.v0; }
    first = false;

    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in arg list"); }
    let c = stringCharCodeAt(src, k);
    if (c == 44) { // ','
      k = k + 1;
      continue;
    }
    if (c == 41) { // ')'
      yield ParsedParams(out, k + 1);
    }
    panic_at(src, k, "expected ',' or ')' in arg list")
  }

  // unreachable
  ParsedParams(out, k)
}

fn skip_angle_brackets(src: String, i: I32) : I32 => {
  // Skips a possibly-nested '<...>' section. Expects '<' at i (after ws).
  let mut k = skip_ws(src, i);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 60)) { // '<'
    panic_at(src, k, "expected '<'");
  }
  k = k + 1;
  let mut depth = 1;
  while (k < stringLen(src)) {
    let ch = stringCharCodeAt(src, k);
    if (ch == 60) { depth = depth + 1; k = k + 1; continue; } // '<'
    if (ch == 62) { // '>'
      depth = depth - 1;
      k = k + 1;
      if (depth == 0) { yield k; }
      continue;
    }
    k = k + 1;
  }
  panic_at(src, k, "unterminated '<...>'")
}

fn parse_struct_lit(src: String, structName: String, i: I32) : ParsedExpr => {
  // Parses: '{' (expr (',' expr)*)? '}' and lowers using struct field order.
  let fields = find_struct_fields(structName);

  let mut k = skip_ws(src, i);
  k = parse_keyword(src, k, "{");

  let mut out = "({ ";
  let mut idx = 0;

  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}' in struct literal"); }
    if (stringCharCodeAt(src, k) == 125) { // '}'
      if (!(idx == vec_len(fields))) {
        panic_at(src, k, "wrong number of values in struct literal for " + structName);
      }
      yield ParsedExpr(out + " })", k + 1);
    }

    if (!(idx < vec_len(fields))) {
      panic_at(src, k, "too many values in struct literal for " + structName);
    }

    let e = parse_expr(src, k);
    k = e.v1;

    let fieldName = vec_get(fields, idx);
    if (idx == 0) { out = out + (fieldName + ": " + e.v0); }
    else { out = out + (", " + fieldName + ": " + e.v0); }
    idx = idx + 1;

    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ',' or '}' in struct literal"); }
    let ch = stringCharCodeAt(src, k);
    if (ch == 44) { // ','
      k = k + 1;
      continue;
    }
    if (ch == 125) { // '}'
      // next loop iteration will close and validate
      continue;
    }
    panic_at(src, k, "expected ',' or '}' in struct literal")
  }

  // unreachable
  ParsedExpr(out + " })", k)
}

fn parse_primary(src: String, i: I32) : ParsedExpr => {
  let j = skip_ws(src, i);
  if (!(j < stringLen(src))) { panic_at(src, j, "expected expression"); }
  let c = stringCharCodeAt(src, j);
  if (starts_with_at(src, j, "if")) {
    let ie = parse_if_expr(src, j);
    yield ie;
  }
  if (starts_with_at(src, j, "match")) {
    let me = parse_match_expr(src, j);
    yield me;
  }
  if (c == 91) { // '['
    let ve = parse_vec_lit(src, j);
    yield ve;
  }
  if (c == 123) { // '{'
    let be = parse_block_expr(src, j);
    yield be;
  }
  if (c == 39) { // '\''
    // Char literal: '\'' <char-or-escape> '\''
    // Lowered to a numeric code point for JS emission.
    let start = j;
    let mut k = j + 1;
    if (!(k < stringLen(src))) { panic_at(src, start, "unterminated char literal"); }

    let mut code: I32 = 0;
    let ch0 = stringCharCodeAt(src, k);
    if (ch0 == 92) { // '\\'
      // Escape sequence.
      k = k + 1;
      if (!(k < stringLen(src))) { panic_at(src, start, "unterminated char escape"); }
      let esc = stringCharCodeAt(src, k);
      code = match (esc) {
        110 => 10, // 'n'
        114 => 13, // 'r'
        116 => 9, // 't'
        48 => 0, // '0'
        92 => 92, // '\\'
        39 => 39, // '\''
        34 => 34, // '"'
        _ => { panic_at(src, k, "unknown char escape"); 0 }
      };
      k = k + 1;
    } else {
      // Single character.
      code = ch0;
      k = k + 1;
    }

    if (!(k < stringLen(src))) { panic_at(src, start, "unterminated char literal"); }
    if (stringCharCodeAt(src, k) != 39) {
      panic_at(src, start, "char literal must contain exactly one character");
    }
    yield ParsedExpr("" + code, k + 1);
  }
  if (c == 34) { // '"'
    let start = j;
    let mut k = j + 1;
    while (k < stringLen(src)) {
      let ch = stringCharCodeAt(src, k);
      if (ch == 34) { yield ParsedExpr(stringSlice(src, start, k + 1), k + 1); }
      if (ch == 92) { // '\\'
        k = k + 1;
        if (k < stringLen(src)) { k = k + 1; continue; }
        panic_at(src, start, "unterminated string");
      }
      k = k + 1;
    }
    panic_at(src, start, "unterminated string");
  }
  if (c == 40) { // '('
    let first = parse_expr(src, j + 1);
    let mut k = skip_ws(src, first.v1);

    // Parenthesized expression
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
      yield ParsedExpr("(" + first.v0 + ")", k + 1);
    }

    // Tuple literal: (a, b, ...)
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 44) { // ','
      let mut out = "[" + first.v0;
      while (true) {
        // consume ','
        k = k + 1;
        k = skip_ws(src, k);

        // allow trailing comma
        if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
          yield ParsedExpr(out + "]", k + 1);
        }

        let e = parse_expr(src, k);
        out = out + ", " + e.v0;
        k = skip_ws(src, e.v1);

        if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in tuple literal"); }
        let ch = stringCharCodeAt(src, k);
        if (ch == 44) { // ','
          continue;
        }
        if (ch == 41) { // ')'
          yield ParsedExpr(out + "]", k + 1);
        }
        panic_at(src, k, "expected ',' or ')' in tuple literal");
      }
    }

    panic_at(src, k, "expected ')'");
  }
  if (is_digit(c)) {
    let n = parse_number(src, j);
    yield ParsedExpr("" + n.value, n.nextPos);
  }
  if (is_ident_start(c)) {
    let id = parse_ident(src, j);
    let mut k = id.nextPos;
    let mut out = id.text;
    while (true) {
      let t = skip_ws(src, k);
      if (!(t + 1 < stringLen(src))) { break; }
      if (!(stringCharCodeAt(src, t) == 58 && stringCharCodeAt(src, t + 1) == 58)) { break; } // '::'
      let next = parse_ident(src, t + 2);
      out = out + "." + next.text;
      k = next.nextPos;
    }

    // Struct literal: Name { <expr>, ... }
    let t2 = skip_ws(src, k);
    if (t2 < stringLen(src) && stringCharCodeAt(src, t2) == 123) { // '{'
      let lit = parse_struct_lit(src, out, t2);
      yield lit;
    }

    yield ParsedExpr(out, k);
  }
  let mut end = j + 32;
  if (end > stringLen(src)) { end = stringLen(src); }
  panic_at(src, j, "expected expression near '" + stringSlice(src, j, end) + "'")
}

fn parse_vec_lit(src: String, i: I32) : ParsedExpr => {
  // vector literal: '[' (expr (',' expr)*)? ']'
  let mut k = parse_keyword(src, i, "[");
  k = skip_ws(src, k);
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 93) { // ']'
    yield ParsedExpr("(() => { const __v = vec_new(); return __v; })()", k + 1);
  }

  let mut pushes = "";
  while (true) {
    let e = parse_expr(src, k);
    k = e.v1;
    pushes = pushes + ("vec_push(__v, " + e.v0 + ");\n");
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ']' in vec literal"); }
    let ch = stringCharCodeAt(src, k);
    if (ch == 44) { // ','
      k = k + 1;
      continue;
    }
    if (ch == 93) { // ']'
      yield ParsedExpr("(() => { const __v = vec_new();\n" + pushes + "return __v;\n})()", k + 1);
    }
    panic_at(src, k, "expected ',' or ']' in vec literal")
  }
  // unreachable
  ParsedExpr("None", k)
}

fn parse_block_body(src: String, i: I32) : ParsedMain => {
  let j = skip_ws(src, i);
  if (!(j < stringLen(src) && stringCharCodeAt(src, j) == 123)) { panic_at(src, j, "expected '{'"); }

  let mut k = j + 1;
  let mut body = "";

  while (true) {
    let t = skip_ws(src, k);
    if (!(t < stringLen(src))) { panic_at(src, t, "expected '}'"); }
    if (stringCharCodeAt(src, t) == 125) { break; }

    let isStmt = starts_with_at(src, t, "let") || starts_with_at(src, t, "while") || starts_with_at(src, t, "if") || starts_with_at(src, t, "yield") || is_field_assign_stmt_start(src, t) || is_assign_stmt_start(src, t) || is_index_assign_stmt_start(src, t);
    if (isStmt) {
      let st = parse_stmt(src, k);
      body = body + st.v0;
      k = st.v1;
      continue;
    }

    // expression statement vs tail expression
    let e = parse_expr(src, k);
    let after = skip_ws(src, e.v1);
    if (after < stringLen(src) && stringCharCodeAt(src, after) == 59) {
      body = body + (e.v0 + ";\n");
      k = after + 1;
      continue;
    }
    // Without semicolons, treat the expression as a statement unless it ends the block.
    if (after < stringLen(src) && stringCharCodeAt(src, after) != 125) {
      body = body + (e.v0 + ";\n");
      k = e.v1;
      continue;
    }
    break;
  }

  // If the block is empty or ends with statements only, treat it as returning `undefined`.
  let t2 = skip_ws(src, k);
  if (t2 < stringLen(src) && stringCharCodeAt(src, t2) == 125) {
    yield ParsedMain(body, "undefined", t2 + 1);
  }

  let tail = parse_expr(src, k);
  k = skip_ws(src, tail.v1);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 125)) { panic_at(src, k, "expected '}'"); }
  ParsedMain(body, tail.v0, k + 1)
}

fn parse_block_expr(src: String, i: I32) : ParsedExpr => {
  let b = parse_block_body(src, i);
  ParsedExpr("(() => {\n" + b.body + "return " + b.expr + ";\n})()", b.v1)
}

fn parse_if_expr(src: String, i: I32) : ParsedExpr => {
  let mut k = parse_keyword(src, i, "if");
  k = parse_keyword(src, k, "(");
  let cond = parse_expr(src, k);
  k = cond.v1;
  k = parse_keyword(src, k, ")");
  let t1 = skip_ws(src, k);
  let thenE = if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 123) parse_block_expr(src, k) else parse_expr(src, k);
  k = thenE.v1;
  k = parse_keyword(src, k, "else");
  let t2 = skip_ws(src, k);
  let elseE = if (t2 < stringLen(src) && stringCharCodeAt(src, t2) == 123) parse_block_expr(src, k) else parse_expr(src, k);
  ParsedExpr("(" + cond.v0 + " ? " + thenE.v0 + " : " + elseE.v0 + ")", elseE.v1)
}

fn parse_match_expr(src: String, i: I32) : ParsedExpr => {
  let mut k = parse_keyword(src, i, "match");
  k = parse_keyword(src, k, "(");
  let scrut = parse_expr(src, k);
  k = scrut.v1;
  k = parse_keyword(src, k, ")");
  k = parse_keyword(src, k, "{");

  let mut cases = "";
  let mut def = "";

  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
    if (stringCharCodeAt(src, k) == 125) { k = k + 1; break; }

    // pattern: number | string | true/false | _
    let mut pat = "";
    let c0 = stringCharCodeAt(src, k);
    if (c0 == 34) { // string
      let lit = parse_primary(src, k);
      pat = lit.v0;
      k = lit.v1;
    } else {
      if (is_digit(c0)) {
        let n = parse_number(src, k);
        pat = "" + n.value;
        k = n.nextPos;
      } else {
        let id = parse_ident(src, k);
        pat = id.text;
        k = id.nextPos;
      }
    }

    k = parse_keyword(src, k, "=>");

    // arm expression: block expr or normal expr
    let t = skip_ws(src, k);
    let arm = if (t < stringLen(src) && stringCharCodeAt(src, t) == 123) parse_block_expr(src, k) else parse_expr(src, k);
    k = arm.v1;

    if (!(pat == "_" || pat == "true" || pat == "false" || is_digit(stringCharCodeAt(pat, 0)) || (stringLen(pat) > 0 && stringCharCodeAt(pat, 0) == 34))) {
      panic_at(src, k, "unsupported match pattern: " + pat);
    }

    if (pat == "_") {
      def = arm.v0;
    } else {
      cases = cases + ("case " + pat + ": return " + arm.v0 + ";\n");
    }

    k = skip_ws(src, k);
    if (k < stringLen(src)) {
      let ch = stringCharCodeAt(src, k);
      if (ch == 44 || ch == 59) { // ',' or ';'
        k = k + 1;
      }
    }
  }

  if (def == "") { panic_at(src, k, "match requires _ arm"); }

  ParsedExpr("(() => { switch (" + scrut.v0 + ") {\n" + cases + "default: return " + def + ";\n} })()", k)
}

fn parse_fn_decl_named(src: String, i: I32, jsName: String, exportThis: Bool) : String => {
  let mut k = parse_keyword(src, i, "fn");
  let name = parse_ident(src, k);
  k = name.nextPos;

  // Optional generic params: fn name<T, U>(...)
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) { // '<'
    k = skip_angle_brackets(src, t0);
  }

  let params = parse_param_list(src, k);
  k = params.v1;

  // Optional return type: : Type
  let t1 = skip_ws(src, k);
  if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 58) { // ':'
    let _rt = parse_type_expr(src, t1 + 1);
    k = _rt.v1;
  }

  k = parse_keyword(src, k, "=>");
  let body = parse_main_body(src, k);
  k = body.v1;

  let exportKw = if (exportThis) "export " else "";
  let js = exportKw + "function " + jsName + "(" + params.v0 + ") {\n" + body.body + "return " + body.expr + ";\n}\n";
  ParsedFn(js, k, name.text)
}

fn parse_module_decl(src: String, i: I32, prefix: String, exportTop: Bool) : String => {
  // module Name { (fn ... | module ...)* }
  let mut k = parse_keyword(src, i, "module");
  let modName = parse_ident(src, k);
  k = modName.nextPos;
  k = parse_keyword(src, k, "{");

  let mut decls = "";
  let mut entries = "";
  let mut first = true;

  while (true) {
    let t = skip_ws(src, k);
    if (!(t < stringLen(src))) { panic_at(src, t, "expected '}'"); }
    if (stringCharCodeAt(src, t) == 125) { k = t + 1; break; }

    if (starts_with_at(src, t, "fn")) {
      let fnParsed = parse_fn_decl_named(src, k, prefix + "__" + modName.text + "__" + "fn" + "__" + "tmp", false);
      // we emitted with a temp name; re-emit with stable js name including function name
      // (parse again from the same start)
      let fn2 = parse_fn_decl_named(src, k, prefix + "__" + modName.text + "__" + fnParsed.v2, false);
      decls = decls + fn2.v0;
      if (first) { entries = entries + (fn2.v2 + ": " + (prefix + "__" + modName.text + "__" + fn2.v2)); }
      else { entries = entries + (", " + fn2.v2 + ": " + (prefix + "__" + modName.text + "__" + fn2.v2)); }
      first = false;
      k = fn2.v1;
      continue;
    }

    if (starts_with_at(src, t, "module")) {
      let inner = parse_module_decl(src, k, prefix + "__" + modName.text, false);
      decls = decls + inner.v0;
      // inner module exports as const with its own name; include it as property
      // since `exportTop` is false here, inner will be `const <Inner> = {...}`
      // and we reference that name.
      let innerName = parse_ident(src, parse_keyword(src, k, "module"));
      // NOTE: parse_ident above is safe since parse_module_decl already parsed it; this is a tiny hack to recover name.
      let prop = innerName.text;
      if (first) { entries = entries + (prop + ": " + prop); }
      else { entries = entries + (", " + prop + ": " + prop); }
      first = false;
      k = inner.v1;
      continue;
    }

    panic_at(src, t, "expected fn or module inside module")
  }

  let obj = "{ " + entries + " }";
  let header = if (exportTop) "export const " else "const ";
  let code = decls + header + modName.text + " = " + obj + ";\n";
  ParsedStmt(code, k)
}

fn parse_imports(src: String, i: I32) : ParsedImports => {
  let mut k = i;
  let mut out = "";
  while (true) {
    let j = skip_ws(src, k);
    if (starts_with_at(src, j, "import")) {
      panic_at(src, j, "`import` is not supported. Use `from <module> use { ... };` instead.");
    }
    if (!starts_with_at(src, j, "from")) { break; }

    k = parse_keyword(src, k, "from");
    let mod = parse_module_path(src, k);
    k = mod.nextPos;
    k = parse_keyword(src, k, "use");
    k = parse_keyword(src, k, "{");

    let mut names = "";
    let mut first = true;
    while (true) {
      k = skip_ws(src, k);
      if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
      if (stringCharCodeAt(src, k) == 125) { k = k + 1; break; }
      let id = parse_ident(src, k);
      k = id.nextPos;
      if (first) { names = names + id.text; } else { names = names + ", " + id.text; }
      first = false;
      k = skip_ws(src, k);
      if (k < stringLen(src) && stringCharCodeAt(src, k) == 44) { k = k + 1; continue; }
      k = skip_ws(src, k);
      if (k < stringLen(src) && stringCharCodeAt(src, k) == 125) { k = k + 1; break; }
      panic_at(src, k, "expected ',' or '}' in import list");
    }

    k = parse_optional_semicolon(src, k);

    let importPath = "./" + module_path_to_relpath(mod.text) + ".mjs";
    out = out + ("import { " + names + " } from \"" + importPath + "\";\n");
  }
  ParsedImports(out, k)
}

fn parse_type_expr(src: String, i: I32) : ParsedType => {
  // Minimal-but-real type expression parser.
  // Produces a textual representation (v0) and the index after the type (v1).
  let mut k = skip_ws(src, i);
  if (!(k < stringLen(src))) { panic_at(src, k, "expected type"); }

  let c = stringCharCodeAt(src, k);

  // Slice: *[T]
  if (c == 42) { // '*'
    k = k + 1;
    k = parse_keyword(src, k, "[");
    let inner = parse_type_expr(src, k);
    k = inner.v1;
    k = parse_keyword(src, k, "]");
    yield ParsedType("*[" + inner.v0 + "]", k);
  }

  // Array: [T; N; M]
  if (c == 91) { // '['
    k = parse_keyword(src, k, "[");
    let inner = parse_type_expr(src, k);
    k = inner.v1;
    let mut sizes = "";
    while (true) {
      let t = skip_ws(src, k);
      if (!(t < stringLen(src) && stringCharCodeAt(src, t) == 59)) { break; } // ';'
      let n = parse_number(src, t + 1);
      sizes = sizes + ";" + ("" + n.value);
      k = n.nextPos;
    }
    k = parse_keyword(src, k, "]");
    yield ParsedType("[" + inner.v0 + sizes + "]", k);
  }

  // Tuple / function type: (T, U) or (T, U) => R
  if (c == 40) { // '('
    k = parse_keyword(src, k, "(");
    k = skip_ws(src, k);
    let mut parts = "";
    let mut first = true;
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
      k = k + 1;
    } else {
      while (true) {
        let t1 = parse_type_expr(src, k);
        k = t1.v1;
        if (first) { parts = parts + t1.v0; } else { parts = parts + ", " + t1.v0; }
        first = false;
        k = skip_ws(src, k);
        if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in type"); }
        let ch = stringCharCodeAt(src, k);
        if (ch == 44) { // ','
          k = k + 1;
          continue;
        }
        if (ch == 41) { // ')'
          k = k + 1;
          break;
        }
        panic_at(src, k, "expected ',' or ')' in type");
      }
    }

    let t2 = skip_ws(src, k);
    if (t2 + 1 < stringLen(src) && stringCharCodeAt(src, t2) == 61 && stringCharCodeAt(src, t2 + 1) == 62) { // '=>'
      let ret = parse_type_expr(src, t2 + 2);
      yield ParsedType("(" + parts + ") => " + ret.v0, ret.v1);
    }
    yield ParsedType("(" + parts + ")", k);
  }

  // Name / generic: Ident or Ident<...>
  let name = parse_ident(src, k);
  k = name.nextPos;
  let mut out = name.text;

  let t3 = skip_ws(src, k);
  if (t3 < stringLen(src) && stringCharCodeAt(src, t3) == 60) { // '<'
    k = parse_keyword(src, t3, "<");
    let mut args = "";
    let mut firstArg = true;
    while (true) {
      let a = parse_type_expr(src, k);
      k = a.v1;
      if (firstArg) { args = args + a.v0; } else { args = args + ", " + a.v0; }
      firstArg = false;
      k = skip_ws(src, k);
      if (!(k < stringLen(src))) { panic_at(src, k, "expected '>' in generic type"); }
      let ch = stringCharCodeAt(src, k);
      if (ch == 44) { // ','
        k = k + 1;
        continue;
      }
      if (ch == 62) { // '>'
        k = k + 1;
        break;
      }
      panic_at(src, k, "expected ',' or '>' in generic type");
    }
    out = out + "<" + args + ">";
  }

  ParsedType(out, k)
}

fn parse_param_list(src: String, i: I32) : ParsedParams => {
  // parses: '(' (ident (',' ident)*)? ')'
  let mut k = parse_keyword(src, i, "(");
  k = skip_ws(src, k);
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
    yield ParsedParams("", k + 1);
  }
  let mut out = "";
  let mut first = true;
  while (true) {
    let id = parse_ident(src, k);
    k = id.nextPos;

    // Optional param type annotation: `name: Type`
    let t0 = skip_ws(src, k);
    if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) { // ':'
      let _ty = parse_type_expr(src, t0 + 1);
      k = _ty.v1;
    }

    if (first) { out = out + id.text; } else { out = out + ", " + id.text; }
    first = false;

    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in param list"); }
    let c = stringCharCodeAt(src, k);
    if (c == 44) { // ','
      k = k + 1;
      continue;
    }
    if (c == 41) { // ')'
      yield ParsedParams(out, k + 1);
    }
    panic_at(src, k, "expected ',' or ')' in param list")
  }
  ParsedParams(out, k)
}

fn parse_extern_decl(src: String, i: I32) : String => {
  let mut k = parse_keyword(src, i, "extern");
  k = parse_keyword(src, k, "from");
  let mod = parse_module_path(src, k);
  k = mod.nextPos;
  k = parse_keyword(src, k, "use");
  k = parse_keyword(src, k, "{");

  let mut names = "";
  let mut first = true;
  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
    if (stringCharCodeAt(src, k) == 125) { k = k + 1; break; }
    let id = parse_ident(src, k);
    k = id.nextPos;
    if (first) { names = names + id.text; } else { names = names + ", " + id.text; }
    first = false;
    k = skip_ws(src, k);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 44) { k = k + 1; continue; }
    k = skip_ws(src, k);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 125) { k = k + 1; break; }
    panic_at(src, k, "expected ',' or '}' in extern list");
  }

  k = parse_optional_semicolon(src, k);

  let mut importPath = "";
  if (starts_with_at(mod.text, 0, "rt::")) { importPath = "./rt/" + stringSlice(mod.text, 4, stringLen(mod.text)) + ".mjs"; }
  if (importPath == "" && starts_with_at(mod.text, 0, "node::")) { importPath = "node:" + stringSlice(mod.text, 6, stringLen(mod.text)); }
  if (importPath == "") { panic_at(src, k, "unsupported extern module: " + mod.text); }

  ParsedStmt("import { " + names + " } from \"" + importPath + "\";\n", k)
}

fn parse_fn_decl2(src: String, i: I32, exportAll: Bool) : String => {
  let mut k = parse_keyword(src, i, "fn");
  let name = parse_ident(src, k);
  k = name.nextPos;
  if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

  // Optional generic params: fn name<T, U>(...)
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) { // '<'
    k = skip_angle_brackets(src, t0);
  }

  let params = parse_param_list(src, k);
  k = params.v1;

  // Optional return type: : Type
  let t1 = skip_ws(src, k);
  if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 58) { // ':'
    let _rt = parse_type_expr(src, t1 + 1);
    k = _rt.v1;
  }

  k = parse_keyword(src, k, "=>");
  let body = parse_main_body(src, k);
  k = body.v1;

  let exportKw = if (exportAll || name.text == "main") "export " else "";
  let js = exportKw + "function " + name.text + "(" + params.v0 + ") {\n" + body.body + "return " + body.expr + ";\n}\n";
  ParsedStmt(js, k)
}

fn parse_class_fn_decl2(src: String, i: I32, exportAll: Bool) : String => {
  let mut k = parse_keyword(src, i, "class");
  k = parse_keyword(src, k, "fn");
  let name = parse_ident(src, k);
  k = name.nextPos;
  if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

  // Optional generic params: class fn name<T, U>(...)
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) { // '<'
    k = skip_angle_brackets(src, t0);
  }

  let params = parse_param_list(src, k);
  k = params.v1;

  // Optional return type: : Type
  let t1 = skip_ws(src, k);
  if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 58) { // ':'
    let _rt = parse_type_expr(src, t1 + 1);
    k = _rt.v1;
  }

  k = parse_keyword(src, k, "=>");
  let body = parse_main_body(src, k);
  k = body.v1;

  // Minimal `class fn` lowering: execute body statements then yield `this`.
  // For now, `this` is just an object containing parameters.
  // (This is sufficient for our compiler's internal record-like classes.)
  let exportKw = if (exportAll || name.text == "main") "export " else "";
  let mut fields = "";
  // params.v0 is the comma-joined param list; we need `{ a: a, b: b }`.
  // Build it by re-parsing the param list text.
  let mut pi = 0;
  let mut first = true;
  while (pi < stringLen(params.v0)) {
    // skip spaces/commas
    while (pi < stringLen(params.v0)) {
      let ch = stringCharCodeAt(params.v0, pi);
      if (ch == 32 || ch == 9 || ch == 10 || ch == 13 || ch == 44) { pi = pi + 1; continue; }
      break;
    }
    if (!(pi < stringLen(params.v0))) { break; }
    let start = pi;
    while (pi < stringLen(params.v0)) {
      let ch = stringCharCodeAt(params.v0, pi);
      if (ch == 44) { break; }
      pi = pi + 1;
    }
    let p = stringSlice(params.v0, start, pi);
    // trim trailing spaces
    let mut end = stringLen(p);
    while (end > 0) {
      let ch = stringCharCodeAt(p, end - 1);
      if (ch == 32 || ch == 9 || ch == 10 || ch == 13) { end = end - 1; continue; }
      break;
    }
    let nameOnly = stringSlice(p, 0, end);
    if (nameOnly != "") {
      if (first) { fields = fields + (nameOnly + ": " + nameOnly); }
      else { fields = fields + (", " + nameOnly + ": " + nameOnly); }
      first = false;
    }
  }

  let js = exportKw + "function " + name.text + "(" + params.v0 + ") {\n" + body.body + "return { " + fields + " };\n}\n";
  ParsedStmt(js, k)
}

fn parse_fn_decl(src: String, i: I32) : String => parse_fn_decl2(src, i, false)

fn parse_optional_semicolon(src: String, i: I32) : I32 => {
  let j = skip_ws(src, i);
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 59) { yield j + 1; }
  i
}

fn parse_required_semicolon(src: String, i: I32) : I32 => {
  let j = skip_ws(src, i);
  if (!(j < stringLen(src) && stringCharCodeAt(src, j) == 59)) { panic_at(src, j, "expected ';'"); }
  j + 1
}

fn skip_type_expr(src: String, i: I32) : I32 => {
  // Skip a type expression in places where we don't need semantics yet.
  // Stops before ',', ';', or '}' when not inside angle brackets.
  let mut k = skip_ws(src, i);
  let mut depth = 0;
  while (k < stringLen(src)) {
    let ch = stringCharCodeAt(src, k);
    if (ch == 60) { depth = depth + 1; k = k + 1; continue; } // '<'
    if (ch == 62) { // '>'
      if (depth > 0) { depth = depth - 1; }
      k = k + 1;
      continue;
    }
    if (depth == 0 && (ch == 44 || ch == 59 || ch == 125)) { yield k; } // ',', ';', '}'
    k = k + 1;
  }
  panic_at(src, k, "unterminated type")
}

fn parse_struct_decl(src: String, i: I32) : String => {
  // struct Name { field: Type, ... }
  let mut k = parse_keyword(src, i, "struct");
  let name = parse_ident(src, k);
  k = name.nextPos;
  if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

  // Optional generic params: struct Name<T, U> { ... }
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) { // '<'
    k = skip_angle_brackets(src, t0);
  }

  k = parse_keyword(src, k, "{");

  let fields = vec_new();

  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
    if (stringCharCodeAt(src, k) == 125) { // '}'
      k = k + 1;
      break;
    }

    let field = parse_ident(src, k);
    k = field.nextPos;
    k = parse_keyword(src, k, ":");
    let _ty = parse_type_expr(src, k);
    k = _ty.v1;

    vec_push(fields, field.text);

    k = skip_ws(src, k);
    if (k < stringLen(src)) {
      let ch = stringCharCodeAt(src, k);
      if (ch == 44 || ch == 59) { // ',' or ';'
        k = k + 1;
      }
    }
  }

  add_struct_def(name.text, fields);
  ParsedStmt("", k)
}

fn parse_type_union_decl(src: String, i: I32, exportAll: Bool) : String => {
  // type Name<T, ...> = Variant1<X> | Variant2 | ...;
  let mut k = parse_keyword(src, i, "type");
  let _name = parse_ident(src, k);
  k = _name.nextPos;
  if (is_identifier_too_short(_name.text)) { warn_short_identifier(src, _name.startPos, _name.text); }

  // optional type params on the alias name
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) { // '<'
    k = skip_angle_brackets(src, t0);
  }

  k = parse_keyword(src, k, "=");

  let mut out = "";
  let mut first = true;
  while (true) {
    if (!first) { k = parse_keyword(src, k, "|"); }
    first = false;

    let v = parse_ident(src, k);
    let variant = v.text;
    k = v.nextPos;

    let mut hasPayload = false;
    let t1 = skip_ws(src, k);
    if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 60) { // '<'
      hasPayload = true;
      k = skip_angle_brackets(src, t1);
    }

    let header = if (exportAll) "export const " else "const ";
    if (hasPayload) {
      out = out + (header + variant + " = (value) => ({ tag: \"" + variant + "\", value });\n");
    } else {
      out = out + (header + variant + " = { tag: \"" + variant + "\" };\n");
    }

    let t2 = skip_ws(src, k);
    if (!(t2 < stringLen(src))) { yield ParsedStmt(out, k); }
    let ch = stringCharCodeAt(src, t2);
    if (ch == 59) { // ';'
      k = t2 + 1;
      break;
    }
    if (ch == 124) { // '|'
      // continue parsing variants
      continue;
    }
    panic_at(src, t2, "expected '|' or ';' in union type")
  }

  ParsedStmt(out, k)
}

fn parse_mut_opt(src: String, i: I32) : ParsedBool => {
  let j = skip_ws(src, i);
  if (starts_with_at(src, j, "mut")) {
    // Require a boundary: next char must not be an identifier character.
    if (j + 3 < stringLen(src)) {
      let n = stringCharCodeAt(src, j + 3);
      if (is_ident_part(n)) { yield ParsedBool(false, i); }
    }
    yield ParsedBool(true, j + 3);
  }
  ParsedBool(false, i)
}

fn parse_stmt_block(src: String, i: I32) : ParsedStmt => {
  let mut k = skip_ws(src, i);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 123)) { panic_at(src, k, "expected '{'"); }
  k = k + 1;
  let mut body = "";
  while (true) {
    let t = skip_ws(src, k);
    if (!(t < stringLen(src))) { panic_at(src, t, "expected '}'"); }
    if (stringCharCodeAt(src, t) == 125) { yield ParsedExpr(body, t + 1); }

    let st = parse_stmt(src, k);
    body = body + st.v0;
    k = st.v1;
  }
  // unreachable
  ParsedExpr(body, k)
}

fn parse_stmt(src: String, i: I32) : ParsedStmt => {
  let mut k = skip_ws(src, i);

  // yield / early return
  if (starts_with_at(src, k, "yield")) {
    k = parse_keyword(src, k, "yield");
    k = skip_ws(src, k);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 59) { // ';'
      yield ParsedStmt("return;\n", k + 1);
    }
    let e = parse_expr(src, k);
    k = e.v1;
    k = parse_optional_semicolon(src, k);
    yield ParsedStmt("return " + e.v0 + ";\n", k);
  }

  // let / let mut
  if (starts_with_at(src, k, "let")) {
    k = parse_keyword(src, k, "let");
    let mutOpt = parse_mut_opt(src, k);
    k = mutOpt.nextPos;
    let name = parse_ident(src, k);
    k = name.nextPos;
    if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

    // Optional let type annotation: `let x: T = ...`
    let t0 = skip_ws(src, k);
    if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) { // ':'
      let _ty = parse_type_expr(src, t0 + 1);
      k = _ty.v1;
    }

    k = parse_keyword(src, k, "=");
    let expr = parse_expr(src, k);
    k = expr.v1;
    k = parse_optional_semicolon(src, k);
    let declKw = if (mutOpt.ok) "let" else "const";
    yield ParsedStmt(declKw + " " + name.text + " = " + expr.v0 + ";\n", k);
  }

  // while (...) { ... }
  if (starts_with_at(src, k, "while")) {
    k = parse_keyword(src, k, "while");
    k = parse_keyword(src, k, "(");
    let cond = parse_expr(src, k);
    k = cond.v1;
    k = parse_keyword(src, k, ")");
    let body = parse_stmt_block(src, k);
    k = body.v1;
    // optional semicolon after the while block
    k = parse_optional_semicolon(src, k);
    yield ParsedStmt("while (" + cond.v0 + ") {\n" + body.v0 + "}\n", k);
  }

  // if (...) { ... } (else { ... })?
  if (starts_with_at(src, k, "if")) {
    k = parse_keyword(src, k, "if");
    k = parse_keyword(src, k, "(");
    let cond = parse_expr(src, k);
    k = cond.v1;
    k = parse_keyword(src, k, ")");
    let thenB = parse_stmt_block(src, k);
    k = thenB.v1;
    let j = skip_ws(src, k);
    if (starts_with_at(src, j, "else")) {
      k = parse_keyword(src, k, "else");
      let elseB = parse_stmt_block(src, k);
      k = elseB.v1;
      // optional semicolon after the if/else
      k = parse_optional_semicolon(src, k);
      yield ParsedStmt("if (" + cond.v0 + ") {\n" + thenB.v0 + "} else {\n" + elseB.v0 + "}\n", k);
    }
    // optional semicolon after the if
    k = parse_optional_semicolon(src, k);
    yield ParsedStmt("if (" + cond.v0 + ") {\n" + thenB.v0 + "}\n", k);
  }

  // assignment: <ident> = <expr>;
  if (is_assign_stmt_start(src, k)) {
    let name = parse_ident(src, k);
    k = name.nextPos;
    if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }
    k = parse_keyword(src, k, "=");
    let expr = parse_expr(src, k);
    k = expr.v1;
    k = parse_optional_semicolon(src, k);
    yield ParsedStmt(name.text + " = " + expr.v0 + ";\n", k);
  }

  // field assignment: <expr>.<field>(.<field>)* = <expr>;
  if (is_field_assign_stmt_start(src, k)) {
    let base = parse_ident(src, k);
    k = base.nextPos;
    let mut lhs = base.text;
    while (true) {
      let t = skip_ws(src, k);
      if (!(t < stringLen(src) && stringCharCodeAt(src, t) == 46)) { break; } // '.'
      k = parse_keyword(src, k, ".");
      let part = parse_ident(src, k);
      lhs = lhs + "." + part.text;
      k = part.nextPos;
    }
    k = parse_keyword(src, k, "=");
    let expr = parse_expr(src, k);
    k = expr.v1;
    k = parse_optional_semicolon(src, k);
    yield ParsedStmt(lhs + " = " + expr.v0 + ";\n", k);
  }

  // index assignment: <ident>[<expr>] = <expr>;
  if (is_index_assign_stmt_start(src, k)) {
    let name = parse_ident(src, k);
    k = name.nextPos;
    k = parse_keyword(src, k, "[");
    let idx = parse_expr(src, k);
    k = idx.v1;
    k = parse_keyword(src, k, "]");
    k = parse_keyword(src, k, "=");
    let val = parse_expr(src, k);
    k = val.v1;
    k = parse_optional_semicolon(src, k);
    yield ParsedStmt("vec_set(" + name.text + ", " + idx.v0 + ", " + val.v0 + ");\n", k);
  }

  // expression statement: <expr>;
  let e = parse_expr(src, k);
  k = e.v1;
  k = parse_optional_semicolon(src, k);
  yield ParsedStmt(e.v0 + ";\n", k);

  panic_at(src, k, "expected statement")
}

fn is_index_assign_stmt_start(src: String, i: I32) : Bool => {
  let mut j = skip_ws(src, i);
  if (!(j < stringLen(src))) { yield false; }
  let c0 = stringCharCodeAt(src, j);
  if (!is_ident_start(c0)) { yield false; }
  j = j + 1;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (!is_ident_part(c)) { break; }
    j = j + 1;
  }
  j = skip_ws(src, j);
  j < stringLen(src) && stringCharCodeAt(src, j) == 91 // '['
}

fn is_assign_stmt_start(src: String, i: I32) : Bool => {
  let mut j = skip_ws(src, i);
  if (!(j < stringLen(src))) { yield false; }
  let c0 = stringCharCodeAt(src, j);
  if (!is_ident_start(c0)) { yield false; }
  j = j + 1;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (!is_ident_part(c)) { break; }
    j = j + 1;
  }
  j = skip_ws(src, j);
  if (!(j < stringLen(src) && stringCharCodeAt(src, j) == 61)) { yield false; }
  // exclude '==' and '=>'
  if (j + 1 < stringLen(src)) {
    let n = stringCharCodeAt(src, j + 1);
    if (n == 61 || n == 62) { yield false; }
  }
  true
}

fn is_field_assign_stmt_start(src: String, i: I32) : Bool => {
  let mut j = skip_ws(src, i);
  if (!(j < stringLen(src))) { yield false; }
  let c0 = stringCharCodeAt(src, j);
  if (!is_ident_start(c0)) { yield false; }
  j = j + 1;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (!is_ident_part(c)) { break; }
    j = j + 1;
  }
  j = skip_ws(src, j);

  // require at least one .ident
  if (!(j < stringLen(src) && stringCharCodeAt(src, j) == 46)) { yield false; }

  while (j < stringLen(src) && stringCharCodeAt(src, j) == 46) {
    j = j + 1; // '.'
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { yield false; }
    let c1 = stringCharCodeAt(src, j);
    if (!is_ident_start(c1)) { yield false; }
    j = j + 1;
    while (j < stringLen(src)) {
      let c = stringCharCodeAt(src, j);
      if (!is_ident_part(c)) { break; }
      j = j + 1;
    }
    j = skip_ws(src, j);
  }

  if (!(j < stringLen(src) && stringCharCodeAt(src, j) == 61)) { yield false; }
  // exclude '==' and '=>'
  if (j + 1 < stringLen(src)) {
    let n = stringCharCodeAt(src, j + 1);
    if (n == 61 || n == 62) { yield false; }
  }
  true
}

fn parse_main_body(src: String, i: I32) : ParsedMain => {
  let j = skip_ws(src, i);
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 123) { // '{'
    let b = parse_block_body(src, i);
    yield ParsedMain(b.body, b.expr, b.v1);
  }

  // expression main body
  let e = parse_expr(src, i);
  ParsedMain("", e.v0, e.v1)
}

fn compile_tiny2(src: String, requireMain: Bool, exportAll: Bool) : String => {
  // Parse:
  //   (extern from <mod> use { <idents> };)*
  //   (from <mod> use { <idents> };)*
  //   (type <ident>(<typeparams>)? = <variants>;)*
  //   (struct <ident> { <fields> })*
  //   (let <ident> = <expr>;)*
  //   (fn <ident>(<params>) => <expr|block>)*
  let mut i = 0;

  // Reset per-file state.
  reset_struct_defs();

  let mut out = "// compiled by selfhost tuffc\n";

  // zero or more extern declarations
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "extern")) {
      let ex = parse_extern_decl(src, i);
      out = out + ex.v0;
      i = ex.v1;
      continue;
    }
    break;
  }

  // zero or more imports
  let imps = parse_imports(src, i);
  out = out + imps.v0;
  i = imps.v1;

  // zero or more module declarations
  while (true) {
    let j = skip_ws(src, i);
    if (!starts_with_at(src, j, "module")) { break; }
    let m = parse_module_decl(src, i, "M", true);
    out = out + m.v0;
    i = m.v1;
  }

  // zero or more type / struct declarations
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "type")) {
      let td = parse_type_union_decl(src, i, exportAll);
      out = out + td.v0;
      i = td.v1;
      continue;
    }
    if (starts_with_at(src, j, "struct")) {
      let sd = parse_struct_decl(src, i);
      out = out + sd.v0;
      i = sd.v1;
      continue;
    }
    break;
  }

  // zero or more let statements
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "let")) {
      i = parse_keyword(src, i, "let");
      let mutOpt = parse_mut_opt(src, i);
      i = mutOpt.nextPos;
      let name = parse_ident(src, i);
      i = name.nextPos;

      // Optional let type annotation: `let x: T = ...`
      let t0 = skip_ws(src, i);
      if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) { // ':'
        let _ty = parse_type_expr(src, t0 + 1);
        i = _ty.v1;
      }

      i = parse_keyword(src, i, "=");
      let expr = parse_expr(src, i);
      i = expr.v1;
      i = parse_optional_semicolon(src, i);
      let declKw = if (mutOpt.ok) "let" else "const";
      out = out + (declKw + " " + name.text + " = " + expr.v0 + ";\n");
      continue;
    }
    break;
  }

  // main
  let mut sawMain = false;
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "fn")) {
      let f = parse_fn_decl2(src, i, exportAll);
      if (starts_with_at(f.v0, 0, "export function main")) { sawMain = true; }
      out = out + f.v0;
      i = f.v1;
      continue;
    }
    if (starts_with_at(src, j, "class")) {
      let f = parse_class_fn_decl2(src, i, exportAll);
      out = out + f.v0;
      i = f.v1;
      continue;
    }
    break;
  }
  if (requireMain && !sawMain) { panic_at(src, i, "expected fn main"); }
  out
}

fn compile_tiny(src: String) : String => compile_tiny2(src, true, false)
fn compile_module(src: String) : String => compile_tiny2(src, false, true)

fn compile_project(entryPath: String, outPath: String) : Void => {
  // Very small multi-file compiler:
  // - supports `from <path> use { ... };` for local file modules
  // - resolves to <path>.tuff relative to the importing file
  // - emits to the same relative path under outDir: <path>.mjs

  let outDir = pathDirname(outPath);

  let mut queue = vec_new();
  vec_push(queue, entryPath);

  let mut done = vec_new();

  while (vec_len(queue) > 0) {
    let path = vec_get(queue, vec_len(queue) - 1);

    // set current file for better error messages
    set_current_file(path);
    // pop
    // (no vec_pop; emulate by shrinking via set+len conventions isn't available,
    //  so we'll use a simple index-based loop instead)
    // We'll just process the last item and rebuild the queue without it.
    let mut newQ = vec_new();
    let mut qi = 0;
    while (qi + 1 < vec_len(queue)) {
      vec_push(newQ, vec_get(queue, qi));
      qi = qi + 1;
    }
    queue = newQ;

    // skip if already done
    let mut already = false;
    let mut di = 0;
    while (di < vec_len(done)) {
      if (vec_get(done, di) == path) { already = true; break; }
      di = di + 1;
    }
    if (already) { continue; }
    vec_push(done, path);

    let src = readTextFile(path);

    // discover imports for queueing (same parsing as emitter)
    let mut scan = 0;
    // skip externs
    while (true) {
      let j = skip_ws(src, scan);
      if (starts_with_at(src, j, "extern")) {
        let ex = parse_extern_decl(src, scan);
        scan = ex.v1;
        continue;
      }
      break;
    }
    while (true) {
      let j = skip_ws(src, scan);
      if (starts_with_at(src, j, "import")) {
        panic_at(src, j, "`import` is not supported. Use `from <module> use { ... };` instead.");
      }
      if (!starts_with_at(src, j, "from")) { break; }
      scan = parse_keyword(src, scan, "from");
      let mod = parse_module_path(src, scan);
      scan = mod.nextPos;
      scan = parse_keyword(src, scan, "use");
      scan = parse_keyword(src, scan, "{");
      // consume name list
      while (true) {
        scan = skip_ws(src, scan);
        if (!(scan < stringLen(src))) { panic_at(src, scan, "expected '}'"); }
        if (stringCharCodeAt(src, scan) == 125) { scan = scan + 1; break; }
        let id = parse_ident(src, scan);
        scan = id.nextPos;
        scan = skip_ws(src, scan);
        if (scan < stringLen(src) && stringCharCodeAt(src, scan) == 44) { scan = scan + 1; continue; }
        scan = skip_ws(src, scan);
        if (scan < stringLen(src) && stringCharCodeAt(src, scan) == 125) { scan = scan + 1; break; }
        panic_at(src, scan, "expected ',' or '}' in import list");
      }
      scan = parse_optional_semicolon(src, scan);

      // queue dependency file
      let baseDir = pathDirname(path);
      let rel = module_path_to_relpath(mod.text);
      let depPath = pathJoin(baseDir, rel + ".tuff");
      vec_push(queue, depPath);
    }

    let js = if (path == entryPath) compile_tiny(src) else compile_module(src);
    // choose output name
    let outFile = if (path == entryPath) outPath else {
      // Preserve relative path under outDir.
      // Example: <base>/std/test.tuff -> <outDir>/std/test.mjs
      // We compute the filename only and keep directories by slicing from baseDir.
      let baseDir = pathDirname(entryPath);
      let mut prefixLen = stringLen(baseDir);
      // If the baseDir doesn't end with a separator, allow one separator.
      let mut relStart = prefixLen;
      if (relStart < stringLen(path)) {
        let ch = stringCharCodeAt(path, relStart);
        if (ch == 47 || ch == 92) { relStart = relStart + 1; }
      }
      let relPath = stringSlice(path, relStart, stringLen(path));
      // relPath ends with .tuff; replace with .mjs
      let relNoExt = stringSlice(relPath, 0, stringLen(relPath) - 5);
      pathJoin(outDir, relNoExt + ".mjs")
    };
    writeTextFile(outFile, js);
  }
}
