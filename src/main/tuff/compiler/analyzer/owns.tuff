// Ownership and move semantics for the analyzer.
//
// Copy types: primitives, structs with all Copy fields, arrays with Copy elements
// Move types: String, structs with non-Copy fields, arrays with non-Copy elements
//
// Move semantics:
// - Assignment transfers ownership: let y = x; (x is moved, can't be used)
// - Function call transfers ownership: f(x); (x is moved, can't be used)
// - Return transfers ownership out: return x; (caller owns)

extern from rt::stdlib use { stringLen, stringSlice, stringCharCodeAt };
extern from rt::vec use { vec_new, vec_len, vec_get, vec_push };

from analyzer::typestrings use {
  ty_i8,
  ty_i16,
  ty_i32,
  ty_i64,
  ty_u8,
  ty_u16,
  ty_u32,
  ty_u64,
  ty_f32,
  ty_f64,
  ty_bool,
  ty_char,
  ty_void,
  ty_never,
  ty_string,
  ty_unknown,
  ty_int_lit,
  ty_float_lit,
  ty_parse_array,
  ty_parse_app,
  ty_is_fn_type,
  normalize_ty_ann,
  ty_skip_ws
};

// Check if a type is a primitive (always Copy)
out fn is_primitive_type(t: String) : Bool => {
  let tt = normalize_ty_ann(t);
  if (tt == ty_i8()) { yield true; }
  if (tt == ty_i16()) { yield true; }
  if (tt == ty_i32()) { yield true; }
  if (tt == ty_i64()) { yield true; }
  if (tt == ty_u8()) { yield true; }
  if (tt == ty_u16()) { yield true; }
  if (tt == ty_u32()) { yield true; }
  if (tt == ty_u64()) { yield true; }
  if (tt == ty_f32()) { yield true; }
  if (tt == ty_f64()) { yield true; }
  if (tt == ty_bool()) { yield true; }
  if (tt == ty_char()) { yield true; }
  if (tt == ty_void()) { yield true; }
  if (tt == ty_never()) { yield true; }
  if (tt == ty_int_lit()) { yield true; }
  if (tt == ty_float_lit()) { yield true; }
  // TODO: String should be Move type once we have .copy() or borrowing
  // For now, treat as Copy to bootstrap the compiler
  if (tt == ty_string()) { yield true; }
  false
}

// Check if a type is Copy given struct definitions
// Structs: vector of (name, fieldTypes)
out fn is_copy_type(t: String, structDefs: Vec<StructDef>) : Bool => {
  let tt = normalize_ty_ann(t);
  
  // Primitives are always Copy (includes String for now)
  if (is_primitive_type(tt)) { yield true; }
  
  // Unknown types: treat as Copy for now to allow bootstrapping
  // TODO: Once we have better type inference for imports, treat Unknown as Move
  if (tt == ty_unknown() || tt == "") { yield true; }
  
  // Function types are NOT Copy (closures capture, etc.)
  if (ty_is_fn_type(tt)) { yield false; }
  
  // Arrays: Copy if element type is Copy
  let arr = ty_parse_array(tt);
  if (arr.ok) {
    yield is_copy_type(arr.elem, structDefs);
  }
  
  // Tuple types: Copy if all elements are Copy
  // Tuples look like (T1, T2, ...)
  if (stringLen(tt) > 0 && stringCharCodeAt(tt, 0) == 40) { // '('
    // For now, treat tuples as Move (conservative)
    // TODO: Parse tuple elements and check each
    yield false;
  }
  
  // Generic type applications: check the base type
  let app = ty_parse_app(tt);
  if (app.ok) {
    // Option<T>, Vec<T>, etc. - treat as Copy for now during bootstrap
    // TODO: Properly check if the generic type has Copy semantics
    yield true;
  }
  
  // Struct types: look up definition and check all fields
  let mut i = 0;
  while (i < vec_len(structDefs)) {
    let s = vec_get(structDefs, i);
    if (s.name == tt) {
      // Check all field types
      let mut fi = 0;
      while (fi < vec_len(s.fieldTyAnns)) {
        let fieldTy = vec_get(s.fieldTyAnns, fi);
        if (!is_copy_type(fieldTy, structDefs)) {
          yield false;
        }
        fi = fi + 1;
      }
      // All fields are Copy, so struct is Copy
      yield true;
    }
    i = i + 1;
  }
  
  // Unknown struct name - treat as Move for safety
  false
}

// Check if a type is Move (opposite of Copy)
out fn is_move_type(t: String, structDefs: Vec<StructDef>) : Bool => {
  !is_copy_type(t, structDefs)
}
