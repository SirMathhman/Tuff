// Validation checks used by the analyzer (calls, struct literals, boolean conditions, operator operands).

extern from rt::vec use { vec_new, vec_len, vec_get };

from util::diagnostics use { error_at };
from ast use { span_start };

from analyzer::infer_basic use { infer_expr_type };
from analyzer::typecheck use { require_type_compatible };
from analyzer::subst use { subst_bind, ty_apply_subst };

from analyzer::env use {
  struct_name_of_expr,
  has_struct_def,
  find_struct_def,
  has_fn_sig,
  find_fn_sig
};

from analyzer::typestrings use {
  normalize_ty_ann,
  type_is_unknown,
  type_is_int_like,
  type_is_float_like,
  ty_is_fn_type,
  ty_fn_param_tys,
  ty_fn_type_params,
  ty_is_type_var,
  ty_i32,
  ty_u32,
  ty_char,
  ty_int_lit,
  ty_f32,
  ty_f64,
  ty_float_lit,
  ty_string
};

out fn check_cond_is_bool(src: String, structs: Vec<StructDef>, fns: Vec<FnSig>, scopes: Vec<Vec<Binding>>, depth: I32, cond: Expr) : Void => {
  let t = infer_expr_type(src, structs, fns, scopes, depth, cond);
  if (t == ty_i32() || t == ty_u32() || t == ty_char() || t == ty_int_lit()) { error_at(src, span_start(cond.span), "condition must be Bool (got I32)"); }
  if (t == ty_f32() || t == ty_f64() || t == ty_float_lit()) { error_at(src, span_start(cond.span), "condition must be Bool (got F64)"); }
  if (t == ty_string()) { error_at(src, span_start(cond.span), "condition must be Bool (got String)"); }
}

out fn check_binary_operand_types(src: String, structs: Vec<StructDef>, fns: Vec<FnSig>, scopes: Vec<Vec<Binding>>, depth: I32, e: Expr) : Void => {
  // Minimal operand validation to catch obviously-wrong code while keeping
  // the bootstrap analyzer incremental.
  if (e.tag != "EBinary") { yield; }

  let lt = infer_expr_type(src, structs, fns, scopes, depth, e.left);
  let rt = infer_expr_type(src, structs, fns, scopes, depth, e.right);

  // If either side is Unknown, do not enforce (avoid false positives).
  if (type_is_unknown(lt) || type_is_unknown(rt)) { yield; }

  // Arithmetic operators: require int-like operands, except `+` allows String.
  if (e.op.tag == "OpAdd") {
    if (lt == ty_string() || rt == ty_string()) { yield; }
    if (!((type_is_int_like(lt) && type_is_int_like(rt)) || (type_is_float_like(lt) && type_is_float_like(rt)))) {
      error_at(src, span_start(e.span), "invalid operands to '+': expected numbers or strings");
    }
    yield;
  }

  if (e.op.tag == "OpSub" || e.op.tag == "OpMul" || e.op.tag == "OpDiv") {
    if (!((type_is_int_like(lt) && type_is_int_like(rt)) || (type_is_float_like(lt) && type_is_float_like(rt)))) {
      error_at(src, span_start(e.span), "invalid operands to arithmetic operator");
    }
    yield;
  }

  // Comparison operators: require both operands to be numeric (int or float), not strings.
  if (e.op.tag == "OpLt" || e.op.tag == "OpLe" || e.op.tag == "OpGt" || e.op.tag == "OpGe") {
    if (!((type_is_int_like(lt) && type_is_int_like(rt)) || (type_is_float_like(lt) && type_is_float_like(rt)))) {
      error_at(src, span_start(e.span), "invalid operands to comparison operator: expected numbers");
    }
    yield;
  }
}

out fn check_struct_lit_types(src: String, structs: Vec<StructDef>, fns: Vec<FnSig>, scopes: Vec<Vec<Binding>>, depth: I32, e: Expr) : Void => {
  let structName = struct_name_of_expr(src, e.nameExpr);
  if (!has_struct_def(structs, structName)) {
    error_at(src, span_start(e.span), "unknown struct: " + structName);
    yield;
  }
  let sd = find_struct_def(structs, structName);
  if (!(vec_len(sd.fields) == vec_len(e.values))) {
    error_at(src, span_start(e.span), "wrong number of values in struct literal for " + structName);
  }

  // If we have field type annotations, validate positional values against them.
  let mut i = 0;
  while (i < vec_len(e.values) && i < vec_len(sd.fieldTyAnns)) {
    let expected = vec_get(sd.fieldTyAnns, i);
    if (expected != "") {
      let actual = infer_expr_type(src, structs, fns, scopes, depth, vec_get(e.values, i));
      require_type_compatible(src, span_start(e.span), "struct " + structName + " field " + vec_get(sd.fields, i), structs, expected, actual);
    }
    i = i + 1;
  }
}

out fn check_call_types(src: String, structs: Vec<StructDef>, fns: Vec<FnSig>, scopes: Vec<Vec<Binding>>, depth: I32, e: Expr) : Void => {
  if (e.callee.tag == "ELambda") {
    if (!(vec_len(e.args) == vec_len(e.callee.params))) {
      error_at(src, span_start(e.span), "wrong number of args in lambda call");
    }

    let subst = vec_new();
    if (vec_len(e.callee.typeParams) > 0) {
      if (vec_len(e.typeArgs) > 0) {
        if (!(vec_len(e.typeArgs) == vec_len(e.callee.typeParams))) {
          error_at(src, span_start(e.span), "wrong number of type args in lambda call");
        }
        let mut ti = 0;
        while (ti < vec_len(e.callee.typeParams)) {
          subst_bind(subst, vec_get(e.callee.typeParams, ti), normalize_ty_ann(vec_get(e.typeArgs, ti)));
          ti = ti + 1;
        }
      } else {
        // Inference: bind T from actual arg types when expected is exactly a type var.
        let mut ai = 0;
        while (ai < vec_len(e.args) && ai < vec_len(e.callee.paramTyAnns)) {
          let expected = vec_get(e.callee.paramTyAnns, ai);
          if (expected != "" && ty_is_type_var(e.callee.typeParams, normalize_ty_ann(expected))) {
            let actual = infer_expr_type(src, structs, fns, scopes, depth, vec_get(e.args, ai));
            subst_bind(subst, normalize_ty_ann(expected), normalize_ty_ann(actual));
          }
          ai = ai + 1;
        }
      }
    } else {
      if (vec_len(e.typeArgs) > 0) {
        error_at(src, span_start(e.span), "cannot supply type args to non-generic lambda");
      }
    }

    let mut i = 0;
    while (i < vec_len(e.args) && i < vec_len(e.callee.paramTyAnns)) {
      let expected = vec_get(e.callee.paramTyAnns, i);
      if (expected != "") {
        let expected1 = if (vec_len(e.callee.typeParams) > 0) ty_apply_subst(e.callee.typeParams, subst, expected) else normalize_ty_ann(expected);
        let actual = infer_expr_type(src, structs, fns, scopes, depth, vec_get(e.args, i));
        require_type_compatible(src, span_start(e.span), "lambda arg " + ("" + (i + 1)), structs, expected1, actual);
      }
      i = i + 1;
    }
    yield;
  }

  // Calling through a function-typed value (incl. method-field values).
  let ct = infer_expr_type(src, structs, fns, scopes, depth, e.callee);
  if (ty_is_fn_type(ct)) {
    let paramTys = ty_fn_param_tys(ct);
    if (!(vec_len(e.args) == vec_len(paramTys))) {
      error_at(src, span_start(e.span), "wrong number of args in call");
    }

    let tps = ty_fn_type_params(ct);
    let subst = vec_new();
    if (vec_len(tps) > 0) {
      if (vec_len(e.typeArgs) > 0) {
        if (!(vec_len(e.typeArgs) == vec_len(tps))) {
          error_at(src, span_start(e.span), "wrong number of type args in call");
        }
        let mut ti = 0;
        while (ti < vec_len(tps)) {
          subst_bind(subst, vec_get(tps, ti), normalize_ty_ann(vec_get(e.typeArgs, ti)));
          ti = ti + 1;
        }
      } else {
        // Inference: bind T from actual arg types when expected is exactly a type var.
        let mut ai = 0;
        while (ai < vec_len(e.args) && ai < vec_len(paramTys)) {
          let expected = vec_get(paramTys, ai);
          if (expected != "" && ty_is_type_var(tps, normalize_ty_ann(expected))) {
            let actual = infer_expr_type(src, structs, fns, scopes, depth, vec_get(e.args, ai));
            subst_bind(subst, normalize_ty_ann(expected), normalize_ty_ann(actual));
          }
          ai = ai + 1;
        }
      }
    } else {
      if (vec_len(e.typeArgs) > 0) {
        error_at(src, span_start(e.span), "cannot supply type args to non-generic function");
      }
    }

    let mut i = 0;
    while (i < vec_len(e.args) && i < vec_len(paramTys)) {
      let expected0 = vec_get(paramTys, i);
      if (!(type_is_unknown(expected0))) {
        let expected = if (vec_len(tps) > 0) ty_apply_subst(tps, subst, expected0) else normalize_ty_ann(expected0);
        let actual = infer_expr_type(src, structs, fns, scopes, depth, vec_get(e.args, i));
        require_type_compatible(src, span_start(e.span), "arg " + ("" + (i + 1)), structs, expected, actual);
      }
      i = i + 1;
    }
    yield;
  }

  if (e.callee.tag != "EIdent") { yield; }
  let name = e.callee.name;
  if (!has_fn_sig(fns, name)) { yield; }
  let sig = find_fn_sig(fns, name);

  if (!(vec_len(e.args) == vec_len(sig.params))) {
    error_at(src, span_start(e.span), "wrong number of args in call to " + name);
  }

  // Type-check args when signature annotations are present.
  // For generic functions, substitute type vars using explicit type args or inference.
  let subst = vec_new();
  if (vec_len(sig.typeParams) > 0) {
    if (vec_len(e.typeArgs) > 0) {
      if (!(vec_len(e.typeArgs) == vec_len(sig.typeParams))) {
        error_at(src, span_start(e.span), "wrong number of type args in call to " + name);
      }
      let mut ti = 0;
      while (ti < vec_len(sig.typeParams)) {
        subst_bind(subst, vec_get(sig.typeParams, ti), normalize_ty_ann(vec_get(e.typeArgs, ti)));
        ti = ti + 1;
      }
    } else {
      // Inference: bind T from actual arg types when expected is exactly a type var.
      let mut ai = 0;
      while (ai < vec_len(e.args) && ai < vec_len(sig.paramTyAnns)) {
        let expected = vec_get(sig.paramTyAnns, ai);
        if (expected != "" && ty_is_type_var(sig.typeParams, normalize_ty_ann(expected))) {
          let actual = infer_expr_type(src, structs, fns, scopes, depth, vec_get(e.args, ai));
          subst_bind(subst, normalize_ty_ann(expected), normalize_ty_ann(actual));
        }
        ai = ai + 1;
      }
    }
  } else {
    if (vec_len(e.typeArgs) > 0) {
      error_at(src, span_start(e.span), "cannot supply type args to non-generic function: " + name);
    }
  }

  let mut i = 0;
  while (i < vec_len(e.args) && i < vec_len(sig.paramTyAnns)) {
    let expected0 = vec_get(sig.paramTyAnns, i);
    if (expected0 != "") {
      let expected = if (vec_len(sig.typeParams) > 0) ty_apply_subst(sig.typeParams, subst, expected0) else normalize_ty_ann(expected0);
      let actual = infer_expr_type(src, structs, fns, scopes, depth, vec_get(e.args, i));
      require_type_compatible(src, span_start(e.span), "arg " + ("" + (i + 1)) + " to " + name, structs, expected, actual);
    }
    i = i + 1;
  }
}
