// Fluff (linting) helpers used by the analyzer.

extern from rt::stdlib use { stringLen, stringCharCodeAt };
extern from rt::vec use { vec_new, vec_len, vec_push, vec_get };

from util::diagnostics use { error_at, warn_at };

// ------------------------------------------------------------
// Settings
//
// Severity levels:
//   0 = off
//   1 = warning
//   2 = error
// ------------------------------------------------------------

let mut __fluff_unused_locals = 0;
let mut __fluff_unused_params = 0;
let mut __fluff_complexity = 0;
let mut __fluff_complexity_threshold = 15;
let mut __fluff_max_file_lines = 0;
let mut __fluff_max_file_lines_threshold = 500;

out fn fluff_set_options(unusedLocalsSeverity: I32, unusedParamsSeverity: I32) : Void => {
  __fluff_unused_locals = unusedLocalsSeverity;
  __fluff_unused_params = unusedParamsSeverity;
}

out fn fluff_set_complexity_options(complexitySeverity: I32, threshold: I32) : Void => {
  __fluff_complexity = complexitySeverity;
  __fluff_complexity_threshold = if (threshold > 0) threshold else 15;
}

out fn fluff_set_file_size_options(severity: I32, threshold: I32) : Void => {
  __fluff_max_file_lines = severity;
  __fluff_max_file_lines_threshold = if (threshold > 0) threshold else 500;
}

fn fluff_emit_at(src: String, pos: I32, severity: I32, msg: String) : Void => {
  if (severity == 1) { warn_at(src, pos, msg); yield; }
  if (severity == 2) { error_at(src, pos, msg); yield; }
  // severity 0 (off) or unknown => ignore
}

fn count_lines(src: String) : I32 => {
  if (stringLen(src) == 0) { yield 0; }
  let mut count = 0;
  let mut i = 0;
  while (i < stringLen(src)) {
    if (stringCharCodeAt(src, i) == 10) { count = count + 1; }
    i = i + 1;
  }
  // If the file doesn't end with a newline, add 1 for the last line.
  // If it ends with a newline, the count of newlines IS the line count.
  if (stringCharCodeAt(src, stringLen(src) - 1) != 10) { count = count + 1; }
  count
}

out fn fluff_check_file_size(src: String) : Void => {
  if (__fluff_max_file_lines == 0) { yield; }
  let lineCount = count_lines(src);
  if (lineCount > __fluff_max_file_lines_threshold) {
    let msg = "file has " + lineCount + " lines, exceeds limit of " + __fluff_max_file_lines_threshold;
    fluff_emit_at(src, 0, __fluff_max_file_lines, msg);
  }
}

fn binding_name_is_intentionally_unused(name: String) : Bool => {
  // Convention: leading underscore indicates intentionally-unused.
  if (stringLen(name) > 0 && stringCharCodeAt(name, 0) == 95) { yield true; }
  false
}

out fn fluff_warn_unused_locals_in_scope(src: String, scopes: Vec<Vec<Binding>>, depth: I32) : Void => {
  let severity = __fluff_unused_locals;
  if (severity == 0) { yield; }
  let scope = vec_get(scopes, depth - 1);
  let mut bi = 0;
  while (bi < vec_len(scope)) {
    let b = vec_get(scope, bi);
    if (!b.read && !b.isParam && !binding_name_is_intentionally_unused(b.name)) {
      fluff_emit_at(src, b.declPos, severity, "unused local: " + b.name);
    }
    bi = bi + 1;
  }
}

out fn fluff_warn_unused_params_in_scope(src: String, scopes: Vec<Vec<Binding>>, depth: I32) : Void => {
  let severity = __fluff_unused_params;
  if (severity == 0) { yield; }
  let scope = vec_get(scopes, depth - 1);
  let mut bi = 0;
  while (bi < vec_len(scope)) {
    let b = vec_get(scope, bi);
    if (!b.read && b.isParam && !binding_name_is_intentionally_unused(b.name)) {
      fluff_emit_at(src, b.declPos, severity, "unused parameter: " + b.name);
    }
    bi = bi + 1;
  }
}

// ------------------------------------------------------------
// Cyclomatic Complexity Calculation
//
// CC = 1 (base)
//    + 1 per if/while/loop branch
//    + (match arms - 1) per match expression
//    + 1 per && or || operator (short-circuit decision points)
//
// Inner functions/lambdas are counted independently (their complexity
// does not add to the outer function's complexity).
// ------------------------------------------------------------

fn cc_expr(e: Expr) : I32 => {
  if (e.tag == "EUndefined") { yield 0; }
  if (e.tag == "EInt") { yield 0; }
  if (e.tag == "EFloat") { yield 0; }
  if (e.tag == "EBool") { yield 0; }
  if (e.tag == "EString") { yield 0; }
  if (e.tag == "EIdent") { yield 0; }
  if (e.tag == "EPath") { yield 0; }

  if (e.tag == "ELambda") {
    // Inner lambda: counted independently, so return 0 for this expression
    yield 0;
  }

  if (e.tag == "EStructLit") {
    let mut cc = 0;
    let mut i = 0;
    while (i < vec_len(e.values)) {
      cc = cc + cc_expr(vec_get(e.values, i));
      i = i + 1;
    }
    yield cc;
  }

  if (e.tag == "EUnary") {
    yield cc_expr(e.expr);
  }

  if (e.tag == "EBinary") {
    let mut cc = cc_expr(e.left) + cc_expr(e.right);
    // && and || are decision points
    if (e.op.tag == "OpAnd" || e.op.tag == "OpOr") {
      cc = cc + 1;
    }
    yield cc;
  }

  if (e.tag == "ECall") {
    let mut cc = cc_expr(e.callee);
    let mut i = 0;
    while (i < vec_len(e.args)) {
      cc = cc + cc_expr(vec_get(e.args, i));
      i = i + 1;
    }
    yield cc;
  }

  if (e.tag == "EIf") {
    // +1 for the if branch itself
    let cc = 1 + cc_expr(e.cond) + cc_expr(e.thenExpr) + cc_expr(e.elseExpr);
    yield cc;
  }

  if (e.tag == "EBlock") {
    let mut cc = cc_stmts(e.body);
    cc = cc + cc_expr(e.tail);
    yield cc;
  }

  if (e.tag == "EVecLit") {
    let mut cc = 0;
    let mut i = 0;
    while (i < vec_len(e.items)) {
      cc = cc + cc_expr(vec_get(e.items, i));
      i = i + 1;
    }
    yield cc;
  }

  if (e.tag == "ETupleLit") {
    let mut cc = 0;
    let mut i = 0;
    while (i < vec_len(e.items)) {
      cc = cc + cc_expr(vec_get(e.items, i));
      i = i + 1;
    }
    yield cc;
  }

  if (e.tag == "EIndex") {
    yield cc_expr(e.base) + cc_expr(e.index);
  }

  if (e.tag == "ETupleIndex") {
    yield cc_expr(e.base);
  }

  if (e.tag == "EField") {
    yield cc_expr(e.base);
  }

  if (e.tag == "EMatch") {
    let mut cc = cc_expr(e.scrut);
    let armCount = vec_len(e.arms);
    // (arms - 1) branches (first arm is the base path)
    if (armCount > 1) { cc = cc + armCount - 1; }
    let mut i = 0;
    while (i < armCount) {
      let arm = vec_get(e.arms, i);
      cc = cc + cc_expr(arm.expr);
      i = i + 1;
    }
    yield cc;
  }

  // Unknown tag: return 0
  0
}

fn cc_stmt(s: Stmt) : I32 => {
  if (s.tag == "SLet") {
    yield cc_expr(s.init);
  }

  if (s.tag == "SAssign") {
    yield cc_expr(s.value);
  }

  if (s.tag == "SExpr") {
    yield cc_expr(s.expr);
  }

  if (s.tag == "SYield") {
    yield cc_expr(s.expr);
  }

  if (s.tag == "SWhile") {
    // +1 for the while loop itself
    let cc = 1 + cc_expr(s.cond) + cc_stmts(s.body);
    yield cc;
  }

  if (s.tag == "SIf") {
    // +1 for the if branch
    let mut cc = 1 + cc_expr(s.cond) + cc_stmts(s.thenBody);
    if (s.hasElse) {
      cc = cc + cc_stmts(s.elseBody);
    }
    yield cc;
  }

  if (s.tag == "SIndexAssign") {
    yield cc_expr(s.base) + cc_expr(s.index) + cc_expr(s.value);
  }

  if (s.tag == "SFieldAssign") {
    yield cc_expr(s.base) + cc_expr(s.value);
  }

  // Unknown tag: return 0
  0
}

fn cc_stmts(stmts: Vec<Stmt>) : I32 => {
  let mut cc = 0;
  let mut i = 0;
  while (i < vec_len(stmts)) {
    cc = cc + cc_stmt(vec_get(stmts, i));
    i = i + 1;
  }
  cc
}

out fn fluff_check_fn_complexity(src: String, pos: I32, fnName: String, body: Vec<Stmt>, tail: Expr) : Void => {
  let severity = __fluff_complexity;
  if (severity == 0) { yield; }

  let cc = 1 + cc_stmts(body) + cc_expr(tail);
  let threshold = __fluff_complexity_threshold;
  if (cc > threshold) {
    let msg = "cyclomatic complexity of " + fnName + " is " + ("" + cc) + " (threshold: " + ("" + threshold) + ")";
    fluff_emit_at(src, pos, severity, msg);
  }
}

out fn fluff_check_lambda_complexity(src: String, pos: I32, name: String, body: Expr) : Void => {
  let severity = __fluff_complexity;
  if (severity == 0) { yield; }

  let cc = 1 + cc_expr(body);
  let threshold = __fluff_complexity_threshold;
  if (cc > threshold) {
    let msg = "cyclomatic complexity of " + name + " is " + ("" + cc) + " (threshold: " + ("" + threshold) + ")";
    fluff_emit_at(src, pos, severity, msg);
  }
}
