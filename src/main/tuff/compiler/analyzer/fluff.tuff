// Fluff (linting) helpers used by the analyzer.

extern from rt::stdlib use { stringLen, stringCharCodeAt };
extern from rt::vec use { vec_new, vec_len, vec_push, vec_get };

from util::diagnostics use { error_at, warn_at };

// ------------------------------------------------------------
// Settings
//
// Severity levels:
//   0 = off
//   1 = warning
//   2 = error
// ------------------------------------------------------------

let mut __fluff_unused_locals = 0;
let mut __fluff_unused_params = 0;
let mut __fluff_complexity = 0;
let mut __fluff_complexity_threshold = 15;
let mut __fluff_max_file_lines = 0;
let mut __fluff_max_file_lines_threshold = 500;
let mut __fluff_max_params = 0;
let mut __fluff_max_params_threshold = 3;
let mut __fluff_single_char_identifiers = 0;
let mut __fluff_missing_docs = 0;

out fn fluff_set_options(unusedLocalsSeverity: I32, unusedParamsSeverity: I32) : Void => {
  __fluff_unused_locals = unusedLocalsSeverity;
  __fluff_unused_params = unusedParamsSeverity;
}

out fn fluff_set_complexity_options(complexitySeverity: I32, threshold: I32) : Void => {
  __fluff_complexity = complexitySeverity;
  __fluff_complexity_threshold = if (threshold > 0) threshold else 15;
}

out fn fluff_set_file_size_options(severity: I32, threshold: I32) : Void => {
  __fluff_max_file_lines = severity;
  __fluff_max_file_lines_threshold = if (threshold > 0) threshold else 500;
}

out fn fluff_set_max_params_options(severity: I32, threshold: I32) : Void => {
  __fluff_max_params = severity;
  __fluff_max_params_threshold = if (threshold > 0) threshold else 3;
}

out fn fluff_set_single_char_identifiers_options(severity: I32) : Void => {
  __fluff_single_char_identifiers = severity;
}

out fn fluff_set_missing_docs_options(severity: I32) : Void => {
  __fluff_missing_docs = severity;
}

fn fluff_emit_at(src: String, pos: I32, severity: I32, msg: String) : Void => {
  if (severity == 1) { warn_at(src, pos, msg); yield; }
  if (severity == 2) { error_at(src, pos, msg); yield; }
  // severity 0 (off) or unknown => ignore
}

fn count_lines(src: String) : I32 => {
  if (stringLen(src) == 0) { yield 0; }
  let mut count = 0;
  let mut i = 0;
  while (i < stringLen(src)) {
    if (stringCharCodeAt(src, i) == 10) { count = count + 1; }
    i = i + 1;
  }
  // If the file doesn't end with a newline, add 1 for the last line.
  // If it ends with a newline, the count of newlines IS the line count.
  if (stringCharCodeAt(src, stringLen(src) - 1) != 10) { count = count + 1; }
  count
}

out fn fluff_check_file_size(src: String) : Void => {
  if (__fluff_max_file_lines == 0) { yield; }
  let lineCount = count_lines(src);
  if (lineCount > __fluff_max_file_lines_threshold) {
    let msg = "file has " + lineCount + " lines, exceeds limit of " + __fluff_max_file_lines_threshold;
    fluff_emit_at(src, 0, __fluff_max_file_lines, msg);
  }
}

fn binding_name_is_intentionally_unused(name: String) : Bool => {
  // Convention: leading underscore indicates intentionally-unused.
  if (stringLen(name) > 0 && stringCharCodeAt(name, 0) == 95) { yield true; }
  false
}

out fn fluff_warn_unused_locals_in_scope(src: String, scopes: Vec<Vec<Binding>>, depth: I32) : Void => {
  let severity = __fluff_unused_locals;
  if (severity == 0) { yield; }
  let scope = vec_get(scopes, depth - 1);
  let mut bi = 0;
  while (bi < vec_len(scope)) {
    let b = vec_get(scope, bi);
    if (!b.read && !b.isParam && !binding_name_is_intentionally_unused(b.name)) {
      fluff_emit_at(src, b.declPos, severity, "unused local: " + b.name);
    }
    bi = bi + 1;
  }
}

out fn fluff_warn_unused_params_in_scope(src: String, scopes: Vec<Vec<Binding>>, depth: I32) : Void => {
  let severity = __fluff_unused_params;
  if (severity == 0) { yield; }
  let scope = vec_get(scopes, depth - 1);
  let mut bi = 0;
  while (bi < vec_len(scope)) {
    let b = vec_get(scope, bi);
    if (!b.read && b.isParam && !binding_name_is_intentionally_unused(b.name)) {
      fluff_emit_at(src, b.declPos, severity, "unused parameter: " + b.name);
    }
    bi = bi + 1;
  }
}

// ------------------------------------------------------------
// Public wrapper API
//
// Other analyzer modules import these names (without the `fluff_` prefix).
// Keep the `fluff_*` exports as the canonical implementation.
// ------------------------------------------------------------

out fn warn_unused_locals_in_scope(src: String, scopes: Vec<Vec<Binding>>, depth: I32) : Void =>
  fluff_warn_unused_locals_in_scope(src, scopes, depth)

out fn warn_unused_params_in_scope(src: String, scopes: Vec<Vec<Binding>>, depth: I32) : Void =>
  fluff_warn_unused_params_in_scope(src, scopes, depth)

out fn check_fn_complexity(src: String, pos: I32, fnName: String, body: Vec<Stmt>, tail: Expr) : Void =>
  fluff_check_fn_complexity(src, pos, fnName, body, tail)

out fn check_lambda_complexity(src: String, pos: I32, name: String, body: Expr) : Void =>
  fluff_check_lambda_complexity(src, pos, name, body)

out fn check_fn_max_params(src: String, pos: I32, fnName: String, paramCount: I32) : Void =>
  fluff_check_fn_max_params(src, pos, fnName, paramCount)

out fn check_single_char_identifier(src: String, pos: I32, name: String, kind: String) : Void =>
  fluff_check_single_char_identifier(src, pos, name, kind)

// ------------------------------------------------------------
// Cyclomatic Complexity Calculation
//
// CC = 1 (base)
//    + 1 per if/while/loop branch
//    + (match arms - 1) per match expression
//    + 1 per && or || operator (short-circuit decision points)
//
// Inner functions/lambdas are counted independently (their complexity
// does not add to the outer function's complexity).
// ------------------------------------------------------------

fn cc_expr(e: Expr) : I32 => {
  if (e is EUndefined) { yield 0; }
  if (e is EInt) { yield 0; }
  if (e is EFloat) { yield 0; }
  if (e is EBool) { yield 0; }
  if (e is EString) { yield 0; }
  if (e is EIdent) { yield 0; }
  if (e is EPath) { yield 0; }

  if (e is ELambda) {
    // Inner lambda: counted independently, so return 0 for this expression
    yield 0;
  }

  if (e is EStructLit) {
    let mut cc = 0;
    let mut i = 0;
    while (i < vec_len(e.values)) {
      cc = cc + cc_expr(vec_get(e.values, i));
      i = i + 1;
    }
    yield cc;
  }

  if (e is EUnary) {
    yield cc_expr(e.expr);
  }

  if (e is EBinary) {
    let mut cc = cc_expr(e.left) + cc_expr(e.right);
    // && and || are decision points
    if (e.op is OpAnd || e.op is OpOr) {
      cc = cc + 1;
    }
    yield cc;
  }

  if (e is ECall) {
    let mut cc = cc_expr(e.callee);
    let mut i = 0;
    while (i < vec_len(e.args)) {
      cc = cc + cc_expr(vec_get(e.args, i));
      i = i + 1;
    }
    yield cc;
  }

  if (e is EIf) {
    // +1 for the if branch itself
    let cc = 1 + cc_expr(e.cond) + cc_expr(e.thenExpr) + cc_expr(e.elseExpr);
    yield cc;
  }

  if (e is EBlock) {
    let mut cc = cc_stmts(e.body);
    cc = cc + cc_expr(e.tail);
    yield cc;
  }

  if (e is EVecLit) {
    let mut cc = 0;
    let mut i = 0;
    while (i < vec_len(e.items)) {
      cc = cc + cc_expr(vec_get(e.items, i));
      i = i + 1;
    }
    yield cc;
  }

  if (e is ETupleLit) {
    let mut cc = 0;
    let mut i = 0;
    while (i < vec_len(e.items)) {
      cc = cc + cc_expr(vec_get(e.items, i));
      i = i + 1;
    }
    yield cc;
  }

  if (e is EIndex) {
    yield cc_expr(e.base) + cc_expr(e.index);
  }

  if (e is ETupleIndex) {
    yield cc_expr(e.base);
  }

  if (e is EField) {
    yield cc_expr(e.base);
  }

  if (e is EMatch) {
    let mut cc = cc_expr(e.scrut);
    let armCount = vec_len(e.arms);
    // (arms - 1) branches (first arm is the base path)
    if (armCount > 1) { cc = cc + armCount - 1; }
    let mut i = 0;
    while (i < armCount) {
      let arm = vec_get(e.arms, i);
      cc = cc + cc_expr(arm.expr);
      i = i + 1;
    }
    yield cc;
  }

  // Unknown tag: return 0
  0
}

fn cc_stmt(s: Stmt) : I32 => {
  if (s is SLet) {
    yield cc_expr(s.init);
  }

  if (s is SAssign) {
    yield cc_expr(s.value);
  }

  if (s is SExpr) {
    yield cc_expr(s.expr);
  }

  if (s is SYield) {
    yield cc_expr(s.expr);
  }

  if (s is SWhile) {
    // +1 for the while loop itself
    let cc = 1 + cc_expr(s.cond) + cc_stmts(s.body);
    yield cc;
  }

  if (s is SIf) {
    // +1 for the if branch
    let mut cc = 1 + cc_expr(s.cond) + cc_stmts(s.thenBody);
    if (s.hasElse) {
      cc = cc + cc_stmts(s.elseBody);
    }
    yield cc;
  }

  if (s is SIndexAssign) {
    yield cc_expr(s.base) + cc_expr(s.index) + cc_expr(s.value);
  }

  if (s is SFieldAssign) {
    yield cc_expr(s.base) + cc_expr(s.value);
  }

  // Unknown tag: return 0
  0
}

fn cc_stmts(stmts: Vec<Stmt>) : I32 => {
  let mut cc = 0;
  let mut i = 0;
  while (i < vec_len(stmts)) {
    cc = cc + cc_stmt(vec_get(stmts, i));
    i = i + 1;
  }
  cc
}

out fn fluff_check_fn_complexity(src: String, pos: I32, fnName: String, body: Vec<Stmt>, tail: Expr) : Void => {
  let severity = __fluff_complexity;
  if (severity == 0) { yield; }

  let cc = 1 + cc_stmts(body) + cc_expr(tail);
  let threshold = __fluff_complexity_threshold;
  if (cc > threshold) {
    let msg = "cyclomatic complexity of " + fnName + " is " + ("" + cc) + " (threshold: " + ("" + threshold) + ")";
    fluff_emit_at(src, pos, severity, msg);
  }
}

out fn fluff_check_lambda_complexity(src: String, pos: I32, name: String, body: Expr) : Void => {
  let severity = __fluff_complexity;
  if (severity == 0) { yield; }

  let cc = 1 + cc_expr(body);
  let threshold = __fluff_complexity_threshold;
  if (cc > threshold) {
    let msg = "cyclomatic complexity of " + name + " is " + ("" + cc) + " (threshold: " + ("" + threshold) + ")";
    fluff_emit_at(src, pos, severity, msg);
  }
}

out fn fluff_check_fn_max_params(src: String, pos: I32, fnName: String, paramCount: I32) : Void => {
  let severity = __fluff_max_params;
  if (severity == 0) { yield; }

  let threshold = __fluff_max_params_threshold;
  if (paramCount > threshold) {
    let msg = "function " + fnName + " has " + ("" + paramCount) + " parameters (threshold: " + ("" + threshold) + ")";
    fluff_emit_at(src, pos, severity, msg);
  }
}

out fn fluff_check_single_char_identifier(src: String, pos: I32, name: String, kind: String) : Void => {
  let severity = __fluff_single_char_identifiers;
  if (severity == 0) { yield; }

  // Ignore intentionally-unused names (leading underscore)
  if (binding_name_is_intentionally_unused(name)) { yield; }

  if (stringLen(name) == 1) {
    let msg = kind + " name '" + name + "' is only a single character; use a more descriptive name";
    fluff_emit_at(src, pos, severity, msg);
  }
}

// ------------------------------------------------------------
// Missing Documentation Check
//
// Warns when exported declarations (functions, structs) lack a
// documentation comment (// or /* */) immediately before them.
// ------------------------------------------------------------

fn is_whitespace_char(ch: I32) : Bool => ch == 32 || ch == 9 || ch == 10 || ch == 13

// Check if there's a comment (line or block) immediately before the declaration.
// Returns true if a doc comment exists, false otherwise.
fn has_doc_comment_before(src: String, pos: I32) : Bool => {
  // Scan backwards from pos to find non-whitespace content.
  // If we find a comment end (newline after //, or */ for block), it's documented.
  if (pos <= 0) { yield false; }

  let mut i = pos - 1;

  // Skip whitespace backwards
  while (i >= 0 && is_whitespace_char(stringCharCodeAt(src, i))) {
    i = i - 1;
  }

  if (i < 0) { yield false; }

  // Check for block comment ending: */
  if (i >= 1) {
    let ch1 = stringCharCodeAt(src, i - 1);
    let ch2 = stringCharCodeAt(src, i);
    if (ch1 == 42 && ch2 == 47) {  // '*' '/'
      yield true;
    }
  }

  // Check for line comment: scan back to find // on this or previous line
  // We need to find a line that starts with // (after optional whitespace)
  let mut lineStart = i;
  while (lineStart > 0 && stringCharCodeAt(src, lineStart - 1) != 10) {
    lineStart = lineStart - 1;
  }

  // Skip leading whitespace on this line
  let mut j = lineStart;
  while (j <= i && is_whitespace_char(stringCharCodeAt(src, j))) {
    j = j + 1;
  }

  // Check if line starts with //
  if (j + 1 <= i) {
    let ch1 = stringCharCodeAt(src, j);
    let ch2 = stringCharCodeAt(src, j + 1);
    if (ch1 == 47 && ch2 == 47) {  // '/' '/'
      yield true;
    }
  }

  false
}

out fn fluff_check_missing_docs(src: String, pos: I32, name: String, kind: String, isExported: Bool) : Void => {
  let severity = __fluff_missing_docs;
  if (severity == 0) { yield; }

  // Only check exported declarations
  if (!isExported) { yield; }

  // Skip main function (entry point doesn't need docs)
  if (name == "main") { yield; }

  if (!has_doc_comment_before(src, pos)) {
    let msg = "missing documentation comment for exported " + kind + " '" + name + "'";
    fluff_emit_at(src, pos, severity, msg);
  }
}
