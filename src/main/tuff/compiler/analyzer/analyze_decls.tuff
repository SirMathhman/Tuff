// Analyzer: per-declaration analysis helpers.
// Split out of analyzer.tuff to keep file sizes under the lint limit.

extern from rt::vec use { vec_new, vec_len, vec_get, vec_push };

from util::diagnostics use { error_at };
from ast use { span_start };

from analyzer::fluff use {
  fluff_warn_unused_locals_in_scope,
  fluff_warn_unused_params_in_scope,
  fluff_check_fn_complexity,
  fluff_check_lambda_complexity,
  fluff_check_fn_max_params,
  fluff_check_single_char_identifier
};

from analyzer::typestrings use {
  ty_unknown,
  ty_void,
  ty_fn_type,
  ty_fn_type_params,
  ty_is_fn_type,
  normalize_ty_ann
};

from analyzer::infer_basic use { infer_expr_type };

from analyzer::scope use {
  scopes_enter,
  declare_local_name
};

from analyzer::typecheck use { require_type_compatible };

from analyzer::analyze_expr_stmt use { analyze_expr, analyze_stmts };

fn warn_unused_locals_in_scope(src: String, scopes: Vec<Vec<Binding>>, depth: I32) : Void =>
  fluff_warn_unused_locals_in_scope(src, scopes, depth)

fn warn_unused_params_in_scope(src: String, scopes: Vec<Vec<Binding>>, depth: I32) : Void =>
  fluff_warn_unused_params_in_scope(src, scopes, depth)

fn check_fn_complexity(src: String, pos: I32, fnName: String, body: Vec<Stmt>, tail: Expr) : Void =>
  fluff_check_fn_complexity(src, pos, fnName, body, tail)

fn check_lambda_complexity(src: String, pos: I32, name: String, body: Expr) : Void =>
  fluff_check_lambda_complexity(src, pos, name, body)

fn check_fn_max_params(src: String, pos: I32, fnName: String, paramCount: I32) : Void =>
  fluff_check_fn_max_params(src, pos, fnName, paramCount)

fn check_single_char_identifier(src: String, pos: I32, name: String, kind: String) : Void =>
  fluff_check_single_char_identifier(src, pos, name, kind)

fn analyze_fn_like_decl(
  src: String,
  structs: Vec<StructDef>,
  unions: Vec<UnionDef>,
  fns: Vec<FnSig>,
  outerScopes: Vec<Vec<Binding>>,
  outerDepth: I32,
  span: Span,
  name: String,
  params: Vec<String>,
  paramTyAnns: Vec<String>,
  retTyAnn: String,
  body: Vec<Stmt>,
  tail: Expr,
  fnKindName: String
) : Void => {
  check_single_char_identifier(src, span_start(span), name, fnKindName);
  
  let depth = scopes_enter(outerScopes, outerDepth);

  let mut pi = 0;
  while (pi < vec_len(params)) {
    let paramName = vec_get(params, pi);
    check_single_char_identifier(src, span_start(span), paramName, "parameter");
    
    let mut pTy = ty_unknown();
    if (pi < vec_len(paramTyAnns)) {
      let ann = vec_get(paramTyAnns, pi);
      if (ann != "") { pTy = normalize_ty_ann(ann); }
    }
    declare_local_name(src, span_start(span), outerScopes, depth, paramName, false, pTy);
    pi = pi + 1;
  }

  let narrowed = vec_new();
  analyze_stmts(src, structs, unions, fns, outerScopes, depth, narrowed, body);
  analyze_expr(src, structs, unions, fns, outerScopes, depth, narrowed, tail);

  // Enforce declared return type (if present) against tail and explicit yields.
  if (retTyAnn != "") {
    let expected = normalize_ty_ann(retTyAnn);

    // tail
    let tailTy = infer_expr_type(src, structs, fns, outerScopes, depth, tail);
    require_type_compatible(src, span_start(span), fnKindName + " " + name + " return", structs, expected, tailTy);

    // yields
    let mut si = 0;
    while (si < vec_len(body)) {
      let st = vec_get(body, si);
      if (st is SYield) {
        let yTy = if (st.expr is EUndefined) ty_void() else infer_expr_type(src, structs, fns, outerScopes, depth, st.expr);
        require_type_compatible(src, span_start(st.span), fnKindName + " " + name + " yield", structs, expected, yTy);
      }
      si = si + 1;
    }
  }

  warn_unused_params_in_scope(src, outerScopes, depth);
  warn_unused_locals_in_scope(src, outerScopes, depth);
  check_fn_complexity(src, span_start(span), name, body, tail);
  check_fn_max_params(src, span_start(span), name, vec_len(params));
}

out fn analyze_fn_decl(src: String, structs: Vec<StructDef>, unions: Vec<UnionDef>, fns: Vec<FnSig>, outerScopes: Vec<Vec<Binding>>, outerDepth: I32, d: DFn) : Void => {
  analyze_fn_like_decl(src, structs, unions, fns, outerScopes, outerDepth, d.span, d.name, d.params, d.paramTyAnns, d.retTyAnn, d.body, d.tail, "function");
}

out fn analyze_class_fn_decl(src: String, structs: Vec<StructDef>, unions: Vec<UnionDef>, fns: Vec<FnSig>, outerScopes: Vec<Vec<Binding>>, outerDepth: I32, d: DClassFn) : Void => {
  analyze_fn_like_decl(src, structs, unions, fns, outerScopes, outerDepth, d.span, d.name, d.params, d.paramTyAnns, d.retTyAnn, d.body, d.tail, "class fn");
}

