// Narrowing-aware inference helpers (union tag tests, payload access).

extern from rt::stdlib use { stringLen, stringSlice };
extern from rt::vec use { vec_new, vec_len, vec_get };

from util::diagnostics use { error_at };
from ast use { span_start };

from analyzer::typestrings use {
  ty_unknown,
  normalize_ty_ann,
  ty_parse_app,
  ty_skip_ws,
  type_is_unknown
};

from analyzer::infer_basic use { infer_expr_type };
from analyzer::env use {
  has_union_def,
  find_union_def,
  union_has_variant,
  union_variant_payload_ty_anns
};
from analyzer::scope use { infer_lookup_ty };
from analyzer::narrowing use { narrow_lookup };
from analyzer::subst use { subst_bind, ty_apply_subst };

out fn infer_expr_type_with_narrowing(src: String, structs: Vec<StructDef>, unions: Vec<UnionDef>, fns: Vec<FnSig>, scopes: Vec<Vec<Binding>>, depth: I32, narrowed: Vec<NarrowedTag>, e: Expr) : String => {
  // Minimal: improve typing for union payload `.value` under narrowing.
  if (e is EField && e.field == "value" && e.base is EIdent) {
    let t = infer_union_payload_type_from_narrowing(src, unions, scopes, depth, narrowed, e.base.name);
    if (!type_is_unknown(t)) { yield t; }
  }
  infer_expr_type(src, structs, fns, scopes, depth, e)
}

class fn ParsedTagEq(ok: Bool, name: String, variant: String) => {}

out fn parse_tag_eq(cond: Expr) : ParsedTagEq => {
  // Recognize: <ident>.tag == "Variant" (either side).
  if (cond.tag != "EBinary") { yield ParsedTagEq(false, "", ""); }
  if (cond.op.tag != "OpEq") { yield ParsedTagEq(false, "", ""); }

  // Left: o.tag
  if (cond.left is EField && cond.left.field == "tag" && cond.left.base is EIdent && cond.right is EString) {
    yield ParsedTagEq(true, cond.left.base.name, cond.right.value);
  }
  // Right: o.tag
  if (cond.right is EField && cond.right.field == "tag" && cond.right.base is EIdent && cond.left is EString) {
    yield ParsedTagEq(true, cond.right.base.name, cond.left.value);
  }
  ParsedTagEq(false, "", "")
}

class fn ParsedTagNarrowing(ok: Bool, name: String, thenVariant: String, elseVariant: String) => {}

out fn parse_tag_narrowing(cond: Expr) : ParsedTagNarrowing => {
  // Recognize union tag tests and return which branch (then/else) implies which variant.
  // Handles:
  //   o is Some            => then: Some
  //   !(o is Some)         => else: Some
  //   o.tag != "Some"      => else: Some (legacy support)
  //   !(o.tag != "Some")   => then: Some (legacy support)
  
  // Handle negation: !(x is Type)
  if (cond is EUnary && cond.op is OpNot) {
    let inner = parse_tag_narrowing(cond.expr);
    if (inner.ok) { yield ParsedTagNarrowing(true, inner.name, inner.elseVariant, inner.thenVariant); }
    yield ParsedTagNarrowing(false, "", "", "");
  }

  // Handle EIsType: x is Type
  if (cond is EIsType) {
    if (cond.expr is EIdent) {
      yield ParsedTagNarrowing(true, cond.expr.name, cond.typeToCheck, "");
    }
    yield ParsedTagNarrowing(false, "", "", "");
  }

  // Legacy support for .tag == comparisons (for backward compatibility during transition)
  if (!(cond is EBinary)) { yield ParsedTagNarrowing(false, "", "", ""); }
  if (!(cond.op is OpEq || cond.op is OpNe)) { yield ParsedTagNarrowing(false, "", "", ""); }

  // Left: o.tag
  if (cond.left is EField && cond.left.field == "tag" && cond.left.base is EIdent && cond.right is EString) {
    let v = cond.right.value;
    if (cond.op is OpEq) { yield ParsedTagNarrowing(true, cond.left.base.name, v, ""); }
    yield ParsedTagNarrowing(true, cond.left.base.name, "", v);
  }
  // Right: o.tag
  if (cond.right is EField && cond.right.field == "tag" && cond.right.base is EIdent && cond.left is EString) {
    let v = cond.left.value;
    if (cond.op is OpEq) { yield ParsedTagNarrowing(true, cond.right.base.name, v, ""); }
    yield ParsedTagNarrowing(true, cond.right.base.name, "", v);
  }
  ParsedTagNarrowing(false, "", "", "")
}

out fn validate_union_variant_for_binding(src: String, pos: I32, unions: Vec<UnionDef>, scopes: Vec<Vec<Binding>>, depth: I32, name: String, variant: String) : Void => {
  // Only enforce when the binding is known to be union-typed.
  let bt0 = infer_lookup_ty(scopes, depth, name);
  let bt = normalize_ty_ann(bt0);
  let mut unionName = bt;
  let app = ty_parse_app(bt);
  if (app.ok) {
    unionName = stringSlice(app.callee, ty_skip_ws(app.callee, 0), stringLen(app.callee));
  }
  if (!has_union_def(unions, unionName)) { yield; }
  let u = find_union_def(unions, unionName);
  if (!union_has_variant(u, variant)) {
    error_at(src, pos, "unknown union variant: " + variant + " (for " + unionName + ")");
  }
}

out fn infer_union_payload_type_from_narrowing(src: String, unions: Vec<UnionDef>, scopes: Vec<Vec<Binding>>, depth: I32, narrowed: Vec<NarrowedTag>, name: String) : String => {
  let v = narrow_lookup(narrowed, name);
  if (v == "") { yield ty_unknown(); }

  let bt0 = infer_lookup_ty(scopes, depth, name);
  let bt = normalize_ty_ann(bt0);
  let mut unionName = bt;
  let mut args = vec_new();
  let app = ty_parse_app(bt);
  if (app.ok) {
    unionName = stringSlice(app.callee, ty_skip_ws(app.callee, 0), stringLen(app.callee));
    args = app.args;
  }
  if (!has_union_def(unions, unionName)) { yield ty_unknown(); }
  let u = find_union_def(unions, unionName);
  if (!union_has_variant(u, v)) { yield ty_unknown(); }

  let payloads = union_variant_payload_ty_anns(u, v);
  if (vec_len(payloads) == 1) {
    let payload0 = normalize_ty_ann(vec_get(payloads, 0));
    if (vec_len(u.typeParams) > 0) {
      let subst = vec_new();
      let mut ti = 0;
      while (ti < vec_len(u.typeParams) && ti < vec_len(args)) {
        subst_bind(subst, vec_get(u.typeParams, ti), normalize_ty_ann(vec_get(args, ti)));
        ti = ti + 1;
      }
      yield ty_apply_subst(u.typeParams, subst, payload0);
    }
    yield payload0;
  }

  ty_unknown()
}
