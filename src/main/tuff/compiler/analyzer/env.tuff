// Environment helpers for analyzer (structs, fns, unions).

extern from rt::vec use { vec_new, vec_len, vec_get };

from util::diagnostics use { error_at };
from ast use { span_start };

from analyzer::defs use { mk_struct_def, mk_fn_sig_def, mk_union_def };
from analyzer::typestrings use { ty_unknown, normalize_ty_ann };

out fn this_struct_name(className: String) : String => "__This__" + className

out fn path_dotted(parts: Vec<String>) : String => {
  let mut out = "";
  let mut i = 0;
  while (i < vec_len(parts)) {
    if (i > 0) { out = out + "."; }
    out = out + vec_get(parts, i);
    i = i + 1;
  }
  out
}

out fn struct_name_of_expr(src: String, nameExpr: Expr) : String => {
  if (nameExpr.tag == "EIdent") { yield nameExpr.name; }
  if (nameExpr.tag == "EPath") { yield path_dotted(nameExpr.parts); }
  error_at(src, span_start(nameExpr.span), "struct literal name must be ident or path");
  ""
}

out fn find_struct_def(structs: Vec<StructDef>, name: String) : StructDef => {
  let mut i = 0;
  while (i < vec_len(structs)) {
    let s = vec_get(structs, i);
    if (s.name == name) { yield s; }
    i = i + 1;
  }
  // Return dummy; caller generally uses this only after a check.
  mk_struct_def(name, vec_new(), vec_new())
}

out fn has_struct_def(structs: Vec<StructDef>, name: String) : Bool => {
  let mut i = 0;
  while (i < vec_len(structs)) {
    if (vec_get(structs, i).name == name) { yield true; }
    i = i + 1;
  }
  false
}

fn struct_field_index(s: StructDef, field: String) : I32 => {
  let mut i = 0;
  while (i < vec_len(s.fields)) {
    if (vec_get(s.fields, i) == field) { yield i; }
    i = i + 1;
  }
  -1
}

out fn get_struct_field_type(src: String, pos: I32, structs: Vec<StructDef>, structName: String, field: String) : String => {
  if (!has_struct_def(structs, structName)) {
    error_at(src, pos, "unknown struct: " + structName);
    yield ty_unknown();
  }
  let s = find_struct_def(structs, structName);
  let idx = struct_field_index(s, field);
  if (idx == -1) {
    error_at(src, pos, "unknown field " + field + " on struct " + structName);
    yield ty_unknown();
  }
  if (idx < vec_len(s.fieldTyAnns)) {
    let t = vec_get(s.fieldTyAnns, idx);
    if (t != "") { yield normalize_ty_ann(t); }
  }
  ty_unknown()
}

out fn find_fn_sig(fns: Vec<FnSig>, name: String) : FnSig => {
  let mut i = 0;
  while (i < vec_len(fns)) {
    let s = vec_get(fns, i);
    if (s.name == name) { yield s; }
    i = i + 1;
  }
  mk_fn_sig_def(name, "", vec_new(), vec_new(), vec_new(), "")
}

out fn has_fn_sig(fns: Vec<FnSig>, name: String) : Bool => {
  let mut i = 0;
  while (i < vec_len(fns)) {
    if (vec_get(fns, i).name == name) { yield true; }
    i = i + 1;
  }
  false
}

out fn find_union_def(unions: Vec<UnionDef>, name: String) : UnionDef => {
  let mut i = 0;
  while (i < vec_len(unions)) {
    let u = vec_get(unions, i);
    if (u.name == name) { yield u; }
    i = i + 1;
  }
  mk_union_def(name, vec_new(), vec_new())
}

out fn has_union_def(unions: Vec<UnionDef>, name: String) : Bool => {
  let mut i = 0;
  while (i < vec_len(unions)) {
    if (vec_get(unions, i).name == name) { yield true; }
    i = i + 1;
  }
  false
}

out fn union_has_variant(u: UnionDef, variantName: String) : Bool => {
  let vs = u.variants;
  let mut i = 0;
  while (i < vec_len(vs)) {
    if (vec_get(vs, i).name == variantName) { yield true; }
    i = i + 1;
  }
  false
}

out fn find_union_by_variant(unions: Vec<UnionDef>, variantName: String) : UnionDef => {
  let mut i = 0;
  while (i < vec_len(unions)) {
    let u = vec_get(unions, i);
    if (union_has_variant(u, variantName)) { yield u; }
    i = i + 1;
  }
  mk_union_def("", vec_new(), vec_new())
}

fn union_variant_index(u: UnionDef, variantName: String) : I32 => {
  let vs = u.variants;
  let mut i = 0;
  while (i < vec_len(vs)) {
    if (vec_get(vs, i).name == variantName) { yield i; }
    i = i + 1;
  }
  -1
}

out fn union_variant_has_payload(u: UnionDef, variantName: String) : Bool => {
  let idx = union_variant_index(u, variantName);
  if (idx == -1) { yield false; }
  vec_get(u.variants, idx).hasPayload
}

out fn union_variant_payload_ty_anns(u: UnionDef, variantName: String) : Vec<String> => {
  let idx = union_variant_index(u, variantName);
  if (idx == -1) { yield vec_new(); }
  vec_get(u.variants, idx).payloadTyAnns
}
