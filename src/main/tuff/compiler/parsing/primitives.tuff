// Selfhost compiler: parsing primitives (keywords/idents/numbers/module paths).
// Extracted from tuffc_lib.tuff as part of Phase 2 (mechanical split).

extern from rt::stdlib use {
  stringLen,
  stringSlice,
  stringCharCodeAt,
  stringFromCharCode
};

from util::diagnostics use { panic_at };

from util::lexing use {
  is_digit,
  is_space,
  is_ident_start,
  is_ident_part,
  skip_ws,
  starts_with_at
};

// Tiny record type used to return two values from parsing helpers.
class fn ParsedNumber(value: I32, nextPos: I32) => {}
class fn ParsedIdent(text: String, startPos: I32, nextPos: I32) => {}
class fn ParsedBool(ok: Bool, nextPos: I32) => {}

fn parse_keyword(src: String, i: I32, lit: String) : I32 => {
  let j = skip_ws(src, i);
  if (!starts_with_at(src, j, lit)) {
    let mut end = j + 16;
    if (end > stringLen(src)) { end = stringLen(src); }
    panic_at(src, j, "expected keyword: " + lit + " but got '" + stringSlice(src, j, end) + "'");
  }
  j + stringLen(lit)
}

fn parse_number(src: String, i: I32) : ParsedNumber => {
  let mut j = skip_ws(src, i);
  let mut acc = 0;
  let mut saw = false;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (!is_digit(c)) { break; }
    saw = true;
    acc = acc * 10 + (c - 48);
    j = j + 1;
  }
  if (!saw) {
    panic_at(src, j, "expected number");
  }
  ParsedNumber(acc, j)
}

fn parse_ident(src: String, i: I32) : ParsedIdent => {
  let mut j = skip_ws(src, i);
  if (!(j < stringLen(src))) { panic_at(src, j, "expected identifier"); }
  let c0 = stringCharCodeAt(src, j);
  if (!is_ident_start(c0)) { panic_at(src, j, "expected identifier"); }
  let start = j;
  j = j + 1;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (!is_ident_part(c)) { break; }
    j = j + 1;
  }
  ParsedIdent(stringSlice(src, start, j), start, j)
}

fn parse_module_path(src: String, i: I32) : ParsedIdent => {
  let mut j = skip_ws(src, i);
  let start = j;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (is_space(c) || c == 59) { break; }
    j = j + 1;
  }
  if (start == j) { panic_at(src, j, "expected module path"); }
  ParsedIdent(stringSlice(src, start, j), start, j)
}

fn module_path_to_relpath(p: String) : String => {
  // Convert `a::b::c` to `a/b/c` for filesystem + ESM relative imports.
  let mut out = "";
  let mut i = 0;
  while (i < stringLen(p)) {
    if (i + 1 < stringLen(p) && stringCharCodeAt(p, i) == 58 && stringCharCodeAt(p, i + 1) == 58) {
      out = out + "/";
      i = i + 2;
      continue;
    }
    out = out + stringFromCharCode(stringCharCodeAt(p, i));
    i = i + 1;
  }
  out
}

fn parse_optional_semicolon(src: String, i: I32) : I32 => {
  let j = skip_ws(src, i);
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 59) { yield j + 1; }
  i
}

fn parse_required_semicolon(src: String, i: I32) : I32 => {
  let j = skip_ws(src, i);
  if (!(j < stringLen(src) && stringCharCodeAt(src, j) == 59)) { panic_at(src, j, "expected ';'"); }
  j + 1
}
