// Selfhost compiler: parsing for declarations (extern/from imports, structs, types, fns, modules).
// Extracted from tuffc_lib.tuff as part of Phase 2 (mechanical split).

extern from rt::stdlib use { stringLen, stringSlice, stringCharCodeAt };
extern from rt::vec use { vec_new, vec_len, vec_push, vec_get };

from util::diagnostics use {
  panic_at,
  add_struct_def,
  is_identifier_too_short,
  warn_short_identifier
};

from util::lexing use { is_ident_part, skip_ws, starts_with_at };

from parsing::primitives use {
  ParsedIdent,
  parse_ident,
  parse_keyword,
  parse_module_path,
  module_path_to_relpath,
  parse_optional_semicolon
};

from parsing::types use { ParsedType, parse_type_expr, skip_angle_brackets };

from parsing::expr_stmt use { ParsedMain, ParsedParams, ParsedStmt, parse_expr, parse_main_body, parse_mut_opt };

from parsing::expr_stmt use {
  ParsedMainAst,
  parse_main_body_ast
};

from ast use {
  span,
  decl_extern_from,
  decl_import,
  decl_fn,
  decl_fn_typed,
  decl_class_fn,
  decl_class_fn_typed,
  decl_struct,
  decl_struct_typed,
  decl_type_union,
  type_union_variant,
  type_union_variant_typed,
  decl_module
};

// NOTE: Avoid type aliases in signatures (type aliases are not runtime exports).
class fn ParsedDeclAst(decl, nextPos: I32) => {}
class fn ParsedDeclsAst(decls, nextPos: I32) => {}
class fn ParsedNamesAst(names: Vec<String>, nextPos: I32) => {}
class fn ParsedParamsAst(names: Vec<String>, tyAnns: Vec<String>, nextPos: I32) => {}
class fn ParsedTypeParamsAst(params: Vec<String>, nextPos: I32) => {}

class fn ParsedImports(v0: String, v1: I32) => {}
class fn ParsedFn(v0: String, v1: String, v2: I32) => {}

fn parse_param_list(src: String, i: I32) : ParsedParams => {
  // parses: '(' (ident (',' ident)*)? ')'
  let mut k = parse_keyword(src, i, "(");
  k = skip_ws(src, k);
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
    yield ParsedParams("", k + 1);
  }
  let mut out = "";
  let mut first = true;
  while (true) {
    let id = parse_ident(src, k);
    k = id.nextPos;

    // Optional param type annotation: `name: Type`
    let t0 = skip_ws(src, k);
    if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) { // ':'
      let _ty = parse_type_expr(src, t0 + 1);
      k = _ty.v1;
    }

    if (first) { out = out + id.text; } else { out = out + ", " + id.text; }
    first = false;

    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in param list"); }
    let c = stringCharCodeAt(src, k);
    if (c == 44) { // ','
      k = k + 1;
      continue;
    }
    if (c == 41) { // ')'
      yield ParsedParams(out, k + 1);
    }
    panic_at(src, k, "expected ',' or ')' in param list")
  }
  ParsedParams(out, k)
}

// ------------------------------------------------------------
// AST path (Phase 3)
// ------------------------------------------------------------

fn parse_name_list_ast(src: String, i: I32) : ParsedNamesAst => {
  // parses: '{' (ident (',' ident)*)? '}'
  let mut k = parse_keyword(src, i, "{");
  k = skip_ws(src, k);
  let names = vec_new();
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 125) { // '}'
    yield ParsedNamesAst(names, k + 1);
  }
  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
    if (stringCharCodeAt(src, k) == 125) { yield ParsedNamesAst(names, k + 1); }
    let id = parse_ident(src, k);
    vec_push(names, id.text);
    k = skip_ws(src, id.nextPos);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 44) { k = k + 1; continue; }
    k = skip_ws(src, k);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 125) { yield ParsedNamesAst(names, k + 1); }
    panic_at(src, k, "expected ',' or '}' in name list")
  }
  ParsedNamesAst(names, k)
}

fn parse_type_params_list_ast(src: String, i: I32) : ParsedTypeParamsAst => {
  // parses: '<' (ident (',' ident)*)? '>'
  let mut k = skip_ws(src, i);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 60)) { // '<'
    yield ParsedTypeParamsAst(vec_new(), i);
  }
  k = k + 1;
  k = skip_ws(src, k);
  let params = vec_new();
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 62) { // '>'
    yield ParsedTypeParamsAst(params, k + 1);
  }
  while (true) {
    let id = parse_ident(src, k);
    vec_push(params, id.text);
    k = skip_ws(src, id.nextPos);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '>' in type params"); }
    let ch = stringCharCodeAt(src, k);
    if (ch == 44) { // ','
      k = k + 1;
      k = skip_ws(src, k);
      continue;
    }
    if (ch == 62) { // '>'
      yield ParsedTypeParamsAst(params, k + 1);
    }
    panic_at(src, k, "expected ',' or '>' in type params");
  }
  ParsedTypeParamsAst(params, k)
}

fn parse_param_list_ast(src: String, i: I32) : ParsedParamsAst => {
  // parses: '(' (ident (',' ident)*)? ')'
  let mut k = parse_keyword(src, i, "(");
  k = skip_ws(src, k);
  let names = vec_new();
  let tyAnns = vec_new();
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
    yield ParsedParamsAst(names, tyAnns, k + 1);
  }
  while (true) {
    let id = parse_ident(src, k);
    k = id.nextPos;
    let t0 = skip_ws(src, k);
    if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) {
      let _ty = parse_type_expr(src, t0 + 1);
      vec_push(tyAnns, _ty.v0);
      k = _ty.v1;
    } else {
      vec_push(tyAnns, "");
    }
    vec_push(names, id.text);
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in param list"); }
    let c = stringCharCodeAt(src, k);
    if (c == 44) { k = k + 1; continue; }
    if (c == 41) { yield ParsedParamsAst(names, tyAnns, k + 1); }
    panic_at(src, k, "expected ',' or ')' in param list")
  }
  ParsedParamsAst(names, tyAnns, k)
}

fn parse_extern_decl_ast(src: String, i: I32) : ParsedDeclAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "extern");
  k = parse_keyword(src, k, "from");
  let mod = parse_module_path(src, k);
  k = parse_keyword(src, mod.nextPos, "use");
  let names = parse_name_list_ast(src, k);
  k = parse_optional_semicolon(src, names.nextPos);
  ParsedDeclAst(decl_extern_from(span(start, k), mod.text, names.names), k)
}

fn parse_imports_ast(src: String, i: I32) : ParsedDeclsAst => {
  let mut k = i;
  let decls = vec_new();
  while (true) {
    let j = skip_ws(src, k);
    if (starts_with_at(src, j, "import")) {
      panic_at(src, j, "`import` is not supported. Use `from <module> use { ... };` instead.");
    }
    if (!starts_with_at(src, j, "from")) { break; }

    let start = skip_ws(src, k);
    k = parse_keyword(src, k, "from");
    let mod = parse_module_path(src, k);
    k = parse_keyword(src, mod.nextPos, "use");
    let names = parse_name_list_ast(src, k);
    k = parse_optional_semicolon(src, names.nextPos);
    vec_push(decls, decl_import(span(start, k), mod.text, names.names));
  }
  ParsedDeclsAst(decls, k)
}

fn parse_fn_decl_ast(src: String, i: I32) : ParsedDeclAst => parse_fn_decl_ast2(src, i, false)

fn parse_fn_decl_ast2(src: String, i: I32, exportAll: Bool) : ParsedDeclAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "fn");
  let name = parse_ident(src, k);
  k = name.nextPos;
  if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

  let mut typeParams = vec_new();
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) {
    let tp = parse_type_params_list_ast(src, t0);
    typeParams = tp.params;
    k = tp.nextPos;
  }

  let params = parse_param_list_ast(src, k);
  k = params.nextPos;

  let t1 = skip_ws(src, k);
  let mut retTyAnn = "";
  if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 58) {
    let _rt = parse_type_expr(src, t1 + 1);
    retTyAnn = _rt.v0;
    k = _rt.v1;
  }

  k = parse_keyword(src, k, "=>");
  let body = parse_main_body_ast(src, k);
  k = body.nextPos;

  // If any types were provided, store them; otherwise keep the legacy shape.
  let mut anyParamTy = false;
  let mut pi = 0;
  while (pi < vec_len(params.tyAnns)) {
    if (vec_get(params.tyAnns, pi) != "") { anyParamTy = true; break; }
    pi = pi + 1;
  }
  if (anyParamTy || retTyAnn != "") {
    yield ParsedDeclAst(decl_fn_typed(span(start, k), name.text, typeParams, params.names, params.tyAnns, retTyAnn, body.body, body.tail), k);
  }
  ParsedDeclAst(decl_fn(span(start, k), name.text, params.names, body.body, body.tail), k)
}

fn parse_class_fn_decl_ast2(src: String, i: I32, exportAll: Bool) : ParsedDeclAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "class");
  k = parse_keyword(src, k, "fn");
  let name = parse_ident(src, k);
  k = name.nextPos;
  if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

  let mut typeParams = vec_new();
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) {
    let tp = parse_type_params_list_ast(src, t0);
    typeParams = tp.params;
    k = tp.nextPos;
  }

  let params = parse_param_list_ast(src, k);
  k = params.nextPos;

  let t1 = skip_ws(src, k);
  let mut retTyAnn = "";
  if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 58) {
    let _rt = parse_type_expr(src, t1 + 1);
    retTyAnn = _rt.v0;
    k = _rt.v1;
  }

  k = parse_keyword(src, k, "=>");
  let body = parse_main_body_ast(src, k);
  k = body.nextPos;

  let mut anyParamTy = false;
  let mut pi = 0;
  while (pi < vec_len(params.tyAnns)) {
    if (vec_get(params.tyAnns, pi) != "") { anyParamTy = true; break; }
    pi = pi + 1;
  }
  if (anyParamTy || retTyAnn != "") {
    yield ParsedDeclAst(decl_class_fn_typed(span(start, k), name.text, typeParams, params.names, params.tyAnns, retTyAnn, body.body, body.tail), k);
  }
  ParsedDeclAst(decl_class_fn(span(start, k), name.text, params.names, body.body, body.tail), k)
}

fn parse_struct_decl_ast(src: String, i: I32) : ParsedDeclAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "struct");
  let name = parse_ident(src, k);
  k = name.nextPos;
  if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

  let mut typeParams = vec_new();
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) {
    let tp = parse_type_params_list_ast(src, t0);
    typeParams = tp.params;
    k = tp.nextPos;
  }

  k = parse_keyword(src, k, "{");
  let fields = vec_new();
  let fieldTyAnns = vec_new();
  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
    if (stringCharCodeAt(src, k) == 125) { k = k + 1; break; }
    let field = parse_ident(src, k);
    k = parse_keyword(src, field.nextPos, ":");
    let _ty = parse_type_expr(src, k);
    k = _ty.v1;
    vec_push(fields, field.text);
    vec_push(fieldTyAnns, _ty.v0);
    k = skip_ws(src, k);
    if (k < stringLen(src)) {
      let ch = stringCharCodeAt(src, k);
      if (ch == 44 || ch == 59) { k = k + 1; }
    }
  }

  // Maintain runtime struct field order table used by struct literals.
  add_struct_def(name.text, fields);
  ParsedDeclAst(decl_struct_typed(span(start, k), name.text, typeParams, fields, fieldTyAnns), k)
}

fn parse_type_union_decl_ast(src: String, i: I32, exportAll: Bool) : ParsedDeclAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "type");
  let name = parse_ident(src, k);
  k = name.nextPos;
  if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

  let mut typeParams = vec_new();
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) {
    let tp = parse_type_params_list_ast(src, t0);
    typeParams = tp.params;
    k = tp.nextPos;
  }

  k = parse_keyword(src, k, "=");
  let variants = vec_new();
  let mut first = true;
  while (true) {
    if (!first) { k = parse_keyword(src, k, "|"); }
    first = false;
    let vStart = skip_ws(src, k);
    let v = parse_ident(src, vStart);
    k = v.nextPos;
    let t1 = skip_ws(src, k);
    if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 60) {
      // Variant payload type annotations: Variant<T> or Variant<T, U>
      let mut pk = parse_keyword(src, t1, "<");
      let payloadTyAnns = vec_new();
      while (true) {
        let a = parse_type_expr(src, pk);
        vec_push(payloadTyAnns, a.v0);
        pk = skip_ws(src, a.v1);
        if (!(pk < stringLen(src))) { panic_at(src, pk, "expected '>' in union variant payload"); }
        let chp = stringCharCodeAt(src, pk);
        if (chp == 44) { // ','
          pk = pk + 1;
          pk = skip_ws(src, pk);
          continue;
        }
        if (chp == 62) { // '>'
          k = pk + 1;
          break;
        }
        panic_at(src, pk, "expected ',' or '>' in union variant payload");
      }
      vec_push(variants, type_union_variant_typed(span(vStart, k), v.text, payloadTyAnns));
    } else {
      vec_push(variants, type_union_variant(span(vStart, k), v.text, false));
    }
    let t2 = skip_ws(src, k);
    if (!(t2 < stringLen(src))) { break; }
    let ch = stringCharCodeAt(src, t2);
    if (ch == 59) { k = t2 + 1; break; }
    if (ch == 124) { continue; }
    panic_at(src, t2, "expected '|' or ';' in union type")
  }
  ParsedDeclAst(decl_type_union(span(start, k), name.text, typeParams, variants), k)
}

fn parse_module_decl_ast(src: String, i: I32) : ParsedDeclAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "module");
  let modName = parse_ident(src, k);
  k = parse_keyword(src, modName.nextPos, "{");

  let decls = vec_new();
  while (true) {
    let t = skip_ws(src, k);
    if (!(t < stringLen(src))) { panic_at(src, t, "expected '}'"); }
    if (stringCharCodeAt(src, t) == 125) { k = t + 1; break; }

    if (starts_with_at(src, t, "fn")) {
      let d = parse_fn_decl_ast2(src, k, false);
      vec_push(decls, d.decl);
      k = d.nextPos;
      continue;
    }
    if (starts_with_at(src, t, "module")) {
      let d = parse_module_decl_ast(src, k);
      vec_push(decls, d.decl);
      k = d.nextPos;
      continue;
    }
    panic_at(src, t, "expected fn or module inside module")
  }

  ParsedDeclAst(decl_module(span(start, k), modName.text, decls), k)
}

fn parse_extern_decl(src: String, i: I32) : String => {
  let mut k = parse_keyword(src, i, "extern");
  k = parse_keyword(src, k, "from");
  let mod = parse_module_path(src, k);
  k = mod.nextPos;
  k = parse_keyword(src, k, "use");
  k = parse_keyword(src, k, "{");

  let mut names = "";
  let mut first = true;
  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
    if (stringCharCodeAt(src, k) == 125) { k = k + 1; break; }
    let id = parse_ident(src, k);
    k = id.nextPos;
    if (first) { names = names + id.text; } else { names = names + ", " + id.text; }
    first = false;
    k = skip_ws(src, k);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 44) { k = k + 1; continue; }
    k = skip_ws(src, k);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 125) { k = k + 1; break; }
    panic_at(src, k, "expected ',' or '}' in extern list");
  }

  k = parse_optional_semicolon(src, k);

  let mut importPath = "";
  if (starts_with_at(mod.text, 0, "rt::")) { importPath = "./rt/" + stringSlice(mod.text, 4, stringLen(mod.text)) + ".mjs"; }
  if (importPath == "" && starts_with_at(mod.text, 0, "node::")) { importPath = "node:" + stringSlice(mod.text, 6, stringLen(mod.text)); }
  if (importPath == "") { panic_at(src, k, "unsupported extern module: " + mod.text); }

  ParsedStmt("import { " + names + " } from \"" + importPath + "\";\n", k)
}

fn parse_imports(src: String, i: I32) : ParsedImports => {
  let mut k = i;
  let mut out = "";
  while (true) {
    let j = skip_ws(src, k);
    if (starts_with_at(src, j, "import")) {
      panic_at(src, j, "`import` is not supported. Use `from <module> use { ... };` instead.");
    }
    if (!starts_with_at(src, j, "from")) { break; }

    k = parse_keyword(src, k, "from");
    let mod = parse_module_path(src, k);
    k = mod.nextPos;
    k = parse_keyword(src, k, "use");
    k = parse_keyword(src, k, "{");

    let mut names = "";
    let mut first = true;
    while (true) {
      k = skip_ws(src, k);
      if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
      if (stringCharCodeAt(src, k) == 125) { k = k + 1; break; }
      let id = parse_ident(src, k);
      k = id.nextPos;
      if (first) { names = names + id.text; } else { names = names + ", " + id.text; }
      first = false;
      k = skip_ws(src, k);
      if (k < stringLen(src) && stringCharCodeAt(src, k) == 44) { k = k + 1; continue; }
      k = skip_ws(src, k);
      if (k < stringLen(src) && stringCharCodeAt(src, k) == 125) { k = k + 1; break; }
      panic_at(src, k, "expected ',' or '}' in import list");
    }

    k = parse_optional_semicolon(src, k);

    let importPath = "./" + module_path_to_relpath(mod.text) + ".mjs";
    out = out + ("import { " + names + " } from \"" + importPath + "\";\n");
  }
  ParsedImports(out, k)
}

fn parse_fn_decl_named(src: String, i: I32, jsName: String, exportThis: Bool) : String => {
  let mut k = parse_keyword(src, i, "fn");
  let name = parse_ident(src, k);
  k = name.nextPos;

  // Optional generic params: fn name<T, U>(...)
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) { // '<'
    k = skip_angle_brackets(src, t0);
  }

  let params = parse_param_list(src, k);
  k = params.v1;

  // Optional return type: : Type
  let t1 = skip_ws(src, k);
  if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 58) { // ':'
    let _rt = parse_type_expr(src, t1 + 1);
    k = _rt.v1;
  }

  k = parse_keyword(src, k, "=>");
  let body = parse_main_body(src, k);
  k = body.v1;

  let exportKw = if (exportThis) "export " else "";
  let js = exportKw + "function " + jsName + "(" + params.v0 + ") {\n" + body.body + "return " + body.expr + ";\n}\n";
  ParsedFn(js, k, name.text)
}

fn parse_module_decl(src: String, i: I32, prefix: String, exportTop: Bool) : String => {
  // module Name { (fn ... | module ...)* }
  let mut k = parse_keyword(src, i, "module");
  let modName = parse_ident(src, k);
  k = modName.nextPos;
  k = parse_keyword(src, k, "{");

  let mut decls = "";
  let mut entries = "";
  let mut first = true;

  while (true) {
    let t = skip_ws(src, k);
    if (!(t < stringLen(src))) { panic_at(src, t, "expected '}'"); }
    if (stringCharCodeAt(src, t) == 125) { k = t + 1; break; }

    if (starts_with_at(src, t, "fn")) {
      let fnParsed = parse_fn_decl_named(src, k, prefix + "__" + modName.text + "__" + "fn" + "__" + "tmp", false);
      // we emitted with a temp name; re-emit with stable js name including function name
      // (parse again from the same start)
      let fn2 = parse_fn_decl_named(src, k, prefix + "__" + modName.text + "__" + fnParsed.v2, false);
      decls = decls + fn2.v0;
      if (first) { entries = entries + (fn2.v2 + ": " + (prefix + "__" + modName.text + "__" + fn2.v2)); }
      else { entries = entries + (", " + fn2.v2 + ": " + (prefix + "__" + modName.text + "__" + fn2.v2)); }
      first = false;
      k = fn2.v1;
      continue;
    }

    if (starts_with_at(src, t, "module")) {
      let inner = parse_module_decl(src, k, prefix + "__" + modName.text, false);
      decls = decls + inner.v0;
      // inner module exports as const with its own name; include it as property
      // since `exportTop` is false here, inner will be `const <Inner> = {...}`
      // and we reference that name.
      let innerName = parse_ident(src, parse_keyword(src, k, "module"));
      // NOTE: parse_ident above is safe since parse_module_decl already parsed it; this is a tiny hack to recover name.
      let prop = innerName.text;
      if (first) { entries = entries + (prop + ": " + prop); }
      else { entries = entries + (", " + prop + ": " + prop); }
      first = false;
      k = inner.v1;
      continue;
    }

    panic_at(src, t, "expected fn or module inside module")
  }

  let obj = "{ " + entries + " }";
  let header = if (exportTop) "export const " else "const ";
  let code = decls + header + modName.text + " = " + obj + ";\n";
  ParsedStmt(code, k)
}

fn parse_fn_decl2(src: String, i: I32, exportAll: Bool) : String => {
  let mut k = parse_keyword(src, i, "fn");
  let name = parse_ident(src, k);
  k = name.nextPos;
  if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

  // Optional generic params: fn name<T, U>(...)
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) { // '<'
    k = skip_angle_brackets(src, t0);
  }

  let params = parse_param_list(src, k);
  k = params.v1;

  // Optional return type: : Type
  let t1 = skip_ws(src, k);
  if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 58) { // ':'
    let _rt = parse_type_expr(src, t1 + 1);
    k = _rt.v1;
  }

  k = parse_keyword(src, k, "=>");
  let body = parse_main_body(src, k);
  k = body.v1;

  let exportKw = if (exportAll || name.text == "main") "export " else "";
  let js = exportKw + "function " + name.text + "(" + params.v0 + ") {\n" + body.body + "return " + body.expr + ";\n}\n";
  ParsedStmt(js, k)
}

fn parse_class_fn_decl2(src: String, i: I32, exportAll: Bool) : String => {
  let mut k = parse_keyword(src, i, "class");
  k = parse_keyword(src, k, "fn");
  let name = parse_ident(src, k);
  k = name.nextPos;
  if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

  // Optional generic params: class fn name<T, U>(...)
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) { // '<'
    k = skip_angle_brackets(src, t0);
  }

  let params = parse_param_list(src, k);
  k = params.v1;

  // Optional return type: : Type
  let t1 = skip_ws(src, k);
  if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 58) { // ':'
    let _rt = parse_type_expr(src, t1 + 1);
    k = _rt.v1;
  }

  k = parse_keyword(src, k, "=>");
  let body = parse_main_body(src, k);
  k = body.v1;

  // Minimal `class fn` lowering: execute body statements then yield `this`.
  // For now, `this` is just an object containing parameters.
  // (This is sufficient for our compiler's internal record-like classes.)
  let exportKw = if (exportAll || name.text == "main") "export " else "";
  let mut fields = "";
  // params.v0 is the comma-joined param list; we need `{ a: a, b: b }`.
  // Build it by re-parsing the param list text.
  let mut pi = 0;
  let mut first = true;
  while (pi < stringLen(params.v0)) {
    // skip spaces/commas
    while (pi < stringLen(params.v0)) {
      let ch = stringCharCodeAt(params.v0, pi);
      if (ch == 32 || ch == 9 || ch == 10 || ch == 13 || ch == 44) { pi = pi + 1; continue; }
      break;
    }
    if (!(pi < stringLen(params.v0))) { break; }
    let start = pi;
    while (pi < stringLen(params.v0)) {
      let ch = stringCharCodeAt(params.v0, pi);
      if (ch == 44) { break; }
      pi = pi + 1;
    }
    let p = stringSlice(params.v0, start, pi);
    // trim trailing spaces
    let mut end = stringLen(p);
    while (end > 0) {
      let ch = stringCharCodeAt(p, end - 1);
      if (ch == 32 || ch == 9 || ch == 10 || ch == 13) { end = end - 1; continue; }
      break;
    }
    let nameOnly = stringSlice(p, 0, end);
    if (nameOnly != "") {
      if (first) { fields = fields + (nameOnly + ": " + nameOnly); }
      else { fields = fields + (", " + nameOnly + ": " + nameOnly); }
      first = false;
    }
  }

  // Also include `let`/`const` locals from the generated JS body.
  // This is a simple text scan over `body.body` (which is JS), used only by
  // the tiny compiler path.
  let mut bi = 0;
  while (bi < stringLen(body.body)) {
    // Find "let " or "const ".
    if (starts_with_at(body.body, bi, "let ") || starts_with_at(body.body, bi, "const ")) {
      bi = bi + (if (starts_with_at(body.body, bi, "let ")) 4 else 6);
      // Read identifier
      let start2 = bi;
      while (bi < stringLen(body.body) && is_ident_part(stringCharCodeAt(body.body, bi))) {
        bi = bi + 1;
      }
      let n = stringSlice(body.body, start2, bi);
      // Avoid duplicates: look for the exact substring "<name>: <name>".
      let mut already = false;
      if (n != "") {
        let pat = n + ": " + n;
        let mut si = 0;
        while (si + stringLen(pat) <= stringLen(fields)) {
          if (stringSlice(fields, si, si + stringLen(pat)) == pat) {
            already = true;
            si = stringLen(fields);
          } else {
            si = si + 1;
          }
        }
      }
      if (n != "" && !already) {
        if (first) { fields = fields + (n + ": " + n); }
        else { fields = fields + (", " + n + ": " + n); }
        first = false;
      }
      continue;
    }
    bi = bi + 1;
  }

  let js = exportKw + "function " + name.text + "(" + params.v0 + ") {\n" + body.body + "return { " + fields + " };\n}\n";
  ParsedStmt(js, k)
}

fn parse_fn_decl(src: String, i: I32) : String => parse_fn_decl2(src, i, false)

fn parse_struct_decl(src: String, i: I32) : String => {
  // struct Name { field: Type, ... }
  let mut k = parse_keyword(src, i, "struct");
  let name = parse_ident(src, k);
  k = name.nextPos;
  if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

  // Optional generic params: struct Name<T, U> { ... }
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) { // '<'
    k = skip_angle_brackets(src, t0);
  }

  k = parse_keyword(src, k, "{");

  let fields = vec_new();

  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
    if (stringCharCodeAt(src, k) == 125) { // '}'
      k = k + 1;
      break;
    }

    let field = parse_ident(src, k);
    k = field.nextPos;
    k = parse_keyword(src, k, ":");
    let _ty = parse_type_expr(src, k);
    k = _ty.v1;

    vec_push(fields, field.text);

    k = skip_ws(src, k);
    if (k < stringLen(src)) {
      let ch = stringCharCodeAt(src, k);
      if (ch == 44 || ch == 59) { // ',' or ';'
        k = k + 1;
      }
    }
  }

  add_struct_def(name.text, fields);
  ParsedStmt("", k)
}

fn parse_type_union_decl(src: String, i: I32, exportAll: Bool) : String => {
  // type Name<T, ...> = Variant1<X> | Variant2 | ...;
  let mut k = parse_keyword(src, i, "type");
  let _name = parse_ident(src, k);
  k = _name.nextPos;
  if (is_identifier_too_short(_name.text)) { warn_short_identifier(src, _name.startPos, _name.text); }

  // optional type params on the alias name
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) { // '<'
    k = skip_angle_brackets(src, t0);
  }

  k = parse_keyword(src, k, "=");

  let mut out = "";
  let mut first = true;
  while (true) {
    if (!first) { k = parse_keyword(src, k, "|"); }
    first = false;

    let v = parse_ident(src, k);
    let variant = v.text;
    k = v.nextPos;

    let mut hasPayload = false;
    let t1 = skip_ws(src, k);
    if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 60) { // '<'
      hasPayload = true;
      k = skip_angle_brackets(src, t1);
    }

    let header = if (exportAll) "export const " else "const ";
    if (hasPayload) {
      out = out + (header + variant + " = (value) => ({ tag: \"" + variant + "\", value });\n");
    } else {
      out = out + (header + variant + " = { tag: \"" + variant + "\" };\n");
    }

    let t2 = skip_ws(src, k);
    if (!(t2 < stringLen(src))) { yield ParsedStmt(out, k); }
    let ch = stringCharCodeAt(src, t2);
    if (ch == 59) { // ';'
      k = t2 + 1;
      break;
    }
    if (ch == 124) { // '|'
      // continue parsing variants
      continue;
    }
    panic_at(src, t2, "expected '|' or ';' in union type")
  }

  ParsedStmt(out, k)
}
