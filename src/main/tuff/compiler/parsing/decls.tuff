// Selfhost compiler: AST-producing declaration parsing.
// Extracted from tuffc_lib.tuff as part of Phase 2 (mechanical split).

extern from rt::stdlib use { stringLen, stringCharCodeAt };
extern from rt::vec use { vec_new, vec_len, vec_push, vec_get };

from util::diagnostics use {
  panic_at,
  add_struct_def,
  is_identifier_too_short,
  warn_short_identifier
};

from util::lexing use { skip_ws, starts_with_at };

from parsing::primitives use {
  parse_ident,
  parse_keyword,
  parse_module_path,
  parse_optional_semicolon
};

from parsing::types use { parse_type_expr };

from parsing::expr_stmt_types use { ParsedMainAst };

from parsing::expr_stmt use { parse_main_body_ast };

from ast use {
  span,
  decl_extern_from,
  decl_extern_type,
  decl_import,
  decl_fn,
  decl_fn_typed,
  decl_class_fn,
  decl_class_fn_typed,
  decl_struct_typed,
  decl_type_union,
  type_union_variant,
  type_union_variant_typed,
  decl_module
};

// NOTE: Avoid type aliases in signatures (type aliases are not runtime exports).
out class fn ParsedDeclAst(decl: String, nextPos: I32) => {}
out class fn ParsedDeclsAst(decls: Vec<String>, nextPos: I32) => {}
out class fn ParsedNamesAst(names: Vec<String>, nextPos: I32) => {}
out class fn ParsedParamsAst(names: Vec<String>, tyAnns: Vec<String>, nextPos: I32) => {}
out class fn ParsedTypeParamsAst(params: Vec<String>, nextPos: I32) => {}

// ------------------------------------------------------------
// AST path (Phase 3) - Helper parsers
// ------------------------------------------------------------

fn parse_name_list_ast(src: String, i: I32) : ParsedNamesAst => {
  // parses: '{' (ident (',' ident)*)? '}'
  let mut k = parse_keyword(src, i, "{");
  k = skip_ws(src, k);
  let names = vec_new();
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 125) { // '}'
    yield ParsedNamesAst(names, k + 1);
  }
  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
    if (stringCharCodeAt(src, k) == 125) { yield ParsedNamesAst(names, k + 1); }
    let id = parse_ident(src, k);
    vec_push(names, id.text);
    k = skip_ws(src, id.nextPos);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 44) { k = k + 1; continue; }
    k = skip_ws(src, k);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 125) { yield ParsedNamesAst(names, k + 1); }
    panic_at(src, k, "expected ',' or '}' in name list")
  }
  ParsedNamesAst(names, k)
}

out fn parse_type_params_list_ast(src: String, i: I32) : ParsedTypeParamsAst => {
  // parses: '<' (ident (',' ident)*)? '>'
  let mut k = skip_ws(src, i);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 60)) { // '<'
    yield ParsedTypeParamsAst(vec_new(), i);
  }
  k = k + 1;
  k = skip_ws(src, k);
  let params = vec_new();
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 62) { // '>'
    yield ParsedTypeParamsAst(params, k + 1);
  }
  while (true) {
    let id = parse_ident(src, k);
    vec_push(params, id.text);
    k = skip_ws(src, id.nextPos);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '>' in type params"); }
    let ch = stringCharCodeAt(src, k);
    if (ch == 44) { // ','
      k = k + 1;
      k = skip_ws(src, k);
      continue;
    }
    if (ch == 62) { // '>'
      yield ParsedTypeParamsAst(params, k + 1);
    }
    panic_at(src, k, "expected ',' or '>' in type params");
  }
  ParsedTypeParamsAst(params, k)
}

fn parse_param_list_ast(src: String, i: I32) : ParsedParamsAst => {
  // parses: '(' (ident (',' ident)*)? ')'
  let mut k = parse_keyword(src, i, "(");
  k = skip_ws(src, k);
  let names = vec_new();
  let tyAnns = vec_new();
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
    yield ParsedParamsAst(names, tyAnns, k + 1);
  }
  while (true) {
    let id = parse_ident(src, k);
    k = id.nextPos;
    let t0 = skip_ws(src, k);
    if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) {
      let _ty = parse_type_expr(src, t0 + 1);
      vec_push(tyAnns, _ty.v0);
      k = _ty.v1;
    } else {
      vec_push(tyAnns, "");
    }
    vec_push(names, id.text);
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in param list"); }
    let c = stringCharCodeAt(src, k);
    if (c == 44) { k = k + 1; continue; }
    if (c == 41) { yield ParsedParamsAst(names, tyAnns, k + 1); }
    panic_at(src, k, "expected ',' or ')' in param list")
  }
  ParsedParamsAst(names, tyAnns, k)
}

// ------------------------------------------------------------
// AST path (Phase 3) - Declaration parsers
// ------------------------------------------------------------

out fn parse_extern_decl_ast(src: String, i: I32) : ParsedDeclAst => {
  let start = skip_ws(src, i);
  let mut k = start;
  let mut isOut = false;
  let j0 = skip_ws(src, k);
  if (starts_with_at(src, j0, "out")) {
    k = parse_keyword(src, k, "out");
    isOut = true;
  }
  k = parse_keyword(src, k, "extern");
  let j1 = skip_ws(src, k);

  // extern from <module> use { ... };
  if (starts_with_at(src, j1, "from")) {
    k = parse_keyword(src, k, "from");
    let mod = parse_module_path(src, k);
    k = parse_keyword(src, mod.nextPos, "use");
    let names = parse_name_list_ast(src, k);
    k = parse_optional_semicolon(src, names.nextPos);
    yield ParsedDeclAst(decl_extern_from(span(start, k), mod.text, names.names), k);
  }

  // extern type Name<T, ...>;
  if (starts_with_at(src, j1, "type")) {
    k = parse_keyword(src, k, "type");
    let name = parse_ident(src, k);
    k = name.nextPos;

    let mut typeParams = vec_new();
    let t0 = skip_ws(src, k);
    if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) {
      let tp = parse_type_params_list_ast(src, t0);
      typeParams = tp.params;
      k = tp.nextPos;
    }

    k = parse_optional_semicolon(src, k);
    yield ParsedDeclAst(decl_extern_type(span(start, k), isOut, name.text, typeParams), k);
  }

  panic_at(src, j1, "expected 'from' or 'type' after extern");
  ParsedDeclAst(decl_extern_from(span(start, k), "", vec_new()), k)
}

out fn parse_imports_ast(src: String, i: I32) : ParsedDeclsAst => {
  let mut k = i;
  let decls = vec_new();
  while (true) {
    let j = skip_ws(src, k);
    if (starts_with_at(src, j, "import")) {
      panic_at(src, j, "`import` is not supported. Use `from <module> use { ... };` instead.");
    }
    if (!starts_with_at(src, j, "from")) { break; }

    let start = skip_ws(src, k);
    k = parse_keyword(src, k, "from");
    let mod = parse_module_path(src, k);
    k = parse_keyword(src, mod.nextPos, "use");
    let names = parse_name_list_ast(src, k);
    k = parse_optional_semicolon(src, names.nextPos);
    vec_push(decls, decl_import(span(start, k), mod.text, names.names));
  }
  ParsedDeclsAst(decls, k)
}

fn parse_fn_decl_ast(src: String, i: I32) : ParsedDeclAst => parse_fn_decl_ast2(src, i, false)

out fn parse_fn_decl_ast2(src: String, i: I32, exportAll: Bool) : ParsedDeclAst => {
  let start = skip_ws(src, i);
  let mut k = start;
  let mut isOut = false;
  let j0 = skip_ws(src, k);
  if (starts_with_at(src, j0, "out")) {
    k = parse_keyword(src, k, "out");
    isOut = true;
  }
  k = parse_keyword(src, k, "fn");
  let name = parse_ident(src, k);
  k = name.nextPos;
  if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

  let mut typeParams = vec_new();
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) {
    let tp = parse_type_params_list_ast(src, t0);
    typeParams = tp.params;
    k = tp.nextPos;
  }

  let params = parse_param_list_ast(src, k);
  k = params.nextPos;

  let t1 = skip_ws(src, k);
  let mut retTyAnn = "";
  if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 58) {
    let _rt = parse_type_expr(src, t1 + 1);
    retTyAnn = _rt.v0;
    k = _rt.v1;
  }

  k = parse_keyword(src, k, "=>");
  let body = parse_main_body_ast(src, k);
  k = body.nextPos;

  // If any types were provided, store them; otherwise keep the legacy shape.
  let mut anyParamTy = false;
  let mut pi = 0;
  while (pi < vec_len(params.tyAnns)) {
    if (vec_get(params.tyAnns, pi) != "") { anyParamTy = true; break; }
    pi = pi + 1;
  }
  if (anyParamTy || retTyAnn != "") {
    yield ParsedDeclAst(decl_fn_typed(span(start, k), isOut, name.text, typeParams, params.names, params.tyAnns, retTyAnn, body.body, body.tail), k);
  }
  ParsedDeclAst(decl_fn(span(start, k), isOut, name.text, params.names, body.body, body.tail), k)
}

out fn parse_class_fn_decl_ast2(src: String, i: I32, exportAll: Bool) : ParsedDeclAst => {
  let start = skip_ws(src, i);
  let mut k = start;
  let mut isOut = false;
  let j0 = skip_ws(src, k);
  if (starts_with_at(src, j0, "out")) {
    k = parse_keyword(src, k, "out");
    isOut = true;
  }
  k = parse_keyword(src, k, "class");
  k = parse_keyword(src, k, "fn");
  let name = parse_ident(src, k);
  k = name.nextPos;
  if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

  let mut typeParams = vec_new();
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) {
    let tp = parse_type_params_list_ast(src, t0);
    typeParams = tp.params;
    k = tp.nextPos;
  }

  let params = parse_param_list_ast(src, k);
  k = params.nextPos;

  let t1 = skip_ws(src, k);
  let mut retTyAnn = "";
  if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 58) {
    let _rt = parse_type_expr(src, t1 + 1);
    retTyAnn = _rt.v0;
    k = _rt.v1;
  }

  k = parse_keyword(src, k, "=>");
  let body = parse_main_body_ast(src, k);
  k = body.nextPos;

  let mut anyParamTy = false;
  let mut pi = 0;
  while (pi < vec_len(params.tyAnns)) {
    if (vec_get(params.tyAnns, pi) != "") { anyParamTy = true; break; }
    pi = pi + 1;
  }
  if (anyParamTy || retTyAnn != "") {
    yield ParsedDeclAst(decl_class_fn_typed(span(start, k), isOut, name.text, typeParams, params.names, params.tyAnns, retTyAnn, body.body, body.tail), k);
  }
  ParsedDeclAst(decl_class_fn(span(start, k), isOut, name.text, params.names, body.body, body.tail), k)
}

out fn parse_struct_decl_ast(src: String, i: I32) : ParsedDeclAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "struct");
  let name = parse_ident(src, k);
  k = name.nextPos;
  if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

  let mut typeParams = vec_new();
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) {
    let tp = parse_type_params_list_ast(src, t0);
    typeParams = tp.params;
    k = tp.nextPos;
  }

  k = parse_keyword(src, k, "{");
  let fields = vec_new();
  let fieldTyAnns = vec_new();
  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
    if (stringCharCodeAt(src, k) == 125) { k = k + 1; break; }
    let field = parse_ident(src, k);
    k = parse_keyword(src, field.nextPos, ":");
    let _ty = parse_type_expr(src, k);
    k = _ty.v1;
    vec_push(fields, field.text);
    vec_push(fieldTyAnns, _ty.v0);
    k = skip_ws(src, k);
    if (k < stringLen(src)) {
      let ch = stringCharCodeAt(src, k);
      if (ch == 44 || ch == 59) { k = k + 1; }
    }
  }

  // Maintain runtime struct field order table used by struct literals.
  add_struct_def(name.text, fields);
  ParsedDeclAst(decl_struct_typed(span(start, k), name.text, typeParams, fields, fieldTyAnns), k)
}

out fn parse_type_union_decl_ast(src: String, i: I32, exportAll: Bool) : ParsedDeclAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "type");
  let name = parse_ident(src, k);
  k = name.nextPos;
  if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

  let mut typeParams = vec_new();
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) {
    let tp = parse_type_params_list_ast(src, t0);
    typeParams = tp.params;
    k = tp.nextPos;
  }

  k = parse_keyword(src, k, "=");
  let variants = vec_new();
  let mut first = true;
  while (true) {
    if (!first) { k = parse_keyword(src, k, "|"); }
    first = false;
    let vStart = skip_ws(src, k);
    let v = parse_ident(src, vStart);
    k = v.nextPos;
    let t1 = skip_ws(src, k);
    if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 60) {
      // Variant payload type annotations: Variant<T> or Variant<T, U>
      let mut pk = parse_keyword(src, t1, "<");
      let payloadTyAnns = vec_new();
      while (true) {
        let a = parse_type_expr(src, pk);
        vec_push(payloadTyAnns, a.v0);
        pk = skip_ws(src, a.v1);
        if (!(pk < stringLen(src))) { panic_at(src, pk, "expected '>' in union variant payload"); }
        let chp = stringCharCodeAt(src, pk);
        if (chp == 44) { // ','
          pk = pk + 1;
          pk = skip_ws(src, pk);
          continue;
        }
        if (chp == 62) { // '>'
          k = pk + 1;
          break;
        }
        panic_at(src, pk, "expected ',' or '>' in union variant payload");
      }
      vec_push(variants, type_union_variant_typed(span(vStart, k), v.text, payloadTyAnns));
    } else {
      vec_push(variants, type_union_variant(span(vStart, k), v.text, false));
    }
    let t2 = skip_ws(src, k);
    if (!(t2 < stringLen(src))) { break; }
    let ch = stringCharCodeAt(src, t2);
    if (ch == 59) { k = t2 + 1; break; }
    if (ch == 124) { continue; }
    panic_at(src, t2, "expected '|' or ';' in union type")
  }
  ParsedDeclAst(decl_type_union(span(start, k), name.text, typeParams, variants), k)
}

out fn parse_module_decl_ast(src: String, i: I32) : ParsedDeclAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "module");
  let modName = parse_ident(src, k);
  k = parse_keyword(src, modName.nextPos, "{");

  let decls = vec_new();
  while (true) {
    let t = skip_ws(src, k);
    if (!(t < stringLen(src))) { panic_at(src, t, "expected '}'"); }
    if (stringCharCodeAt(src, t) == 125) { k = t + 1; break; }

    if (starts_with_at(src, t, "fn") || starts_with_at(src, t, "out")) {
      let d = parse_fn_decl_ast2(src, k, false);
      vec_push(decls, d.decl);
      k = d.nextPos;
      continue;
    }
    if (starts_with_at(src, t, "module")) {
      let d = parse_module_decl_ast(src, k);
      vec_push(decls, d.decl);
      k = d.nextPos;
      continue;
    }
    panic_at(src, t, "expected fn or module inside module")
  }

  ParsedDeclAst(decl_module(span(start, k), modName.text, decls), k)
}
