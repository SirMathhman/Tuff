// Selfhost compiler: minimal type-expression parsing helpers.
// Extracted from tuffc_lib.tuff as part of Phase 2 (mechanical split).

extern from rt::stdlib use { stringLen, stringCharCodeAt, stringSlice };

from util::diagnostics use { panic_at };
from util::lexing use { skip_ws };

from parsing::primitives use {
  ParsedIdent,
  ParsedNumber,
  parse_ident,
  parse_keyword,
  parse_number
};

out class fn ParsedType(v0: String, v1: I32) => {}

out fn skip_angle_brackets(src: String, i: I32) : I32 => {
  // Skips a possibly-nested '<...>' section. Expects '<' at i (after ws).
  let mut k = skip_ws(src, i);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 60)) { // '<'
    panic_at(src, k, "expected '<'");
  }
  k = k + 1;
  let mut depth = 1;
  while (k < stringLen(src)) {
    let ch = stringCharCodeAt(src, k);
    if (ch == 60) { depth = depth + 1; k = k + 1; continue; } // '<'
    if (ch == 62) { // '>'
      depth = depth - 1;
      k = k + 1;
      if (depth == 0) { yield k; }
      continue;
    }
    k = k + 1;
  }
  panic_at(src, k, "unterminated '<...>'")
}

out fn parse_type_expr(src: String, i: I32) : ParsedType => {
  // Minimal-but-real type expression parser.
  // Produces a textual representation (v0) and the index after the type (v1).
  let mut k = skip_ws(src, i);
  if (!(k < stringLen(src))) { panic_at(src, k, "expected type"); }

  let c = stringCharCodeAt(src, k);

  // Slice: *[T]
  if (c == 42) { // '*'
    k = k + 1;
    k = parse_keyword(src, k, "[");
    let inner = parse_type_expr(src, k);
    k = inner.v1;
    k = parse_keyword(src, k, "]");
    yield ParsedType("*[" + inner.v0 + "]", k);
  }

  // Array: [T; N; M]
  if (c == 91) { // '['
    k = parse_keyword(src, k, "[");
    let inner = parse_type_expr(src, k);
    k = inner.v1;
    let mut sizes = "";
    while (true) {
      let t = skip_ws(src, k);
      if (!(t < stringLen(src) && stringCharCodeAt(src, t) == 59)) { break; } // ';'
      let n = parse_number(src, t + 1);
      sizes = sizes + ";" + ("" + n.value);
      k = n.nextPos;
    }
    k = parse_keyword(src, k, "]");
    yield ParsedType("[" + inner.v0 + sizes + "]", k);
  }

  // Tuple / function type: (T, U) or (T, U) => R
  if (c == 40) { // '('
    k = parse_keyword(src, k, "(");
    k = skip_ws(src, k);
    let mut parts = "";
    let mut first = true;
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
      k = k + 1;
    } else {
      while (true) {
        let t1 = parse_type_expr(src, k);
        k = t1.v1;
        if (first) { parts = parts + t1.v0; } else { parts = parts + ", " + t1.v0; }
        first = false;
        k = skip_ws(src, k);
        if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in type"); }
        let ch = stringCharCodeAt(src, k);
        if (ch == 44) { // ','
          k = k + 1;
          continue;
        }
        if (ch == 41) { // ')'
          k = k + 1;
          break;
        }
        panic_at(src, k, "expected ',' or ')' in type");
      }
    }

    let t2 = skip_ws(src, k);
    if (t2 + 1 < stringLen(src) && stringCharCodeAt(src, t2) == 61 && stringCharCodeAt(src, t2 + 1) == 62) { // '=>'
      let ret = parse_type_expr(src, t2 + 2);
      yield ParsedType("(" + parts + ") => " + ret.v0, ret.v1);
    }
    yield ParsedType("(" + parts + ")", k);
  }

  // Name / generic: Ident or Ident<...>
  let name = parse_ident(src, k);
  k = name.nextPos;
  let mut out = name.text;

  let t3 = skip_ws(src, k);
  if (t3 < stringLen(src) && stringCharCodeAt(src, t3) == 60) { // '<'
    k = parse_keyword(src, t3, "<");
    let mut args = "";
    let mut firstArg = true;
    while (true) {
      let a = parse_type_expr(src, k);
      k = a.v1;
      if (firstArg) { args = args + a.v0; } else { args = args + ", " + a.v0; }
      firstArg = false;
      k = skip_ws(src, k);
      if (!(k < stringLen(src))) { panic_at(src, k, "expected '>' in generic type"); }
      let ch = stringCharCodeAt(src, k);
      if (ch == 44) { // ','
        k = k + 1;
        continue;
      }
      if (ch == 62) { // '>'
        k = k + 1;
        break;
      }
      panic_at(src, k, "expected ',' or '>' in generic type");
    }
    out = out + "<" + args + ">";
  }

  ParsedType(out, k)
}

fn skip_type_expr(src: String, i: I32) : I32 => {
  // Skip a type expression in places where we don't need semantics yet.
  // Stops before ',', ';', or '}' when not inside angle brackets.
  let mut k = skip_ws(src, i);
  let mut depth = 0;
  while (k < stringLen(src)) {
    let ch = stringCharCodeAt(src, k);
    if (ch == 60) { depth = depth + 1; k = k + 1; continue; } // '<'
    if (ch == 62) { // '>'
      if (depth > 0) { depth = depth - 1; }
      k = k + 1;
      continue;
    }
    if (depth == 0 && (ch == 44 || ch == 59 || ch == 125)) { yield k; } // ',', ';', '}'
    k = k + 1;
  }
  panic_at(src, k, "unterminated type")
}
