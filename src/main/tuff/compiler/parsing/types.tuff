// Selfhost compiler: minimal type-expression parsing helpers.
// Extracted from tuffc_lib.tuff as part of Phase 2 (mechanical split).

extern from rt::stdlib use { stringLen, stringCharCodeAt, stringSlice };

from util::diagnostics use { panic_at };
from util::lexing use { skip_ws };

from parsing::primitives use {
  ParsedIdent,
  ParsedNumber,
  parse_ident,
  parse_keyword,
  parse_number
};

from util::lexing use { is_ident_start, is_ident_part };

out class fn ParsedType(v0: String, v1: I32) => {}

// Result of parsing !dropFn suffix
out class fn ParsedDropSuffix(hasIt: Bool, name: String, nextPos: I32) => {}

// Parse optional !identifier suffix for droppable types
fn parse_drop_suffix(src: String, i: I32) : ParsedDropSuffix => {
  let k = skip_ws(src, i);
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 33) { // '!'
    let afterBang = k + 1;
    if (afterBang < stringLen(src) && is_ident_start(stringCharCodeAt(src, afterBang))) {
      let ident = parse_ident(src, afterBang);
      yield ParsedDropSuffix(true, ident.text, ident.nextPos);
    }
  }
  ParsedDropSuffix(false, "", i)
}

out fn skip_angle_brackets(src: String, i: I32) : I32 => {
  // Skips a possibly-nested '<...>' section. Expects '<' at i (after ws).
  let mut k = skip_ws(src, i);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 60)) { // '<'
    panic_at(src, k, "expected '<'");
  }
  k = k + 1;
  let mut depth = 1;
  while (k < stringLen(src)) {
    let ch = stringCharCodeAt(src, k);
    if (ch == 60) { depth = depth + 1; k = k + 1; continue; } // '<'
    if (ch == 62) { // '>'
      depth = depth - 1;
      k = k + 1;
      if (depth == 0) { yield k; }
      continue;
    }
    k = k + 1;
  }
  panic_at(src, k, "unterminated '<...>'")
}

out fn parse_type_expr(src: String, i: I32) : ParsedType => {
  // Minimal-but-real type expression parser.
  // Produces a textual representation (v0) and the index after the type (v1).
  let mut k = skip_ws(src, i);
  if (!(k < stringLen(src))) { panic_at(src, k, "expected type"); }

  let c = stringCharCodeAt(src, k);

  // Pointer: *mut T
  if (c == 42) { // '*'
    let afterStar = k + 1;
    // Check for 'mut' keyword
    let mutPos = skip_ws(src, afterStar);
    if (mutPos + 2 < stringLen(src) &&
        stringCharCodeAt(src, mutPos) == 109 &&     // 'm'
        stringCharCodeAt(src, mutPos + 1) == 117 && // 'u'
        stringCharCodeAt(src, mutPos + 2) == 116) { // 't'
      // Ensure 'mut' is not part of a longer identifier
      let afterMut = mutPos + 3;
      if (afterMut >= stringLen(src) || !is_ident_part(stringCharCodeAt(src, afterMut))) {
        // It's *mut T - parse inner type recursively
        let inner = parse_type_expr(src, afterMut);
        let base = "*mut " + inner.v0;
        // Check for !drop suffix
        let drop = parse_drop_suffix(src, inner.v1);
        if (drop.hasIt) {
          yield ParsedType(base + "!" + drop.name, drop.nextPos);
        }
        yield ParsedType(base, inner.v1);
      }
    }
    // Fall through to slice syntax: *[T]
    k = k + 1;
    k = parse_keyword(src, k, "[");
    let inner = parse_type_expr(src, k);
    k = inner.v1;
    k = parse_keyword(src, k, "]");
    let base = "*[" + inner.v0 + "]";
    // Check for !drop suffix
    let drop = parse_drop_suffix(src, k);
    if (drop.hasIt) {
      yield ParsedType(base + "!" + drop.name, drop.nextPos);
    }
    yield ParsedType(base, k);
  }

  // Array: [T; N; M]
  if (c == 91) { // '['
    k = parse_keyword(src, k, "[");
    let inner = parse_type_expr(src, k);
    k = inner.v1;
    let mut sizes = "";
    while (true) {
      let t = skip_ws(src, k);
      if (!(t < stringLen(src) && stringCharCodeAt(src, t) == 59)) { break; } // ';'
      let n = parse_number(src, t + 1);
      sizes = sizes + ";" + ("" + n.value);
      k = n.nextPos;
    }
    k = parse_keyword(src, k, "]");
    let base = "[" + inner.v0 + sizes + "]";
    // Check for !drop suffix
    let drop = parse_drop_suffix(src, k);
    if (drop.hasIt) {
      yield ParsedType(base + "!" + drop.name, drop.nextPos);
    }
    yield ParsedType(base, k);
  }

  // Tuple / function type: (T, U) or (T, U) => R
  if (c == 40) { // '('
    k = parse_keyword(src, k, "(");
    k = skip_ws(src, k);
    let mut parts = "";
    let mut first = true;
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
      k = k + 1;
    } else {
      while (true) {
        let t1 = parse_type_expr(src, k);
        k = t1.v1;
        if (first) { parts = parts + t1.v0; } else { parts = parts + ", " + t1.v0; }
        first = false;
        k = skip_ws(src, k);
        if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in type"); }
        let ch = stringCharCodeAt(src, k);
        if (ch == 44) { // ','
          k = k + 1;
          continue;
        }
        if (ch == 41) { // ')'
          k = k + 1;
          break;
        }
        panic_at(src, k, "expected ',' or ')' in type");
      }
    }

    let t2 = skip_ws(src, k);
    if (t2 + 1 < stringLen(src) && stringCharCodeAt(src, t2) == 61 && stringCharCodeAt(src, t2 + 1) == 62) { // '=>'
      let ret = parse_type_expr(src, t2 + 2);
      let base = "(" + parts + ") => " + ret.v0;
      // Check for !drop suffix
      let drop = parse_drop_suffix(src, ret.v1);
      if (drop.hasIt) {
        yield ParsedType(base + "!" + drop.name, drop.nextPos);
      }
      yield ParsedType(base, ret.v1);
    }
    let base = "(" + parts + ")";
    // Check for !drop suffix
    let drop = parse_drop_suffix(src, k);
    if (drop.hasIt) {
      yield ParsedType(base + "!" + drop.name, drop.nextPos);
    }
    yield ParsedType(base, k);
  }

  // Name / generic: Ident or Ident<...>
  let name = parse_ident(src, k);
  k = name.nextPos;
  let mut out = name.text;

  if (name.text == "Any") {
    panic_at(src, name.startPos, "type 'Any' is unsupported");
  }

  let t3 = skip_ws(src, k);
  if (t3 < stringLen(src) && stringCharCodeAt(src, t3) == 60) { // '<'
    k = parse_keyword(src, t3, "<");
    let mut args = "";
    let mut firstArg = true;
    while (true) {
      let a = parse_type_expr(src, k);
      k = a.v1;
      if (firstArg) { args = args + a.v0; } else { args = args + ", " + a.v0; }
      firstArg = false;
      k = skip_ws(src, k);
      if (!(k < stringLen(src))) { panic_at(src, k, "expected '>' in generic type"); }
      let ch = stringCharCodeAt(src, k);
      if (ch == 44) { // ','
        k = k + 1;
        continue;
      }
      if (ch == 62) { // '>'
        k = k + 1;
        break;
      }
      panic_at(src, k, "expected ',' or '>' in generic type");
    }
    out = out + "<" + args + ">";
  }

  // Check for !drop suffix
  let drop = parse_drop_suffix(src, k);
  if (drop.hasIt) {
    yield ParsedType(out + "!" + drop.name, drop.nextPos);
  }

  ParsedType(out, k)
}

fn skip_type_expr(src: String, i: I32) : I32 => {
  // Skip a type expression in places where we don't need semantics yet.
  // Stops before ',', ';', or '}' when not inside angle brackets.
  let mut k = skip_ws(src, i);
  let mut depth = 0;
  while (k < stringLen(src)) {
    let ch = stringCharCodeAt(src, k);
    if (ch == 60) { depth = depth + 1; k = k + 1; continue; } // '<'
    if (ch == 62) { // '>'
      if (depth > 0) { depth = depth - 1; }
      k = k + 1;
      continue;
    }
    if (depth == 0 && (ch == 44 || ch == 59 || ch == 125)) { yield k; } // ',', ';', '}'
    k = k + 1;
  }
  panic_at(src, k, "unterminated type")
}
