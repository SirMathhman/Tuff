// Selfhost compiler: expression + statement parsing helpers.
// Extracted from tuffc_lib.tuff as part of Phase 2 (mechanical split).

extern from rt::stdlib use { panic, stringLen, stringSlice, stringCharCodeAt, stringFromCharCode };
extern from rt::vec use { vec_new, vec_push, vec_len, vec_get };

from util::diagnostics use {
  panic_at,
  panic_at_help,
  find_struct_fields,
  is_identifier_too_short,
  warn_short_identifier
};

from util::lexing use {
  is_digit,
  is_ident_start,
  is_ident_part,
  skip_ws,
  starts_with_at
};

from parsing::primitives use {
  ParsedBool,
  ParsedIdent,
  ParsedNumber,
  parse_ident,
  parse_keyword,
  parse_number,
  parse_optional_semicolon
};

from parsing::types use { parse_type_expr };

from ast use {
  span,
  span_start,
  expr_span,

  // Expr constructors
  expr_undefined,
  expr_int,
  expr_float,
  expr_bool,
  expr_string,
  expr_ident,
  expr_path,
  expr_lambda,
  expr_struct_lit,
  expr_unary,
  expr_binary,
  expr_call,
  expr_if,
  expr_block,
  expr_vec_lit,
  expr_tuple_lit,
  expr_index,
  expr_tuple_index,
  expr_field,
  expr_match,

  // Ops
  OpOr,
  OpAnd,
  OpEq,
  OpNe,
  OpLt,
  OpLe,
  OpGt,
  OpGe,
  OpAdd,
  OpSub,
  OpMul,
  OpDiv,
  OpNot,
  OpNeg,

  // Match constructors
  mk_match_arm,
  pat_wildcard,
  pat_int,
  pat_bool,
  pat_string,

  // Stmt constructors
  stmt_let,
  stmt_let_typed,
  stmt_assign,
  stmt_expr,
  stmt_yield,
  stmt_while,
  stmt_if,
  stmt_index_assign,
  stmt_field_assign
};

class fn ParsedExpr(v0: String, v1: I32) => {}
class fn ParsedMain(body: String, expr: String, v1: I32) => {}
class fn ParsedStmt(v0: String, v1: I32) => {}
class fn ParsedParams(v0: String, v1: I32) => {}

// Phase 3: canonical AST parser outputs
// NOTE: Avoid type aliases in signatures (type aliases are not runtime exports).
class fn ParsedExprAst(expr, nextPos: I32) => {}
class fn ParsedMainAst(body, tail, nextPos: I32) => {}
class fn ParsedStmtAst(stmt, nextPos: I32) => {}
class fn ParsedStmtsAst(stmts, nextPos: I32) => {}
class fn ParsedExprListAst(items, nextPos: I32) => {}

fn find_matching_rparen(src: String, openPos: I32) : I32 => {
  // Returns the index of the ')' that closes the '(' at openPos, or -1.
  // This is used only for lambda disambiguation.
  let mut i = openPos;
  let mut depth = 0;
  while (i < stringLen(src)) {
    let ch = stringCharCodeAt(src, i);

    // Skip string literals (minimal escape handling).
    if (ch == 34) { // '"'
      i = i + 1;
      while (i < stringLen(src)) {
        let c = stringCharCodeAt(src, i);
        if (c == 92) { // '\\'
          i = i + 2;
          continue;
        }
        if (c == 34) { i = i + 1; break; }
        i = i + 1;
      }
      continue;
    }

    // Skip char literals (minimal escape handling).
    if (ch == 39) { // '\''
      i = i + 1;
      while (i < stringLen(src)) {
        let c = stringCharCodeAt(src, i);
        if (c == 92) { // '\\'
          i = i + 2;
          continue;
        }
        if (c == 39) { i = i + 1; break; }
        i = i + 1;
      }
      continue;
    }

    if (ch == 40) { // '('
      depth = depth + 1;
      i = i + 1;
      continue;
    }
    if (ch == 41) { // ')'
      depth = depth - 1;
      if (depth == 0) { yield i; }
      i = i + 1;
      continue;
    }

    i = i + 1;
  }
  -1
}

// Lambda params list parser is only used when we've already determined this is
// a lambda expression (see `parse_primary_ast` disambiguation).
fn parse_lambda_expr_ast(src: String, i: I32) : ParsedExprAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "(");
  k = skip_ws(src, k);

  let params = vec_new();
  let paramTyAnns = vec_new();

  // Empty param list: ()
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
    k = k + 1;
  } else {
    // One or more params: name (':' Type)?
    while (true) {
      let name = parse_ident(src, k);
      vec_push(params, name.text);
      k = skip_ws(src, name.nextPos);

      // Optional parameter type annotation.
      let mut tyAnn = "";
      if (k < stringLen(src) && stringCharCodeAt(src, k) == 58) { // ':'
        k = parse_keyword(src, k, ":");
        let ty = parse_type_expr(src, k);
        tyAnn = ty.v0;
        k = ty.v1;
      }
      vec_push(paramTyAnns, tyAnn);
      k = skip_ws(src, k);

      if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in lambda params"); }
      let ch = stringCharCodeAt(src, k);
      if (ch == 44) { // ','
        k = k + 1;
        k = skip_ws(src, k);
        // Allow trailing comma: (a: I32,)
        if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
          k = k + 1;
          break;
        }
        continue;
      }
      if (ch == 41) { // ')'
        k = k + 1;
        break;
      }
      panic_at(src, k, "expected ',' or ')' in lambda params")
    }
  }

  // Optional return type annotation: `: Type`
  k = skip_ws(src, k);
  let mut retTyAnn = "";
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 58) { // ':'
    k = parse_keyword(src, k, ":");
    let ret = parse_type_expr(src, k);
    retTyAnn = ret.v0;
    k = ret.v1;
  }

  k = parse_keyword(src, k, "=>");

  let t = skip_ws(src, k);
  let body = if (t < stringLen(src) && stringCharCodeAt(src, t) == 123) parse_block_expr_ast(src, k) else parse_expr_ast(src, k);
  ParsedExprAst(expr_lambda(span(start, body.nextPos), params, paramTyAnns, retTyAnn, body.expr), body.nextPos)
}

fn parse_expr(src: String, i: I32) : ParsedExpr => parse_or(src, i)

// ------------------------------------------------------------
// AST path (Phase 3)
// ------------------------------------------------------------

fn parse_expr_ast(src: String, i: I32) : ParsedExprAst => parse_or_ast(src, i)

fn parse_or_ast(src: String, i: I32) : ParsedExprAst => {
  let mut left = parse_and_ast(src, i);
  let mut j = left.nextPos;
  while (true) {
    j = skip_ws(src, j);
    if (!(j + 1 < stringLen(src))) { break; }
    if (stringCharCodeAt(src, j) == 124 && stringCharCodeAt(src, j + 1) == 124) { // '||'
      let rhs = parse_and_ast(src, j + 2);
      let start = span_start(expr_span(left.expr));
      left = ParsedExprAst(expr_binary(span(start, rhs.nextPos), OpOr, left.expr, rhs.expr), rhs.nextPos);
      j = left.nextPos;
      continue;
    }
    break;
  }
  left
}

fn parse_and_ast(src: String, i: I32) : ParsedExprAst => {
  let mut left = parse_cmp_ast(src, i);
  let mut j = left.nextPos;
  while (true) {
    j = skip_ws(src, j);
    if (!(j + 1 < stringLen(src))) { break; }
    if (stringCharCodeAt(src, j) == 38 && stringCharCodeAt(src, j + 1) == 38) { // '&&'
      let rhs = parse_cmp_ast(src, j + 2);
      let start = span_start(expr_span(left.expr));
      left = ParsedExprAst(expr_binary(span(start, rhs.nextPos), OpAnd, left.expr, rhs.expr), rhs.nextPos);
      j = left.nextPos;
      continue;
    }
    break;
  }
  left
}

fn parse_cmp_ast(src: String, i: I32) : ParsedExprAst => {
  let mut left = parse_add_ast(src, i);
  let mut j = left.nextPos;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }

    let c0 = stringCharCodeAt(src, j);
    let c1 = if (j + 1 < stringLen(src)) stringCharCodeAt(src, j + 1) else 0;

    let mut opTag = "";
    let mut op = OpEq;
    let mut adv = 0;

    if (c0 == 61 && c1 == 61) { opTag = "=="; op = OpEq; adv = 2; }
    if (opTag == "" && c0 == 33 && c1 == 61) { opTag = "!="; op = OpNe; adv = 2; }
    if (opTag == "" && c0 == 60 && c1 == 61) { opTag = "<="; op = OpLe; adv = 2; }
    if (opTag == "" && c0 == 62 && c1 == 61) { opTag = ">="; op = OpGe; adv = 2; }
    if (opTag == "" && c0 == 60) { opTag = "<"; op = OpLt; adv = 1; }
    if (opTag == "" && c0 == 62) { opTag = ">"; op = OpGt; adv = 1; }

    if (opTag == "") { break; }

    let rhs = parse_add_ast(src, j + adv);
    let start = span_start(expr_span(left.expr));
    left = ParsedExprAst(expr_binary(span(start, rhs.nextPos), op, left.expr, rhs.expr), rhs.nextPos);
    j = left.nextPos;
  }
  left
}

fn parse_add_ast(src: String, i: I32) : ParsedExprAst => {
  let mut left = parse_mul_ast(src, i);
  let mut j = left.nextPos;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }
    let ch = stringCharCodeAt(src, j);
    if (!(ch == 43 || ch == 45)) { break; } // '+' or '-'
    let rhs = parse_mul_ast(src, j + 1);
    let op = if (ch == 43) OpAdd else OpSub;
    let start = span_start(expr_span(left.expr));
    left = ParsedExprAst(expr_binary(span(start, rhs.nextPos), op, left.expr, rhs.expr), rhs.nextPos);
    j = left.nextPos;
  }
  left
}

fn parse_mul_ast(src: String, i: I32) : ParsedExprAst => {
  let mut left = parse_unary_ast(src, i);
  let mut j = left.nextPos;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }
    let ch = stringCharCodeAt(src, j);
    if (!(ch == 42 || ch == 47)) { break; } // '*' or '/'
    let rhs = parse_unary_ast(src, j + 1);
    let op = if (ch == 42) OpMul else OpDiv;
    let start = span_start(expr_span(left.expr));
    left = ParsedExprAst(expr_binary(span(start, rhs.nextPos), op, left.expr, rhs.expr), rhs.nextPos);
    j = left.nextPos;
  }
  left
}

fn parse_unary_ast(src: String, i: I32) : ParsedExprAst => {
  let j = skip_ws(src, i);
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 33) { // '!'
    let inner = parse_unary_ast(src, j + 1);
    yield ParsedExprAst(expr_unary(span(j, inner.nextPos), OpNot, inner.expr), inner.nextPos);
  }
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 45) { // '-'
    let inner = parse_unary_ast(src, j + 1);
    yield ParsedExprAst(expr_unary(span(j, inner.nextPos), OpNeg, inner.expr), inner.nextPos);
  }
  parse_postfix_ast(src, i)
}

fn parse_postfix_ast(src: String, i: I32) : ParsedExprAst => {
  let mut left = parse_primary_ast(src, i);
  let mut j = left.nextPos;
  while (true) {
    j = skip_ws(src, j);

    // Generic call sugar: f<T>(...) or obj.f<T>(...).
    if (j < stringLen(src) && stringCharCodeAt(src, j) == 60) { // '<'
      let skipped = try_skip_type_args_for_call(src, j);
      if (skipped.ok) { j = skipped.nextPos; continue; }
    }

    if (j < stringLen(src) && stringCharCodeAt(src, j) == 40) { // '('
      let args = parse_arg_list_ast(src, j);
      let start = span_start(expr_span(left.expr));
      left = ParsedExprAst(expr_call(span(start, args.nextPos), left.expr, args.items), args.nextPos);
      j = left.nextPos;
      continue;
    }

    if (j < stringLen(src) && stringCharCodeAt(src, j) == 46) { // '.'
      let t = skip_ws(src, j + 1);
      if (t < stringLen(src) && is_digit(stringCharCodeAt(src, t))) {
        let n = parse_number(src, t);
        let start = span_start(expr_span(left.expr));
        left = ParsedExprAst(expr_tuple_index(span(start, n.nextPos), left.expr, n.value), n.nextPos);
        j = left.nextPos;
        continue;
      }
      let next = parse_ident(src, j + 1);
      let start = span_start(expr_span(left.expr));
      left = ParsedExprAst(expr_field(span(start, next.nextPos), left.expr, next.text), next.nextPos);
      j = left.nextPos;
      continue;
    }

    if (j < stringLen(src) && stringCharCodeAt(src, j) == 91) { // '['
      let mut k = parse_keyword(src, j, "[");
      let idx = parse_expr_ast(src, k);
      k = idx.nextPos;
      k = skip_ws(src, k);
      if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 93)) { panic("expected ']'"); }
      let start = span_start(expr_span(left.expr));
      left = ParsedExprAst(expr_index(span(start, k + 1), left.expr, idx.expr), k + 1);
      j = left.nextPos;
      continue;
    }

    break;
  }
  left
}

fn parse_arg_list_ast(src: String, i: I32) : ParsedExprListAst => {
  // parses: '(' (expr (',' expr)*)? ')'
  let mut k = skip_ws(src, i);
  k = parse_keyword(src, k, "(");
  k = skip_ws(src, k);

  let items = vec_new();
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
    yield ParsedExprListAst(items, k + 1);
  }

  while (true) {
    let e = parse_expr_ast(src, k);
    vec_push(items, e.expr);
    k = skip_ws(src, e.nextPos);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in arg list"); }
    let c = stringCharCodeAt(src, k);
    if (c == 44) { k = k + 1; k = skip_ws(src, k); continue; }
    if (c == 41) { yield ParsedExprListAst(items, k + 1); }
    panic_at(src, k, "expected ',' or ')' in arg list")
  }
  ParsedExprListAst(items, k)
}

fn parse_string_lit_value(src: String, startQuote: I32) : ParsedIdent => {
  // Returns ParsedIdent(text=value, startPos=startQuote, nextPos=endPosAfterQuote)
  // NOTE: We reuse ParsedIdent for convenience.
  let mut k = startQuote + 1;
  let mut out = "";
  while (k < stringLen(src)) {
    let ch = stringCharCodeAt(src, k);
    if (ch == 34) { // '"'
      yield ParsedIdent(out, startQuote, k + 1);
    }
    if (ch == 92) { // '\\'
      k = k + 1;
      if (!(k < stringLen(src))) { panic_at(src, startQuote, "unterminated string"); }
      let esc = stringCharCodeAt(src, k);
      let code = match (esc) {
        110 => 10, // n
        114 => 13, // r
        116 => 9,  // t
        48 => 0,   // 0
        92 => 92,  // \\
        34 => 34,  // "
        _ => esc
      };
      out = out + stringFromCharCode(code);
      k = k + 1;
      continue;
    }
    out = out + stringFromCharCode(ch);
    k = k + 1;
  }
  panic_at(src, startQuote, "unterminated string")
}

fn parse_vec_lit_ast(src: String, i: I32) : ParsedExprAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "[");
  k = skip_ws(src, k);
  let items = vec_new();
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 93) { // ']'
    yield ParsedExprAst(expr_vec_lit(span(start, k + 1), items), k + 1);
  }
  while (true) {
    let e = parse_expr_ast(src, k);
    vec_push(items, e.expr);
    k = skip_ws(src, e.nextPos);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ']' in vec literal"); }
    let ch = stringCharCodeAt(src, k);
    if (ch == 44) { k = k + 1; continue; }
    if (ch == 93) { yield ParsedExprAst(expr_vec_lit(span(start, k + 1), items), k + 1); }
    panic_at(src, k, "expected ',' or ']' in vec literal")
  }
  ParsedExprAst(expr_vec_lit(span(start, k), items), k)
}

fn parse_stmt_block_ast(src: String, i: I32) : ParsedStmtsAst => {
  let mut k = skip_ws(src, i);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 123)) { panic_at(src, k, "expected '{'"); }
  k = k + 1;

  let body = vec_new();
  while (true) {
    let t = skip_ws(src, k);
    if (!(t < stringLen(src))) { panic_at(src, t, "expected '}'"); }
    if (stringCharCodeAt(src, t) == 125) { yield ParsedStmtsAst(body, t + 1); }
    let st = parse_stmt_ast(src, k);
    vec_push(body, st.stmt);
    k = st.nextPos;
  }
  ParsedStmtsAst(body, k)
}

fn parse_block_body_ast(src: String, i: I32) : ParsedMainAst => {
  let j = skip_ws(src, i);
  if (!(j < stringLen(src) && stringCharCodeAt(src, j) == 123)) { panic_at(src, j, "expected '{'"); }

  let mut k = j + 1;
  let body = vec_new();

  while (true) {
    let t = skip_ws(src, k);
    if (!(t < stringLen(src))) { panic_at(src, t, "expected '}'"); }
    if (stringCharCodeAt(src, t) == 125) { break; }

    let isStmt = starts_with_at(src, t, "let") || starts_with_at(src, t, "while") || starts_with_at(src, t, "if") || starts_with_at(src, t, "yield") || is_field_assign_stmt_start(src, t) || is_assign_stmt_start(src, t) || is_index_assign_stmt_start(src, t);
    if (isStmt) {
      let st = parse_stmt_ast(src, k);
      vec_push(body, st.stmt);
      k = st.nextPos;
      continue;
    }

    // expression statement vs tail expression
    let e = parse_expr_ast(src, k);
    let after = skip_ws(src, e.nextPos);
    if (after < stringLen(src) && stringCharCodeAt(src, after) == 59) {
      vec_push(body, stmt_expr(span(span_start(expr_span(e.expr)), after + 1), e.expr));
      k = after + 1;
      continue;
    }
    if (after < stringLen(src) && stringCharCodeAt(src, after) != 125) {
      vec_push(body, stmt_expr(span(span_start(expr_span(e.expr)), e.nextPos), e.expr));
      k = e.nextPos;
      continue;
    }
    break;
  }

  let t2 = skip_ws(src, k);
  if (t2 < stringLen(src) && stringCharCodeAt(src, t2) == 125) {
    yield ParsedMainAst(body, expr_undefined(span(t2, t2)), t2 + 1);
  }

  let tail = parse_expr_ast(src, k);
  k = skip_ws(src, tail.nextPos);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 125)) { panic_at(src, k, "expected '}'"); }
  ParsedMainAst(body, tail.expr, k + 1)
}

fn parse_block_expr_ast(src: String, i: I32) : ParsedExprAst => {
  let start = skip_ws(src, i);
  let b = parse_block_body_ast(src, start);
  ParsedExprAst(expr_block(span(start, b.nextPos), b.body, b.tail), b.nextPos)
}

fn parse_if_expr_ast(src: String, i: I32) : ParsedExprAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "if");
  k = parse_keyword(src, k, "(");
  let cond = parse_expr_ast(src, k);
  k = cond.nextPos;
  k = parse_keyword(src, k, ")");
  let t1 = skip_ws(src, k);
  let thenE = if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 123) parse_block_expr_ast(src, k) else parse_expr_ast(src, k);
  k = thenE.nextPos;
  k = parse_keyword(src, k, "else");
  let t2 = skip_ws(src, k);
  let elseE = if (t2 < stringLen(src) && stringCharCodeAt(src, t2) == 123) parse_block_expr_ast(src, k) else parse_expr_ast(src, k);
  ParsedExprAst(expr_if(span(start, elseE.nextPos), cond.expr, thenE.expr, elseE.expr), elseE.nextPos)
}

fn parse_match_expr_ast(src: String, i: I32) : ParsedExprAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "match");
  k = parse_keyword(src, k, "(");
  let scrut = parse_expr_ast(src, k);
  k = scrut.nextPos;
  k = parse_keyword(src, k, ")");
  k = parse_keyword(src, k, "{");

  let arms = vec_new();
  let mut sawDefault = false;

  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
    if (stringCharCodeAt(src, k) == 125) { k = k + 1; break; }

    let patStart = k;
    let c0 = stringCharCodeAt(src, k);
    let mut pat = pat_wildcard(span(patStart, patStart));

    if (c0 == 34) {
      let lit = parse_string_lit_value(src, k);
      pat = pat_string(span(patStart, lit.nextPos), lit.text);
      k = lit.nextPos;
    } else {
      if (is_digit(c0)) {
        let n = parse_number(src, k);
        pat = pat_int(span(patStart, n.nextPos), n.value);
        k = n.nextPos;
      } else {
        let id = parse_ident(src, k);
        k = id.nextPos;
        if (id.text == "_") {
          pat = pat_wildcard(span(patStart, k));
        } else {
          if (id.text == "true") {
            pat = pat_bool(span(patStart, k), true);
          } else {
            if (id.text == "false") {
              pat = pat_bool(span(patStart, k), false);
            } else {
              panic_at(src, patStart, "unsupported match pattern: " + id.text);
            }
          }
        }
      }
    }

    k = parse_keyword(src, k, "=>");
    let t = skip_ws(src, k);
    let armE = if (t < stringLen(src) && stringCharCodeAt(src, t) == 123) parse_block_expr_ast(src, k) else parse_expr_ast(src, k);
    k = armE.nextPos;

    if (pat.tag == "MPWildcard") { sawDefault = true; }
    vec_push(arms, mk_match_arm(span(patStart, armE.nextPos), pat, armE.expr));

    k = skip_ws(src, k);
    if (k < stringLen(src)) {
      let ch = stringCharCodeAt(src, k);
      if (ch == 44 || ch == 59) { k = k + 1; }
    }
  }

  if (!sawDefault) { panic_at(src, k, "match requires _ arm"); }
  ParsedExprAst(expr_match(span(start, k), scrut.expr, arms), k)
}

fn parse_primary_ast(src: String, i: I32) : ParsedExprAst => {
  let j = skip_ws(src, i);
  if (!(j < stringLen(src))) { panic_at(src, j, "expected expression"); }
  let c = stringCharCodeAt(src, j);

  if (starts_with_at(src, j, "if")) { yield parse_if_expr_ast(src, j); }
  if (starts_with_at(src, j, "match")) { yield parse_match_expr_ast(src, j); }
  if (c == 91) { yield parse_vec_lit_ast(src, j); }
  if (c == 123) { yield parse_block_expr_ast(src, j); }

  if (c == 39) { // char literal
    let start = j;
    let mut k = j + 1;
    if (!(k < stringLen(src))) { panic_at(src, start, "unterminated char literal"); }
    let mut code: I32 = 0;
    let ch0 = stringCharCodeAt(src, k);
    if (ch0 == 92) {
      k = k + 1;
      if (!(k < stringLen(src))) { panic_at(src, start, "unterminated char escape"); }
      let esc = stringCharCodeAt(src, k);
      code = match (esc) {
        110 => 10,
        114 => 13,
        116 => 9,
        48 => 0,
        92 => 92,
        39 => 39,
        34 => 34,
        _ => { panic_at(src, k, "unknown char escape"); 0 }
      };
      k = k + 1;
    } else {
      code = ch0;
      k = k + 1;
    }
    if (!(k < stringLen(src))) { panic_at(src, start, "unterminated char literal"); }
    if (stringCharCodeAt(src, k) != 39) { panic_at(src, start, "char literal must contain exactly one character"); }
    yield ParsedExprAst(expr_int(span(start, k + 1), code), k + 1);
  }

  if (c == 34) { // string literal
    let lit = parse_string_lit_value(src, j);
    yield ParsedExprAst(expr_string(span(j, lit.nextPos), lit.text), lit.nextPos);
  }

  if (c == 40) { // '('
    // Disambiguate lambdas from parenthesized expressions / tuples.
    // Lambdas are recognized by what comes *after* the matching ')':
    //   (params) => body
    //   (params) : Ret => body
    let rp = find_matching_rparen(src, j);
    if (rp != -1) {
      let after = skip_ws(src, rp + 1);
      // '=>'
      if (after + 1 < stringLen(src) && stringCharCodeAt(src, after) == 61 && stringCharCodeAt(src, after + 1) == 62) {
        yield parse_lambda_expr_ast(src, j);
      }
      // ':' (optional return annotation) followed by '=>'
      if (after < stringLen(src) && stringCharCodeAt(src, after) == 58) {
        yield parse_lambda_expr_ast(src, j);
      }
    }

    let first = parse_expr_ast(src, j + 1);
    let mut k = skip_ws(src, first.nextPos);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) {
      yield ParsedExprAst(first.expr, k + 1);
    }
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 44) {
      let items = vec_new();
      vec_push(items, first.expr);
      while (true) {
        k = k + 1;
        k = skip_ws(src, k);
        if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) {
          yield ParsedExprAst(expr_tuple_lit(span(j, k + 1), items), k + 1);
        }
        let e = parse_expr_ast(src, k);
        vec_push(items, e.expr);
        k = skip_ws(src, e.nextPos);
        if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in tuple literal"); }
        let ch = stringCharCodeAt(src, k);
        if (ch == 44) { continue; }
        if (ch == 41) { yield ParsedExprAst(expr_tuple_lit(span(j, k + 1), items), k + 1); }
        panic_at(src, k, "expected ',' or ')' in tuple literal")
      }
    }
    panic_at_help(src, k, "expected ')'", "Add ')' to close the opening '('.")
  }

  if (is_digit(c)) {
    // Float literal: <digits> '.' <digits> [F32|F64]
    // Parse this before falling back to integer parsing so `2.0` doesn't get
    // interpreted as tuple indexing on the integer literal `2`.
    let mut k = j;
    while (k < stringLen(src) && is_digit(stringCharCodeAt(src, k))) {
      k = k + 1;
    }
    if (k + 1 < stringLen(src) && stringCharCodeAt(src, k) == 46 && is_digit(stringCharCodeAt(src, k + 1))) { // '.'
      let mut m = k + 1;
      while (m < stringLen(src) && is_digit(stringCharCodeAt(src, m))) {
        m = m + 1;
      }
      let text = stringSlice(src, j, m);
      
      // Check for optional suffix (F32 or F64)
      let mut suffix = "";
      let mut endPos = m;
      if (m + 2 < stringLen(src)) {
        let s1 = stringSlice(src, m, m + 3);
        if (s1 == "F32") {
          suffix = "F32";
          endPos = m + 3;
        } else {
          if (s1 == "F64") {
            suffix = "F64";
            endPos = m + 3;
          }
        }
      }
      
      yield ParsedExprAst(expr_float(span(j, endPos), text, suffix), endPos);
    }

    let n = parse_number(src, j);
    yield ParsedExprAst(expr_int(span(j, n.nextPos), n.value), n.nextPos);
  }

  if (is_ident_start(c)) {
    let id = parse_ident(src, j);
    let mut k = id.nextPos;

    // module path: A::B::C
    let parts = vec_new();
    vec_push(parts, id.text);
    while (true) {
      let t = skip_ws(src, k);
      if (!(t + 1 < stringLen(src))) { break; }
      if (!(stringCharCodeAt(src, t) == 58 && stringCharCodeAt(src, t + 1) == 58)) { break; }
      let next = parse_ident(src, t + 2);
      vec_push(parts, next.text);
      k = next.nextPos;
    }

    // Struct literal: Name { <expr>, ... }
    let t2 = skip_ws(src, k);
    if (t2 < stringLen(src) && stringCharCodeAt(src, t2) == 123) {
      let vals = parse_struct_lit_values_ast(src, t2);
      let nameExpr = expr_path(span(j, k), parts);
      yield ParsedExprAst(expr_struct_lit(span(j, vals.nextPos), nameExpr, vals.items), vals.nextPos);
    }

    // Plain identifier or module path
    if (vec_len(parts) == 1) {
      yield ParsedExprAst(expr_ident(span(j, k), vec_get(parts, 0)), k);
    }
    yield ParsedExprAst(expr_path(span(j, k), parts), k);
  }

  let mut end = j + 32;
  if (end > stringLen(src)) { end = stringLen(src); }
  panic_at(src, j, "expected expression near '" + stringSlice(src, j, end) + "'")
}

fn parse_struct_lit_values_ast(src: String, i: I32) : ParsedExprListAst => {
  // Parses: '{' (expr (',' expr)*)? '}'
  let mut k = skip_ws(src, i);
  k = parse_keyword(src, k, "{");
  k = skip_ws(src, k);
  let items = vec_new();
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 125) {
    yield ParsedExprListAst(items, k + 1);
  }
  while (true) {
    let e = parse_expr_ast(src, k);
    vec_push(items, e.expr);
    k = skip_ws(src, e.nextPos);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ',' or '}' in struct literal"); }
    let ch = stringCharCodeAt(src, k);
    if (ch == 44) { k = k + 1; continue; }
    if (ch == 125) { yield ParsedExprListAst(items, k + 1); }
    panic_at(src, k, "expected ',' or '}' in struct literal")
  }
  ParsedExprListAst(items, k)
}

fn parse_stmt_ast(src: String, i: I32) : ParsedStmtAst => {
  let mut k = skip_ws(src, i);
  let start = k;

  // yield / early return
  if (starts_with_at(src, k, "yield")) {
    k = parse_keyword(src, k, "yield");
    k = skip_ws(src, k);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 59) {
      yield ParsedStmtAst(stmt_yield(span(start, k + 1), expr_undefined(span(k, k))), k + 1);
    }
    let e = parse_expr_ast(src, k);
    k = parse_optional_semicolon(src, e.nextPos);
    yield ParsedStmtAst(stmt_yield(span(start, k), e.expr), k);
  }

  // let / let mut
  if (starts_with_at(src, k, "let")) {
    k = parse_keyword(src, k, "let");
    let mutOpt = parse_mut_opt(src, k);
    k = mutOpt.nextPos;
    let name = parse_ident(src, k);
    k = name.nextPos;
    if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }
    let mut tyAnn = "";
    let t0 = skip_ws(src, k);
    if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) {
      let _ty = parse_type_expr(src, t0 + 1);
      tyAnn = _ty.v0;
      k = _ty.v1;
    }
    k = parse_keyword(src, k, "=");
    let e = parse_expr_ast(src, k);
    k = parse_optional_semicolon(src, e.nextPos);
    if (tyAnn == "") {
      yield ParsedStmtAst(stmt_let(span(start, k), mutOpt.ok, name.text, e.expr), k);
    }
    yield ParsedStmtAst(stmt_let_typed(span(start, k), mutOpt.ok, name.text, tyAnn, e.expr), k);
  }

  // while (...) { ... }
  if (starts_with_at(src, k, "while")) {
    k = parse_keyword(src, k, "while");
    k = parse_keyword(src, k, "(");
    let cond = parse_expr_ast(src, k);
    k = parse_keyword(src, cond.nextPos, ")");
    let body = parse_stmt_block_ast(src, k);
    k = parse_optional_semicolon(src, body.nextPos);
    yield ParsedStmtAst(stmt_while(span(start, k), cond.expr, body.stmts), k);
  }

  // if (...) { ... } (else { ... })?
  if (starts_with_at(src, k, "if")) {
    k = parse_keyword(src, k, "if");
    k = parse_keyword(src, k, "(");
    let cond = parse_expr_ast(src, k);
    k = parse_keyword(src, cond.nextPos, ")");
    let thenB = parse_stmt_block_ast(src, k);
    k = thenB.nextPos;
    let j = skip_ws(src, k);
    if (starts_with_at(src, j, "else")) {
      k = parse_keyword(src, k, "else");
      let elseB = parse_stmt_block_ast(src, k);
      k = parse_optional_semicolon(src, elseB.nextPos);
      yield ParsedStmtAst(stmt_if(span(start, k), cond.expr, thenB.stmts, true, elseB.stmts), k);
    }
    k = parse_optional_semicolon(src, k);
    yield ParsedStmtAst(stmt_if(span(start, k), cond.expr, thenB.stmts, false, vec_new()), k);
  }

  // assignment: <ident> = <expr>;
  if (is_assign_stmt_start(src, k)) {
    let name = parse_ident(src, k);
    k = parse_keyword(src, name.nextPos, "=");
    let e = parse_expr_ast(src, k);
    k = parse_optional_semicolon(src, e.nextPos);
    yield ParsedStmtAst(stmt_assign(span(start, k), name.text, e.expr), k);
  }

  // field assignment: <ident>.<field>(.<field>)* = <expr>;
  if (is_field_assign_stmt_start(src, k)) {
    let base = parse_ident(src, k);
    k = base.nextPos;
    let fields = vec_new();
    while (true) {
      let t = skip_ws(src, k);
      if (!(t < stringLen(src) && stringCharCodeAt(src, t) == 46)) { break; }
      k = parse_keyword(src, k, ".");
      let part = parse_ident(src, k);
      vec_push(fields, part.text);
      k = part.nextPos;
    }
    k = parse_keyword(src, k, "=");
    let e = parse_expr_ast(src, k);
    k = parse_optional_semicolon(src, e.nextPos);
    let baseExpr = expr_ident(span(base.startPos, base.nextPos), base.text);
    yield ParsedStmtAst(stmt_field_assign(span(start, k), baseExpr, fields, e.expr), k);
  }

  // index assignment: <ident>[<expr>] = <expr>;
  if (is_index_assign_stmt_start(src, k)) {
    let name = parse_ident(src, k);
    k = parse_keyword(src, name.nextPos, "[");
    let idx = parse_expr_ast(src, k);
    k = parse_keyword(src, idx.nextPos, "]");
    k = parse_keyword(src, k, "=");
    let val = parse_expr_ast(src, k);
    k = parse_optional_semicolon(src, val.nextPos);
    let baseExpr = expr_ident(span(name.startPos, name.nextPos), name.text);
    yield ParsedStmtAst(stmt_index_assign(span(start, k), baseExpr, idx.expr, val.expr), k);
  }

  // expression statement
  let e = parse_expr_ast(src, k);
  k = parse_optional_semicolon(src, e.nextPos);
  ParsedStmtAst(stmt_expr(span(start, k), e.expr), k)
}

fn parse_main_body_ast(src: String, i: I32) : ParsedMainAst => {
  let j = skip_ws(src, i);
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 123) {
    let b = parse_block_body_ast(src, i);
    yield b;
  }
  let e = parse_expr_ast(src, i);
  ParsedMainAst(vec_new(), e.expr, e.nextPos)
}

fn parse_or(src: String, i: I32) : ParsedExpr => {
  let mut left = parse_and(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j + 1 < stringLen(src))) { break; }
    if (stringCharCodeAt(src, j) == 124 && stringCharCodeAt(src, j + 1) == 124) { // '||'
      let rhs = parse_and(src, j + 2);
      left = ParsedExpr("(" + left.v0 + " || " + rhs.v0 + ")", rhs.v1);
      j = left.v1;
      continue;
    }
    break;
  }
  left
}

fn parse_and(src: String, i: I32) : ParsedExpr => {
  let mut left = parse_cmp(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j + 1 < stringLen(src))) { break; }
    if (stringCharCodeAt(src, j) == 38 && stringCharCodeAt(src, j + 1) == 38) { // '&&'
      let rhs = parse_cmp(src, j + 2);
      left = ParsedExpr("(" + left.v0 + " && " + rhs.v0 + ")", rhs.v1);
      j = left.v1;
      continue;
    }
    break;
  }
  left
}

fn parse_cmp(src: String, i: I32) : ParsedExpr => {
  // comparisons: == != < <= > >=
  let mut left = parse_add(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }

    let c0 = stringCharCodeAt(src, j);
    let c1 = if (j + 1 < stringLen(src)) stringCharCodeAt(src, j + 1) else 0;

    let mut op = "";
    let mut adv = 0;

    // ==
    if (c0 == 61 && c1 == 61) { op = "=="; adv = 2; }
    // !=
    if (op == "" && c0 == 33 && c1 == 61) { op = "!="; adv = 2; }
    // <=
    if (op == "" && c0 == 60 && c1 == 61) { op = "<="; adv = 2; }
    // >=
    if (op == "" && c0 == 62 && c1 == 61) { op = ">="; adv = 2; }
    // <
    if (op == "" && c0 == 60) { op = "<"; adv = 1; }
    // >
    if (op == "" && c0 == 62) { op = ">"; adv = 1; }

    if (op == "") { break; }

    let rhs = parse_add(src, j + adv);
    left = ParsedExpr("(" + left.v0 + " " + op + " " + rhs.v0 + ")", rhs.v1);
    j = left.v1;
  }
  left
}

fn parse_add(src: String, i: I32) : ParsedExpr => {
  let mut left = parse_mul(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }
    let op = stringCharCodeAt(src, j);
    if (!(op == 43 || op == 45)) { break; } // '+' or '-'
    let rhs = parse_mul(src, j + 1);
    let opStr = if (op == 43) "+" else "-";
    left = ParsedExpr("(" + left.v0 + " " + opStr + " " + rhs.v0 + ")", rhs.v1);
    j = left.v1;
  }
  left
}

fn parse_mul(src: String, i: I32) : ParsedExpr => {
  let mut left = parse_unary(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }
    let op = stringCharCodeAt(src, j);
    if (!(op == 42 || op == 47)) { break; } // '*' or '/'
    let rhs = parse_unary(src, j + 1);
    let opStr = if (op == 42) "*" else "/";
    left = ParsedExpr("(" + left.v0 + " " + opStr + " " + rhs.v0 + ")", rhs.v1);
    j = left.v1;
  }
  left
}

fn parse_unary(src: String, i: I32) : ParsedExpr => {
  let j = skip_ws(src, i);
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 33) { // '!'
    let inner = parse_unary(src, j + 1);
    yield ParsedExpr("(!" + inner.v0 + ")", inner.v1);
  }
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 45) { // '-'
    let inner = parse_unary(src, j + 1);
    yield ParsedExpr("(-" + inner.v0 + ")", inner.v1);
  }
  parse_postfix(src, i)
}

fn parse_postfix(src: String, i: I32) : ParsedExpr => {
  let mut left = parse_primary(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);

    // Generic call sugar: f<T>(...) or obj.f<T>(...).
    // Only treat `<...>` as type args if it is balanced and followed by `(`.
    if (j < stringLen(src) && stringCharCodeAt(src, j) == 60) { // '<'
      let skipped = try_skip_type_args_for_call(src, j);
      if (skipped.ok) {
        j = skipped.nextPos;
        continue;
      }
    }

    if (j < stringLen(src) && stringCharCodeAt(src, j) == 40) { // '('
      let args = parse_arg_list(src, j);
      left = ParsedExpr(left.v0 + "(" + args.v0 + ")", args.v1);
      j = left.v1;
      continue;
    }
    if (j < stringLen(src) && stringCharCodeAt(src, j) == 46) { // '.'
      // tuple access: expr.0 => expr[0]
      let t = skip_ws(src, j + 1);
      if (t < stringLen(src) && is_digit(stringCharCodeAt(src, t))) {
        let n = parse_number(src, t);
        left = ParsedExpr(left.v0 + "[" + ("" + n.value) + "]", n.nextPos);
        j = left.v1;
        continue;
      }

      let next = parse_ident(src, j + 1);
      left = ParsedExpr(left.v0 + "." + next.text, next.nextPos);
      j = left.v1;
      continue;
    }
    if (j < stringLen(src) && stringCharCodeAt(src, j) == 91) { // '['
      let mut k = parse_keyword(src, j, "[");
      let idx = parse_expr(src, k);
      k = idx.v1;
      k = skip_ws(src, k);
      if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 93)) { panic("expected ']' "); }
      left = ParsedExpr("vec_get(" + left.v0 + ", " + idx.v0 + ")", k + 1);
      j = left.v1;
      continue;
    }
    break;
  }
  left
}

fn try_skip_type_args_for_call(src: String, i: I32) : ParsedBool => {
  // Returns ParsedBool(true, endIndexAfterGreaterThan) if `<...>` is balanced
  // and followed by `(` (after ws). Otherwise ParsedBool(false, i).
  let mut k = skip_ws(src, i);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 60)) { // '<'
    yield ParsedBool(false, i);
  }
  let mut p = k + 1;
  let mut depth = 1;
  while (p < stringLen(src)) {
    let ch = stringCharCodeAt(src, p);
    if (ch == 60) { depth = depth + 1; p = p + 1; continue; } // '<'
    if (ch == 62) { // '>'
      depth = depth - 1;
      p = p + 1;
      if (depth == 0) {
        let after = skip_ws(src, p);
        if (after < stringLen(src) && stringCharCodeAt(src, after) == 40) { // '('
          yield ParsedBool(true, p);
        }
        yield ParsedBool(false, i);
      }
      continue;
    }
    p = p + 1;
  }
  ParsedBool(false, i)
}

fn parse_arg_list(src: String, i: I32) : ParsedParams => {
  // parses: '(' (expr (',' expr)*)? ')'
  let mut k = skip_ws(src, i);
  k = parse_keyword(src, k, "(");

  k = skip_ws(src, k);
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
    yield ParsedParams("", k + 1);
  }

  let mut out = "";
  let mut first = true;
  while (true) {
    let e = parse_expr(src, k);
    k = e.v1;
    if (first) { out = out + e.v0; } else { out = out + ", " + e.v0; }
    first = false;

    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in arg list"); }
    let c = stringCharCodeAt(src, k);
    if (c == 44) { // ','
      k = k + 1;
      continue;
    }
    if (c == 41) { // ')'
      yield ParsedParams(out, k + 1);
    }
    panic_at(src, k, "expected ',' or ')' in arg list")
  }

  // unreachable
  ParsedParams(out, k)
}

fn parse_struct_lit(src: String, structName: String, i: I32) : ParsedExpr => {
  // Parses: '{' (expr (',' expr)*)? '}' and lowers using struct field order.
  let fields = find_struct_fields(structName);

  let mut k = skip_ws(src, i);
  k = parse_keyword(src, k, "{");

  let mut out = "({ ";
  let mut idx = 0;

  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}' in struct literal"); }
    if (stringCharCodeAt(src, k) == 125) { // '}'
      if (!(idx == vec_len(fields))) {
        panic_at(src, k, "wrong number of values in struct literal for " + structName);
      }
      yield ParsedExpr(out + " })", k + 1);
    }

    if (!(idx < vec_len(fields))) {
      panic_at(src, k, "too many values in struct literal for " + structName);
    }

    let e = parse_expr(src, k);
    k = e.v1;

    let fieldName = vec_get(fields, idx);
    if (idx == 0) { out = out + (fieldName + ": " + e.v0); }
    else { out = out + (", " + fieldName + ": " + e.v0); }
    idx = idx + 1;

    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ',' or '}' in struct literal"); }
    let ch = stringCharCodeAt(src, k);
    if (ch == 44) { // ','
      k = k + 1;
      continue;
    }
    if (ch == 125) { // '}'
      // next loop iteration will close and validate
      continue;
    }
    panic_at(src, k, "expected ',' or '}' in struct literal")
  }

  // unreachable
  ParsedExpr(out + " })", k)
}

fn parse_primary(src: String, i: I32) : ParsedExpr => {
  let j = skip_ws(src, i);
  if (!(j < stringLen(src))) { panic_at(src, j, "expected expression"); }
  let c = stringCharCodeAt(src, j);
  if (starts_with_at(src, j, "if")) {
    let ie = parse_if_expr(src, j);
    yield ie;
  }
  if (starts_with_at(src, j, "match")) {
    let me = parse_match_expr(src, j);
    yield me;
  }
  if (c == 91) { // '['
    let ve = parse_vec_lit(src, j);
    yield ve;
  }
  if (c == 123) { // '{'
    let be = parse_block_expr(src, j);
    yield be;
  }
  if (c == 39) { // '\''
    // Char literal: '\'' <char-or-escape> '\''
    // Lowered to a numeric code point for JS emission.
    let start = j;
    let mut k = j + 1;
    if (!(k < stringLen(src))) { panic_at(src, start, "unterminated char literal"); }

    let mut code: I32 = 0;
    let ch0 = stringCharCodeAt(src, k);
    if (ch0 == 92) { // '\\'
      // Escape sequence.
      k = k + 1;
      if (!(k < stringLen(src))) { panic_at(src, start, "unterminated char escape"); }
      let esc = stringCharCodeAt(src, k);
      code = match (esc) {
        110 => 10, // 'n'
        114 => 13, // 'r'
        116 => 9, // 't'
        48 => 0, // '0'
        92 => 92, // '\\'
        39 => 39, // '\''
        34 => 34, // '"'
        _ => { panic_at(src, k, "unknown char escape"); 0 }
      };
      k = k + 1;
    } else {
      // Single character.
      code = ch0;
      k = k + 1;
    }

    if (!(k < stringLen(src))) { panic_at(src, start, "unterminated char literal"); }
    if (stringCharCodeAt(src, k) != 39) {
      panic_at(src, start, "char literal must contain exactly one character");
    }
    yield ParsedExpr("" + code, k + 1);
  }
  if (c == 34) { // '"'
    let start = j;
    let mut k = j + 1;
    while (k < stringLen(src)) {
      let ch = stringCharCodeAt(src, k);
      if (ch == 34) { yield ParsedExpr(stringSlice(src, start, k + 1), k + 1); }
      if (ch == 92) { // '\\'
        k = k + 1;
        if (k < stringLen(src)) { k = k + 1; continue; }
        panic_at(src, start, "unterminated string");
      }
      k = k + 1;
    }
    panic_at(src, start, "unterminated string");
  }
  if (c == 40) { // '('
    let first = parse_expr(src, j + 1);
    let mut k = skip_ws(src, first.v1);

    // Parenthesized expression
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
      yield ParsedExpr("(" + first.v0 + ")", k + 1);
    }

    // Tuple literal: (a, b, ...)
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 44) { // ','
      let mut out = "[" + first.v0;
      while (true) {
        // consume ','
        k = k + 1;
        k = skip_ws(src, k);

        // allow trailing comma
        if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
          yield ParsedExpr(out + "]", k + 1);
        }

        let e = parse_expr(src, k);
        out = out + ", " + e.v0;
        k = skip_ws(src, e.v1);

        if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in tuple literal"); }
        let ch = stringCharCodeAt(src, k);
        if (ch == 44) { // ','
          continue;
        }
        if (ch == 41) { // ')'
          yield ParsedExpr(out + "]", k + 1);
        }
        panic_at(src, k, "expected ',' or ')' in tuple literal");
      }
    }

    panic_at(src, k, "expected ')'");
  }
  if (is_digit(c)) {
    let n = parse_number(src, j);
    yield ParsedExpr("" + n.value, n.nextPos);
  }
  if (is_ident_start(c)) {
    let id = parse_ident(src, j);
    let mut k = id.nextPos;
    let mut out = id.text;
    while (true) {
      let t = skip_ws(src, k);
      if (!(t + 1 < stringLen(src))) { break; }
      if (!(stringCharCodeAt(src, t) == 58 && stringCharCodeAt(src, t + 1) == 58)) { break; } // '::'
      let next = parse_ident(src, t + 2);
      out = out + "." + next.text;
      k = next.nextPos;
    }

    // Struct literal: Name { <expr>, ... }
    let t2 = skip_ws(src, k);
    if (t2 < stringLen(src) && stringCharCodeAt(src, t2) == 123) { // '{'
      let lit = parse_struct_lit(src, out, t2);
      yield lit;
    }

    yield ParsedExpr(out, k);
  }
  let mut end = j + 32;
  if (end > stringLen(src)) { end = stringLen(src); }
  panic_at(src, j, "expected expression near '" + stringSlice(src, j, end) + "'")
}

fn parse_vec_lit(src: String, i: I32) : ParsedExpr => {
  // vector literal: '[' (expr (',' expr)*)? ']'
  let mut k = parse_keyword(src, i, "[");
  k = skip_ws(src, k);
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 93) { // ']'
    yield ParsedExpr("(() => { const __v = vec_new(); return __v; })()", k + 1);
  }

  let mut pushes = "";
  while (true) {
    let e = parse_expr(src, k);
    k = e.v1;
    pushes = pushes + ("vec_push(__v, " + e.v0 + ");\n");
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ']' in vec literal"); }
    let ch = stringCharCodeAt(src, k);
    if (ch == 44) { // ','
      k = k + 1;
      continue;
    }
    if (ch == 93) { // ']'
      yield ParsedExpr("(() => { const __v = vec_new();\n" + pushes + "return __v;\n})()", k + 1);
    }
    panic_at(src, k, "expected ',' or ']' in vec literal")
  }
  // unreachable
  ParsedExpr("None", k)
}

fn parse_block_body(src: String, i: I32) : ParsedMain => {
  let j = skip_ws(src, i);
  if (!(j < stringLen(src) && stringCharCodeAt(src, j) == 123)) { panic_at(src, j, "expected '{'"); }

  let mut k = j + 1;
  let mut body = "";

  while (true) {
    let t = skip_ws(src, k);
    if (!(t < stringLen(src))) { panic_at(src, t, "expected '}'"); }
    if (stringCharCodeAt(src, t) == 125) { break; }

    let isStmt = starts_with_at(src, t, "let") || starts_with_at(src, t, "while") || starts_with_at(src, t, "if") || starts_with_at(src, t, "yield") || is_field_assign_stmt_start(src, t) || is_assign_stmt_start(src, t) || is_index_assign_stmt_start(src, t);
    if (isStmt) {
      let st = parse_stmt(src, k);
      body = body + st.v0;
      k = st.v1;
      continue;
    }

    // expression statement vs tail expression
    let e = parse_expr(src, k);
    let after = skip_ws(src, e.v1);
    if (after < stringLen(src) && stringCharCodeAt(src, after) == 59) {
      body = body + (e.v0 + ";\n");
      k = after + 1;
      continue;
    }
    // Without semicolons, treat the expression as a statement unless it ends the block.
    if (after < stringLen(src) && stringCharCodeAt(src, after) != 125) {
      body = body + (e.v0 + ";\n");
      k = e.v1;
      continue;
    }
    break;
  }

  // If the block is empty or ends with statements only, treat it as returning `undefined`.
  let t2 = skip_ws(src, k);
  if (t2 < stringLen(src) && stringCharCodeAt(src, t2) == 125) {
    yield ParsedMain(body, "undefined", t2 + 1);
  }

  let tail = parse_expr(src, k);
  k = skip_ws(src, tail.v1);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 125)) { panic_at(src, k, "expected '}'"); }
  ParsedMain(body, tail.v0, k + 1)
}

fn parse_block_expr(src: String, i: I32) : ParsedExpr => {
  let b = parse_block_body(src, i);
  ParsedExpr("(() => {\n" + b.body + "return " + b.expr + ";\n})()", b.v1)
}

fn parse_if_expr(src: String, i: I32) : ParsedExpr => {
  let mut k = parse_keyword(src, i, "if");
  k = parse_keyword(src, k, "(");
  let cond = parse_expr(src, k);
  k = cond.v1;
  k = parse_keyword(src, k, ")");
  let t1 = skip_ws(src, k);
  let thenE = if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 123) parse_block_expr(src, k) else parse_expr(src, k);
  k = thenE.v1;
  k = parse_keyword(src, k, "else");
  let t2 = skip_ws(src, k);
  let elseE = if (t2 < stringLen(src) && stringCharCodeAt(src, t2) == 123) parse_block_expr(src, k) else parse_expr(src, k);
  ParsedExpr("(" + cond.v0 + " ? " + thenE.v0 + " : " + elseE.v0 + ")", elseE.v1)
}

fn parse_match_expr(src: String, i: I32) : ParsedExpr => {
  let mut k = parse_keyword(src, i, "match");
  k = parse_keyword(src, k, "(");
  let scrut = parse_expr(src, k);
  k = scrut.v1;
  k = parse_keyword(src, k, ")");
  k = parse_keyword(src, k, "{");

  let mut cases = "";
  let mut def = "";

  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
    if (stringCharCodeAt(src, k) == 125) { k = k + 1; break; }

    // pattern: number | string | true/false | _
    let mut pat = "";
    let c0 = stringCharCodeAt(src, k);
    if (c0 == 34) { // string
      let lit = parse_primary(src, k);
      pat = lit.v0;
      k = lit.v1;
    } else {
      if (is_digit(c0)) {
        let n = parse_number(src, k);
        pat = "" + n.value;
        k = n.nextPos;
      } else {
        let id = parse_ident(src, k);
        pat = id.text;
        k = id.nextPos;
      }
    }

    k = parse_keyword(src, k, "=>");

    // arm expression: block expr or normal expr
    let t = skip_ws(src, k);
    let arm = if (t < stringLen(src) && stringCharCodeAt(src, t) == 123) parse_block_expr(src, k) else parse_expr(src, k);
    k = arm.v1;

    if (!(pat == "_" || pat == "true" || pat == "false" || is_digit(stringCharCodeAt(pat, 0)) || (stringLen(pat) > 0 && stringCharCodeAt(pat, 0) == 34))) {
      panic_at(src, k, "unsupported match pattern: " + pat);
    }

    if (pat == "_") {
      def = arm.v0;
    } else {
      cases = cases + ("case " + pat + ": return " + arm.v0 + ";\n");
    }

    k = skip_ws(src, k);
    if (k < stringLen(src)) {
      let ch = stringCharCodeAt(src, k);
      if (ch == 44 || ch == 59) { // ',' or ';'
        k = k + 1;
      }
    }
  }

  if (def == "") { panic_at(src, k, "match requires _ arm"); }

  ParsedExpr("(() => { switch (" + scrut.v0 + ") {\n" + cases + "default: return " + def + ";\n} })()", k)
}

fn parse_mut_opt(src: String, i: I32) : ParsedBool => {
  let j = skip_ws(src, i);
  if (starts_with_at(src, j, "mut")) {
    // Require a boundary: next char must not be an identifier character.
    if (j + 3 < stringLen(src)) {
      let n = stringCharCodeAt(src, j + 3);
      if (is_ident_part(n)) { yield ParsedBool(false, i); }
    }
    yield ParsedBool(true, j + 3);
  }
  ParsedBool(false, i)
}

fn parse_stmt_block(src: String, i: I32) : ParsedStmt => {
  let mut k = skip_ws(src, i);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 123)) { panic_at(src, k, "expected '{'"); }
  k = k + 1;
  let mut body = "";
  while (true) {
    let t = skip_ws(src, k);
    if (!(t < stringLen(src))) { panic_at(src, t, "expected '}'"); }
    if (stringCharCodeAt(src, t) == 125) { yield ParsedExpr(body, t + 1); }

    let st = parse_stmt(src, k);
    body = body + st.v0;
    k = st.v1;
  }
  // unreachable
  ParsedExpr(body, k)
}

fn parse_stmt(src: String, i: I32) : ParsedStmt => {
  let mut k = skip_ws(src, i);

  // yield / early return
  if (starts_with_at(src, k, "yield")) {
    k = parse_keyword(src, k, "yield");
    k = skip_ws(src, k);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 59) { // ';'
      yield ParsedStmt("return;\n", k + 1);
    }
    let e = parse_expr(src, k);
    k = e.v1;
    k = parse_optional_semicolon(src, k);
    yield ParsedStmt("return " + e.v0 + ";\n", k);
  }

  // let / let mut
  if (starts_with_at(src, k, "let")) {
    k = parse_keyword(src, k, "let");
    let mutOpt = parse_mut_opt(src, k);
    k = mutOpt.nextPos;
    let name = parse_ident(src, k);
    k = name.nextPos;
    if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

    // Optional let type annotation: `let x: T = ...`
    let t0 = skip_ws(src, k);
    if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) { // ':'
      let _ty = parse_type_expr(src, t0 + 1);
      k = _ty.v1;
    }

    k = parse_keyword(src, k, "=");
    let expr = parse_expr(src, k);
    k = expr.v1;
    k = parse_optional_semicolon(src, k);
    let declKw = if (mutOpt.ok) "let" else "const";
    yield ParsedStmt(declKw + " " + name.text + " = " + expr.v0 + ";\n", k);
  }

  // while (...) { ... }
  if (starts_with_at(src, k, "while")) {
    k = parse_keyword(src, k, "while");
    k = parse_keyword(src, k, "(");
    let cond = parse_expr(src, k);
    k = cond.v1;
    k = parse_keyword(src, k, ")");
    let body = parse_stmt_block(src, k);
    k = body.v1;
    // optional semicolon after the while block
    k = parse_optional_semicolon(src, k);
    yield ParsedStmt("while (" + cond.v0 + ") {\n" + body.v0 + "}\n", k);
  }

  // if (...) { ... } (else { ... })?
  if (starts_with_at(src, k, "if")) {
    k = parse_keyword(src, k, "if");
    k = parse_keyword(src, k, "(");
    let cond = parse_expr(src, k);
    k = cond.v1;
    k = parse_keyword(src, k, ")");
    let thenB = parse_stmt_block(src, k);
    k = thenB.v1;
    let j = skip_ws(src, k);
    if (starts_with_at(src, j, "else")) {
      k = parse_keyword(src, k, "else");
      let elseB = parse_stmt_block(src, k);
      k = elseB.v1;
      // optional semicolon after the if/else
      k = parse_optional_semicolon(src, k);
      yield ParsedStmt("if (" + cond.v0 + ") {\n" + thenB.v0 + "} else {\n" + elseB.v0 + "}\n", k);
    }
    // optional semicolon after the if
    k = parse_optional_semicolon(src, k);
    yield ParsedStmt("if (" + cond.v0 + ") {\n" + thenB.v0 + "}\n", k);
  }

  // assignment: <ident> = <expr>;
  if (is_assign_stmt_start(src, k)) {
    let name = parse_ident(src, k);
    k = name.nextPos;
    if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }
    k = parse_keyword(src, k, "=");
    let expr = parse_expr(src, k);
    k = expr.v1;
    k = parse_optional_semicolon(src, k);
    yield ParsedStmt(name.text + " = " + expr.v0 + ";\n", k);
  }

  // field assignment: <expr>.<field>(.<field>)* = <expr>;
  if (is_field_assign_stmt_start(src, k)) {
    let base = parse_ident(src, k);
    k = base.nextPos;
    let mut lhs = base.text;
    while (true) {
      let t = skip_ws(src, k);
      if (!(t < stringLen(src) && stringCharCodeAt(src, t) == 46)) { break; } // '.'
      k = parse_keyword(src, k, ".");
      let part = parse_ident(src, k);
      lhs = lhs + "." + part.text;
      k = part.nextPos;
    }
    k = parse_keyword(src, k, "=");
    let expr = parse_expr(src, k);
    k = expr.v1;
    k = parse_optional_semicolon(src, k);
    yield ParsedStmt(lhs + " = " + expr.v0 + ";\n", k);
  }

  // index assignment: <ident>[<expr>] = <expr>;
  if (is_index_assign_stmt_start(src, k)) {
    let name = parse_ident(src, k);
    k = name.nextPos;
    k = parse_keyword(src, k, "[");
    let idx = parse_expr(src, k);
    k = idx.v1;
    k = parse_keyword(src, k, "]");
    k = parse_keyword(src, k, "=");
    let val = parse_expr(src, k);
    k = val.v1;
    k = parse_optional_semicolon(src, k);
    yield ParsedStmt("vec_set(" + name.text + ", " + idx.v0 + ", " + val.v0 + ");\n", k);
  }

  // expression statement: <expr>;
  let e = parse_expr(src, k);
  k = e.v1;
  k = parse_optional_semicolon(src, k);
  yield ParsedStmt(e.v0 + ";\n", k);

  panic_at(src, k, "expected statement")
}

fn is_index_assign_stmt_start(src: String, i: I32) : Bool => {
  let mut j = skip_ws(src, i);
  if (!(j < stringLen(src))) { yield false; }
  let c0 = stringCharCodeAt(src, j);
  if (!is_ident_start(c0)) { yield false; }
  j = j + 1;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (!is_ident_part(c)) { break; }
    j = j + 1;
  }
  j = skip_ws(src, j);
  j < stringLen(src) && stringCharCodeAt(src, j) == 91 // '['
}

fn is_assign_stmt_start(src: String, i: I32) : Bool => {
  let mut j = skip_ws(src, i);
  if (!(j < stringLen(src))) { yield false; }
  let c0 = stringCharCodeAt(src, j);
  if (!is_ident_start(c0)) { yield false; }
  j = j + 1;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (!is_ident_part(c)) { break; }
    j = j + 1;
  }
  j = skip_ws(src, j);
  if (!(j < stringLen(src) && stringCharCodeAt(src, j) == 61)) { yield false; }
  // exclude '==' and '=>'
  if (j + 1 < stringLen(src)) {
    let n = stringCharCodeAt(src, j + 1);
    if (n == 61 || n == 62) { yield false; }
  }
  true
}

fn is_field_assign_stmt_start(src: String, i: I32) : Bool => {
  let mut j = skip_ws(src, i);
  if (!(j < stringLen(src))) { yield false; }
  let c0 = stringCharCodeAt(src, j);
  if (!is_ident_start(c0)) { yield false; }
  j = j + 1;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (!is_ident_part(c)) { break; }
    j = j + 1;
  }
  j = skip_ws(src, j);

  // require at least one .ident
  if (!(j < stringLen(src) && stringCharCodeAt(src, j) == 46)) { yield false; }

  while (j < stringLen(src) && stringCharCodeAt(src, j) == 46) {
    j = j + 1; // '.'
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { yield false; }
    let c1 = stringCharCodeAt(src, j);
    if (!is_ident_start(c1)) { yield false; }
    j = j + 1;
    while (j < stringLen(src)) {
      let c = stringCharCodeAt(src, j);
      if (!is_ident_part(c)) { break; }
      j = j + 1;
    }
    j = skip_ws(src, j);
  }

  if (!(j < stringLen(src) && stringCharCodeAt(src, j) == 61)) { yield false; }
  // exclude '==' and '=>'
  if (j + 1 < stringLen(src)) {
    let n = stringCharCodeAt(src, j + 1);
    if (n == 61 || n == 62) { yield false; }
  }
  true
}

fn parse_main_body(src: String, i: I32) : ParsedMain => {
  let j = skip_ws(src, i);
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 123) { // '{'
    let b = parse_block_body(src, i);
    yield ParsedMain(b.body, b.expr, b.v1);
  }

  // expression main body
  let e = parse_expr(src, i);
  ParsedMain("", e.v0, e.v1)
}
