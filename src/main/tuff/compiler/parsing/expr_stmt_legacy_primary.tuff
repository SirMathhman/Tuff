// Selfhost compiler: primary expressions, blocks, and control (legacy string-emission path).
// Split out of expr_stmt_legacy.tuff.

extern from rt::stdlib use { panic, stringLen, stringSlice, stringCharCodeAt, stringFromCharCode };
extern from rt::vec use { vec_len, vec_get };

from util::diagnostics use { panic_at, find_struct_fields };

from util::lexing use {
  is_digit,
  is_ident_start,
  skip_ws,
  starts_with_at
};

from parsing::primitives use { parse_ident, parse_keyword, parse_number };

from parsing::expr_stmt_types use { ParsedExpr, ParsedMain };

from parsing::expr_stmt_legacy_expr use { parse_expr };
from parsing::expr_stmt_legacy_stmt use { parse_stmt };
from parsing::expr_stmt_stmt_starts use {
  is_assign_stmt_start_impl,
  is_field_assign_stmt_start_impl,
  is_index_assign_stmt_start_impl
};

out fn parse_primary(src: String, i: I32) : ParsedExpr => {
  let j = skip_ws(src, i);
  if (!(j < stringLen(src))) { panic_at(src, j, "expected expression"); }
  let c = stringCharCodeAt(src, j);
  if (starts_with_at(src, j, "if")) {
    let ie = parse_if_expr(src, j);
    yield ie;
  }
  if (starts_with_at(src, j, "match")) {
    let me = parse_match_expr(src, j);
    yield me;
  }
  if (c == 91) { // '['
    let ve = parse_vec_lit(src, j);
    yield ve;
  }
  if (c == 123) { // '{'
    let be = parse_block_expr(src, j);
    yield be;
  }
  if (c == 39) { // '\''
    // Char literal: '\'' <char-or-escape> '\''
    // Lowered to a numeric code point for JS emission.
    let start = j;
    let mut k = j + 1;
    if (!(k < stringLen(src))) { panic_at(src, start, "unterminated char literal"); }

    let mut code: I32 = 0;
    let ch0 = stringCharCodeAt(src, k);
    if (ch0 == 92) { // '\\'
      // Escape sequence.
      k = k + 1;
      if (!(k < stringLen(src))) { panic_at(src, start, "unterminated char escape"); }
      let esc = stringCharCodeAt(src, k);
      code = match (esc) {
        110 => 10, // 'n'
        114 => 13, // 'r'
        116 => 9, // 't'
        48 => 0, // '0'
        92 => 92, // '\\'
        39 => 39, // '\''
        34 => 34, // '"'
        _ => { panic_at(src, k, "unknown char escape"); 0 }
      };
      k = k + 1;
    } else {
      // Single character.
      code = ch0;
      k = k + 1;
    }

    if (!(k < stringLen(src))) { panic_at(src, start, "unterminated char literal"); }
    if (stringCharCodeAt(src, k) != 39) {
      panic_at(src, start, "char literal must contain exactly one character");
    }
    yield ParsedExpr("" + code, k + 1);
  }
  if (c == 34) { // '"'
    let start = j;
    let mut k = j + 1;
    while (k < stringLen(src)) {
      let ch = stringCharCodeAt(src, k);
      if (ch == 34) { yield ParsedExpr(stringSlice(src, start, k + 1), k + 1); }
      if (ch == 92) { // '\\'
        k = k + 1;
        if (k < stringLen(src)) { k = k + 1; continue; }
        panic_at(src, start, "unterminated string");
      }
      k = k + 1;
    }
    panic_at(src, start, "unterminated string");
  }
  if (c == 40) { // '('
    let first = parse_expr(src, j + 1);
    let mut k = skip_ws(src, first.v1);

    // Parenthesized expression
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
      yield ParsedExpr("(" + first.v0 + ")", k + 1);
    }

    // Tuple literal: (a, b, ...)
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 44) { // ','
      let mut out = "[" + first.v0;
      while (true) {
        // consume ','
        k = k + 1;
        k = skip_ws(src, k);

        // allow trailing comma
        if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
          yield ParsedExpr(out + "]", k + 1);
        }

        let e = parse_expr(src, k);
        out = out + ", " + e.v0;
        k = skip_ws(src, e.v1);

        if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in tuple literal"); }
        let ch = stringCharCodeAt(src, k);
        if (ch == 44) { // ','
          continue;
        }
        if (ch == 41) { // ')'
          yield ParsedExpr(out + "]", k + 1);
        }
        panic_at(src, k, "expected ',' or ')' in tuple literal");
      }
    }

    panic_at(src, k, "expected ')'");
  }
  if (is_digit(c)) {
    let n = parse_number(src, j);
    yield ParsedExpr("" + n.value, n.nextPos);
  }
  if (is_ident_start(c)) {
    let id = parse_ident(src, j);
    let mut k = id.nextPos;
    let mut out = id.text;
    while (true) {
      let t = skip_ws(src, k);
      if (!(t + 1 < stringLen(src))) { break; }
      if (!(stringCharCodeAt(src, t) == 58 && stringCharCodeAt(src, t + 1) == 58)) { break; } // '::'
      let next = parse_ident(src, t + 2);
      out = out + "." + next.text;
      k = next.nextPos;
    }

    // Struct literal: Name { <expr>, ... }
    let t2 = skip_ws(src, k);
    if (t2 < stringLen(src) && stringCharCodeAt(src, t2) == 123) { // '{'
      let lit = parse_struct_lit(src, out, t2);
      yield lit;
    }

    yield ParsedExpr(out, k);
  }
  let mut end = j + 32;
  if (end > stringLen(src)) { end = stringLen(src); }
  panic_at(src, j, "expected expression near '" + stringSlice(src, j, end) + "'")
}

fn parse_struct_lit(src: String, structName: String, i: I32) : ParsedExpr => {
  // Parses: '{' (expr (',' expr)*)? '}' and lowers using struct field order.
  let fields = find_struct_fields(structName);

  let mut k = skip_ws(src, i);
  k = parse_keyword(src, k, "{");

  let mut out = "({ ";
  let mut idx = 0;

  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}' in struct literal"); }
    if (stringCharCodeAt(src, k) == 125) { // '}'
      if (!(idx == vec_len(fields))) {
        panic_at(src, k, "wrong number of values in struct literal for " + structName);
      }
      yield ParsedExpr(out + " })", k + 1);
    }

    if (!(idx < vec_len(fields))) {
      panic_at(src, k, "too many values in struct literal for " + structName);
    }

    let e = parse_expr(src, k);
    k = e.v1;

    let fieldName = vec_get(fields, idx);
    if (idx == 0) { out = out + (fieldName + ": " + e.v0); }
    else { out = out + (", " + fieldName + ": " + e.v0); }
    idx = idx + 1;

    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ',' or '}' in struct literal"); }
    let ch = stringCharCodeAt(src, k);
    if (ch == 44) { // ','
      k = k + 1;
      continue;
    }
    if (ch == 125) { // '}'
      // next loop iteration will close and validate
      continue;
    }
    panic_at(src, k, "expected ',' or '}' in struct literal")
  }

  // unreachable
  ParsedExpr(out + " })", k)
}

fn parse_vec_lit(src: String, i: I32) : ParsedExpr => {
  // vector literal: '[' (expr (',' expr)*)? ']'
  let mut k = parse_keyword(src, i, "[");
  k = skip_ws(src, k);
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 93) { // ']'
    yield ParsedExpr("(() => { const __v = vec_new(); return __v; })()", k + 1);
  }

  let mut pushes = "";
  while (true) {
    let e = parse_expr(src, k);
    k = e.v1;
    pushes = pushes + ("vec_push(__v, " + e.v0 + ");\n");
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ']' in vec literal"); }
    let ch = stringCharCodeAt(src, k);
    if (ch == 44) { // ','
      k = k + 1;
      continue;
    }
    if (ch == 93) { // ']'
      yield ParsedExpr("(() => { const __v = vec_new();\n" + pushes + "return __v;\n})()", k + 1);
    }
    panic_at(src, k, "expected ',' or ']' in vec literal")
  }
  // unreachable
  ParsedExpr("None", k)
}

out fn parse_block_body(src: String, i: I32) : ParsedMain => {
  let j = skip_ws(src, i);
  if (!(j < stringLen(src) && stringCharCodeAt(src, j) == 123)) { panic_at(src, j, "expected '{'"); }

  let mut k = j + 1;
  let mut body = "";

  while (true) {
    let t = skip_ws(src, k);
    if (!(t < stringLen(src))) { panic_at(src, t, "expected '}'"); }
    if (stringCharCodeAt(src, t) == 125) { break; }

    let isStmt = starts_with_at(src, t, "let") || starts_with_at(src, t, "fn") || starts_with_at(src, t, "while") || starts_with_at(src, t, "if") || starts_with_at(src, t, "yield") || is_field_assign_stmt_start_impl(src, t) || is_assign_stmt_start_impl(src, t) || is_index_assign_stmt_start_impl(src, t);
    if (isStmt) {
      let st = parse_stmt(src, k);
      body = body + st.v0;
      k = st.v1;
      continue;
    }

    // expression statement vs tail expression
    let e = parse_expr(src, k);
    let after = skip_ws(src, e.v1);
    if (after < stringLen(src) && stringCharCodeAt(src, after) == 59) {
      body = body + (e.v0 + ";\n");
      k = after + 1;
      continue;
    }
    // Without semicolons, treat the expression as a statement unless it ends the block.
    if (after < stringLen(src) && stringCharCodeAt(src, after) != 125) {
      body = body + (e.v0 + ";\n");
      k = e.v1;
      continue;
    }
    break;
  }

  // If the block is empty or ends with statements only, treat it as returning `undefined`.
  let t2 = skip_ws(src, k);
  if (t2 < stringLen(src) && stringCharCodeAt(src, t2) == 125) {
    yield ParsedMain(body, "undefined", t2 + 1);
  }

  let tail = parse_expr(src, k);
  k = skip_ws(src, tail.v1);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 125)) { panic_at(src, k, "expected '}'"); }
  ParsedMain(body, tail.v0, k + 1)
}

fn parse_block_expr(src: String, i: I32) : ParsedExpr => {
  let b = parse_block_body(src, i);
  ParsedExpr("(() => {\n" + b.body + "return " + b.expr + ";\n})()", b.v1)
}

fn parse_if_expr(src: String, i: I32) : ParsedExpr => {
  let mut k = parse_keyword(src, i, "if");
  k = parse_keyword(src, k, "(");
  let cond = parse_expr(src, k);
  k = cond.v1;
  k = parse_keyword(src, k, ")");
  let t1 = skip_ws(src, k);
  let thenE = if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 123) parse_block_expr(src, k) else parse_expr(src, k);
  k = thenE.v1;
  k = parse_keyword(src, k, "else");
  let t2 = skip_ws(src, k);
  let elseE = if (t2 < stringLen(src) && stringCharCodeAt(src, t2) == 123) parse_block_expr(src, k) else parse_expr(src, k);
  ParsedExpr("(" + cond.v0 + " ? " + thenE.v0 + " : " + elseE.v0 + ")", elseE.v1)
}

fn parse_match_expr(src: String, i: I32) : ParsedExpr => {
  let mut k = parse_keyword(src, i, "match");
  k = parse_keyword(src, k, "(");
  let scrut = parse_expr(src, k);
  k = scrut.v1;
  k = parse_keyword(src, k, ")");
  k = parse_keyword(src, k, "{");

  let mut cases = "";
  let mut def = "";
  let mut sawVariant = false;

  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
    if (stringCharCodeAt(src, k) == 125) { k = k + 1; break; }

    // pattern: number | string | true/false | _ | VariantName
    let mut pat = "";
    let c0 = stringCharCodeAt(src, k);
    if (c0 == 34) { // string
      let lit = parse_primary(src, k);
      pat = lit.v0;
      k = lit.v1;
    } else {
      if (is_digit(c0)) {
        let n = parse_number(src, k);
        pat = "" + n.value;
        k = n.nextPos;
      } else {
        let id = parse_ident(src, k);
        k = id.nextPos;

        // module path: A::B::C (use the last segment for variant matches)
        let mut name = id.text;
        while (true) {
          let t = skip_ws(src, k);
          if (!(t + 1 < stringLen(src))) { break; }
          if (!(stringCharCodeAt(src, t) == 58 && stringCharCodeAt(src, t + 1) == 58)) { break; }
          let next = parse_ident(src, t + 2);
          name = next.text;
          k = next.nextPos;
        }

        if (id.text == "_" || id.text == "true" || id.text == "false") {
          pat = id.text;
        } else {
          // Treat bare identifier patterns as union variant names (tags).
          let q = stringFromCharCode(34);
          pat = q + name + q;
          sawVariant = true;
        }
      }
    }

    k = parse_keyword(src, k, "=>");

    // arm expression: block expr or normal expr
    let t = skip_ws(src, k);
    let arm = if (t < stringLen(src) && stringCharCodeAt(src, t) == 123) parse_block_expr(src, k) else parse_expr(src, k);
    k = arm.v1;

    if (pat == "_") {
      def = arm.v0;
    } else {
      cases = cases + ("case " + pat + ": return " + arm.v0 + ";\n");
    }

    k = skip_ws(src, k);
    if (k < stringLen(src)) {
      let ch = stringCharCodeAt(src, k);
      if (ch == 44 || ch == 59) { // ',' or ';'
        k = k + 1;
      }
    }
  }

  if (def == "" && !sawVariant) { panic_at(src, k, "match requires _ arm"); }
  if (def == "" && sawVariant) { def = "(() => { throw new Error(\\\"non-exhaustive match\\\"); })()"; }

  let scrutJs = if (sawVariant) "(" + scrut.v0 + ").tag" else scrut.v0;
  ParsedExpr("(() => { switch (" + scrutJs + ") {\n" + cases + "default: return " + def + ";\n} })()", k)
}
