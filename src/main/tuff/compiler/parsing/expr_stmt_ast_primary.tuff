// Selfhost compiler: primary expressions and literals (AST-producing path).
// Split out of expr_stmt_ast.tuff.

extern from rt::stdlib use { panic, stringLen, stringSlice, stringCharCodeAt, stringFromCharCode };
extern from rt::vec use { vec_new, vec_push, vec_len, vec_get };

from util::diagnostics use { panic_at, panic_at_help };
from util::lexing use { is_digit, is_ident_start, is_ident_part, skip_ws, starts_with_at };

from parsing::primitives use { ParsedIdent, parse_ident, parse_keyword, parse_number };
from parsing::types use { parse_type_expr };

from parsing::expr_stmt_types use {
  ParsedExprAst,
  ParsedExprListAst,
  ParsedTypeParamsForLambdaAst
};

from parsing::expr_stmt_ast_expr use { parse_expr_ast_impl };
from parsing::expr_stmt_ast_blocks use { parse_block_expr_ast };
from parsing::expr_stmt_ast_lambda use { find_matching_rparen, parse_lambda_expr_ast, parse_type_param_names_list_ast };

from ast use {
  span,
  span_start,
  expr_span,

  expr_int,
  expr_float,
  expr_string,
  expr_ident,
  expr_path,
  expr_lambda,
  expr_struct_lit,
  expr_vec_lit,
  expr_tuple_lit,
  expr_if,
  expr_match,

  mk_match_arm,
  pat_wildcard,
  pat_int,
  pat_bool,
  pat_string,
  pat_variant
};

fn parse_string_lit_value(src: String, startQuote: I32) : ParsedIdent => {
  // Returns ParsedIdent(text=value, startPos=startQuote, nextPos=endPosAfterQuote)
  // NOTE: We reuse ParsedIdent for convenience.
  let mut k = startQuote + 1;
  let mut out = "";
  while (k < stringLen(src)) {
    let ch = stringCharCodeAt(src, k);
    if (ch == 34) { // '"'
      yield ParsedIdent(out, startQuote, k + 1);
    }
    if (ch == 92) { // '\\'
      k = k + 1;
      if (!(k < stringLen(src))) { panic_at(src, startQuote, "unterminated string"); }
      let esc = stringCharCodeAt(src, k);
      let code = match (esc) {
        110 => 10, // n
        114 => 13, // r
        116 => 9,  // t
        48 => 0,   // 0
        92 => 92,  // \\
        34 => 34,  // "
        _ => esc
      };
      out = out + stringFromCharCode(code);
      k = k + 1;
      continue;
    }
    out = out + stringFromCharCode(ch);
    k = k + 1;
  }
  panic_at(src, startQuote, "unterminated string")
}

fn parse_vec_lit_ast(src: String, i: I32) : ParsedExprAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "[");
  k = skip_ws(src, k);
  let items = vec_new();
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 93) { // ']'
    yield ParsedExprAst(expr_vec_lit(span(start, k + 1), items), k + 1);
  }
  while (true) {
    let e = parse_expr_ast_impl(src, k);
    vec_push(items, e.expr);
    k = skip_ws(src, e.nextPos);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ']' in vec literal"); }
    let ch = stringCharCodeAt(src, k);
    if (ch == 44) { k = k + 1; continue; }
    if (ch == 93) { yield ParsedExprAst(expr_vec_lit(span(start, k + 1), items), k + 1); }
    panic_at(src, k, "expected ',' or ']' in vec literal")
  }
  ParsedExprAst(expr_vec_lit(span(start, k), items), k)
}

fn parse_struct_lit_values_ast(src: String, i: I32) : ParsedExprListAst => {
  // Parses: '{' (expr (',' expr)*)? '}'
  let mut k = skip_ws(src, i);
  k = parse_keyword(src, k, "{");
  k = skip_ws(src, k);
  let items = vec_new();
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 125) {
    yield ParsedExprListAst(items, k + 1);
  }
  while (true) {
    let e = parse_expr_ast_impl(src, k);
    vec_push(items, e.expr);
    k = skip_ws(src, e.nextPos);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ',' or '}' in struct literal"); }
    let ch = stringCharCodeAt(src, k);
    if (ch == 44) { k = k + 1; continue; }
    if (ch == 125) { yield ParsedExprListAst(items, k + 1); }
    panic_at(src, k, "expected ',' or '}' in struct literal")
  }
  ParsedExprListAst(items, k)
}

fn parse_if_expr_ast(src: String, i: I32) : ParsedExprAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "if");
  k = parse_keyword(src, k, "(");
  let cond = parse_expr_ast_impl(src, k);
  k = cond.nextPos;
  k = parse_keyword(src, k, ")");
  let t1 = skip_ws(src, k);
  let thenE = if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 123) parse_block_expr_ast(src, k) else parse_expr_ast_impl(src, k);
  k = thenE.nextPos;
  k = parse_keyword(src, k, "else");
  let t2 = skip_ws(src, k);
  let elseE = if (t2 < stringLen(src) && stringCharCodeAt(src, t2) == 123) parse_block_expr_ast(src, k) else parse_expr_ast_impl(src, k);
  ParsedExprAst(expr_if(span(start, elseE.nextPos), cond.expr, thenE.expr, elseE.expr), elseE.nextPos)
}

fn parse_match_expr_ast(src: String, i: I32) : ParsedExprAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "match");
  k = parse_keyword(src, k, "(");
  let scrut = parse_expr_ast_impl(src, k);
  k = scrut.nextPos;
  k = parse_keyword(src, k, ")");
  k = parse_keyword(src, k, "{");

  let arms = vec_new();
  let mut sawDefault = false;
  let mut sawVariant = false;

  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
    if (stringCharCodeAt(src, k) == 125) { k = k + 1; break; }

    let patStart = k;
    let c0 = stringCharCodeAt(src, k);
    let mut pat = pat_wildcard(span(patStart, patStart));

    if (c0 == 34) {
      let lit = parse_string_lit_value(src, k);
      pat = pat_string(span(patStart, lit.nextPos), lit.text);
      k = lit.nextPos;
    } else {
      if (is_digit(c0)) {
        let n = parse_number(src, k);
        pat = pat_int(span(patStart, n.nextPos), n.value);
        k = n.nextPos;
      } else {
        let id = parse_ident(src, k);
        k = id.nextPos;

        // module path: A::B::C (use the last segment for variant matches)
        let mut name = id.text;
        while (true) {
          let t = skip_ws(src, k);
          if (!(t + 1 < stringLen(src))) { break; }
          if (!(stringCharCodeAt(src, t) == 58 && stringCharCodeAt(src, t + 1) == 58)) { break; }
          let next = parse_ident(src, t + 2);
          name = next.text;
          k = next.nextPos;
        }

        if (id.text == "_") {
          pat = pat_wildcard(span(patStart, k));
        } else {
          if (id.text == "true") {
            pat = pat_bool(span(patStart, k), true);
          } else {
            if (id.text == "false") {
              pat = pat_bool(span(patStart, k), false);
            } else {
              // Union variant pattern.
              pat = pat_variant(span(patStart, k), name);
              sawVariant = true;
            }
          }
        }
      }
    }

    k = parse_keyword(src, k, "=>");
    let t = skip_ws(src, k);
    let armE = if (t < stringLen(src) && stringCharCodeAt(src, t) == 123) parse_block_expr_ast(src, k) else parse_expr_ast_impl(src, k);
    k = armE.nextPos;

    if (pat.tag == "MPWildcard") { sawDefault = true; }
    vec_push(arms, mk_match_arm(span(patStart, armE.nextPos), pat, armE.expr));

    k = skip_ws(src, k);
    if (k < stringLen(src)) {
      let ch = stringCharCodeAt(src, k);
      if (ch == 44 || ch == 59) { k = k + 1; }
    }
  }

  // Keep the old bootstrap restriction for non-variant matches.
  if (!sawDefault && !sawVariant) { panic_at(src, k, "match requires _ arm"); }
  ParsedExprAst(expr_match(span(start, k), scrut.expr, arms), k)
}

out fn parse_primary_ast(src: String, i: I32) : ParsedExprAst => {
  let j = skip_ws(src, i);
  if (!(j < stringLen(src))) { panic_at(src, j, "expected expression"); }
  let c = stringCharCodeAt(src, j);

  if (starts_with_at(src, j, "if")) { yield parse_if_expr_ast(src, j); }
  if (starts_with_at(src, j, "match")) { yield parse_match_expr_ast(src, j); }
  if (c == 91) { yield parse_vec_lit_ast(src, j); }
  if (c == 123) { yield parse_block_expr_ast(src, j); }

  if (c == 39) { // char literal
    let start = j;
    let mut k = j + 1;
    if (!(k < stringLen(src))) { panic_at(src, start, "unterminated char literal"); }
    let mut code: I32 = 0;
    let ch0 = stringCharCodeAt(src, k);
    if (ch0 == 92) {
      k = k + 1;
      if (!(k < stringLen(src))) { panic_at(src, start, "unterminated char escape"); }
      let esc = stringCharCodeAt(src, k);
      code = match (esc) {
        110 => 10,
        114 => 13,
        116 => 9,
        48 => 0,
        92 => 92,
        39 => 39,
        34 => 34,
        _ => { panic_at(src, k, "unknown char escape"); 0 }
      };
      k = k + 1;
    } else {
      code = ch0;
      k = k + 1;
    }
    if (!(k < stringLen(src))) { panic_at(src, start, "unterminated char literal"); }
    if (stringCharCodeAt(src, k) != 39) { panic_at(src, start, "char literal must contain exactly one character"); }
    yield ParsedExprAst(expr_int(span(start, k + 1), code), k + 1);
  }

  if (c == 34) { // string literal
    let lit = parse_string_lit_value(src, j);
    yield ParsedExprAst(expr_string(span(j, lit.nextPos), lit.text), lit.nextPos);
  }

  if (c == 40) { // '('
    // Disambiguate lambdas from parenthesized expressions / tuples.
    // Lambdas are recognized by what comes *after* the matching ')':
    //   (params) => body
    //   (params) : Ret => body
    let rp = find_matching_rparen(src, j);
    if (rp != -1) {
      let after = skip_ws(src, rp + 1);
      if (after + 1 < stringLen(src) && stringCharCodeAt(src, after) == 61 && stringCharCodeAt(src, after + 1) == 62) {
        yield parse_lambda_expr_ast(src, j);
      }
      // ':' (optional return annotation) followed by '=>'
      if (after < stringLen(src) && stringCharCodeAt(src, after) == 58) {
        yield parse_lambda_expr_ast(src, j);
      }
    }

    let first = parse_expr_ast_impl(src, j + 1);
    let mut k = skip_ws(src, first.nextPos);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) {
      yield ParsedExprAst(first.expr, k + 1);
    }
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 44) {
      let items = vec_new();
      vec_push(items, first.expr);
      while (true) {
        k = k + 1;
        k = skip_ws(src, k);
        if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) {
          yield ParsedExprAst(expr_tuple_lit(span(j, k + 1), items), k + 1);
        }
        let e = parse_expr_ast_impl(src, k);
        vec_push(items, e.expr);
        k = skip_ws(src, e.nextPos);
        if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in tuple literal"); }
        let ch = stringCharCodeAt(src, k);
        if (ch == 44) { continue; }
        if (ch == 41) { yield ParsedExprAst(expr_tuple_lit(span(j, k + 1), items), k + 1); }
        panic_at(src, k, "expected ',' or ')' in tuple literal")
      }
    }
    panic_at_help(src, k, "expected ')'", "Add ')' to close the opening '('.")
  }

  if (is_digit(c)) {
    // Float literal: <digits> '.' <digits> [F32|F64]
    // Parse this before falling back to integer parsing so `2.0` doesn't get
    // interpreted as tuple indexing on the integer literal `2`.
    let mut k = j;
    while (k < stringLen(src) && is_digit(stringCharCodeAt(src, k))) {
      k = k + 1;
    }
    if (k + 1 < stringLen(src) && stringCharCodeAt(src, k) == 46 && is_digit(stringCharCodeAt(src, k + 1))) { // '.'
      let mut m = k + 1;
      while (m < stringLen(src) && is_digit(stringCharCodeAt(src, m))) {
        m = m + 1;
      }
      let text = stringSlice(src, j, m);

      // Check for optional suffix (F32 or F64)
      let mut suffix = "";
      let mut endPos = m;
      if (m + 2 < stringLen(src)) {
        let s1 = stringSlice(src, m, m + 3);
        if (s1 == "F32") {
          suffix = "F32";
          endPos = m + 3;
        } else {
          if (s1 == "F64") {
            suffix = "F64";
            endPos = m + 3;
          }
        }
      }

      yield ParsedExprAst(expr_float(span(j, endPos), text, suffix), endPos);
    }

    let n = parse_number(src, j);
    yield ParsedExprAst(expr_int(span(j, n.nextPos), n.value), n.nextPos);
  }

  if (is_ident_start(c)) {
    let id = parse_ident(src, j);
    let mut k = id.nextPos;

    // module path: A::B::C
    let parts = vec_new();
    vec_push(parts, id.text);
    while (true) {
      let t = skip_ws(src, k);
      if (!(t + 1 < stringLen(src))) { break; }
      if (!(stringCharCodeAt(src, t) == 58 && stringCharCodeAt(src, t + 1) == 58)) { break; }
      let next = parse_ident(src, t + 2);
      vec_push(parts, next.text);
      k = next.nextPos;
    }

    // Struct literal: Name { <expr>, ... }
    let t2 = skip_ws(src, k);
    if (t2 < stringLen(src) && stringCharCodeAt(src, t2) == 123) {
      let vals = parse_struct_lit_values_ast(src, t2);
      let nameExpr = expr_path(span(j, k), parts);
      yield ParsedExprAst(expr_struct_lit(span(j, vals.nextPos), nameExpr, vals.items), vals.nextPos);
    }

    // Plain identifier or module path
    if (vec_len(parts) == 1) {
      yield ParsedExprAst(expr_ident(span(j, k), vec_get(parts, 0)), k);
    }
    yield ParsedExprAst(expr_path(span(j, k), parts), k);
  }

  let mut end = j + 32;
  if (end > stringLen(src)) { end = stringLen(src); }
  panic_at(src, j, "expected expression near '" + stringSlice(src, j, end) + "'")
}
