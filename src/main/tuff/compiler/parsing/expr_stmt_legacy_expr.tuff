// Selfhost compiler: expression parsing (legacy string-emission path).
// Split out of expr_stmt_legacy.tuff.

extern from rt::stdlib use { stringLen, stringCharCodeAt, stringFromCharCode };

from util::lexing use { skip_ws, starts_with_at, is_ident_part };
from parsing::primitives use { parse_ident };

from parsing::expr_stmt_types use { ParsedExpr };
from parsing::expr_stmt_legacy_postfix use { parse_postfix };

out fn parse_expr(src: String, i: I32) : ParsedExpr => parse_or(src, i)

fn parse_or(src: String, i: I32) : ParsedExpr => {
  let mut left = parse_and(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j + 1 < stringLen(src))) { break; }
    if (stringCharCodeAt(src, j) == 124 && stringCharCodeAt(src, j + 1) == 124) { // '||'
      let rhs = parse_and(src, j + 2);
      left = ParsedExpr("(" + left.v0 + " || " + rhs.v0 + ")", rhs.v1);
      j = left.v1;
      continue;
    }
    break;
  }
  left
}

fn parse_and(src: String, i: I32) : ParsedExpr => {
  let mut left = parse_cmp(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j + 1 < stringLen(src))) { break; }
    if (stringCharCodeAt(src, j) == 38 && stringCharCodeAt(src, j + 1) == 38) { // '&&'
      let rhs = parse_cmp(src, j + 2);
      left = ParsedExpr("(" + left.v0 + " && " + rhs.v0 + ")", rhs.v1);
      j = left.v1;
      continue;
    }
    break;
  }
  left
}

fn parse_cmp(src: String, i: I32) : ParsedExpr => {
  // comparisons: == != < <= > >=
  let mut left = parse_add(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }

    // `is` narrowing operator (legacy JS-string parser): desugar like the AST path.
    if (starts_with_at(src, j, "is")) {
      let afterIs = j + 2;
      let mut boundaryOk = true;
      if (afterIs < stringLen(src) && is_ident_part(stringCharCodeAt(src, afterIs))) { boundaryOk = false; }
      if (boundaryOk) {
        let mut k0 = skip_ws(src, afterIs);

        // Optional `not` keyword: `x is not Some`
        let mut isNot = false;
        if (starts_with_at(src, k0, "not")) {
          let afterNot = k0 + 3;
          let mut notBoundaryOk = true;
          if (afterNot < stringLen(src) && is_ident_part(stringCharCodeAt(src, afterNot))) { notBoundaryOk = false; }
          if (notBoundaryOk) {
            isNot = true;
            k0 = skip_ws(src, afterNot);
          }
        }

        // Variant name: identifier or module path (`A::B::Some`). Use the last segment.
        let first = parse_ident(src, k0);
        let mut k = first.nextPos;
        let mut variantName = first.text;
        while (true) {
          let t = skip_ws(src, k);
          if (!(t + 1 < stringLen(src))) { break; }
          if (!(stringCharCodeAt(src, t) == 58 && stringCharCodeAt(src, t + 1) == 58)) { break; }
          let next = parse_ident(src, t + 2);
          variantName = next.text;
          k = next.nextPos;
        }

        let q = stringFromCharCode(34);
        let rhs = q + variantName + q;
        let op = if (isNot) "!=" else "==";
        left = ParsedExpr("(" + left.v0 + ".tag " + op + " " + rhs + ")", k);
        j = left.v1;
        continue;
      }
    }

    let c0 = stringCharCodeAt(src, j);
    let c1 = if (j + 1 < stringLen(src)) stringCharCodeAt(src, j + 1) else 0;

    let mut op = "";
    let mut adv = 0;

    // ==
    if (c0 == 61 && c1 == 61) { op = "=="; adv = 2; }
    // !=
    if (op == "" && c0 == 33 && c1 == 61) { op = "!="; adv = 2; }
    // <=
    if (op == "" && c0 == 60 && c1 == 61) { op = "<="; adv = 2; }
    // >=
    if (op == "" && c0 == 62 && c1 == 61) { op = ">="; adv = 2; }
    // <
    if (op == "" && c0 == 60) { op = "<"; adv = 1; }
    // >
    if (op == "" && c0 == 62) { op = ">"; adv = 1; }

    if (op == "") { break; }

    let rhs = parse_add(src, j + adv);
    left = ParsedExpr("(" + left.v0 + " " + op + " " + rhs.v0 + ")", rhs.v1);
    j = left.v1;
  }
  left
}

fn parse_add(src: String, i: I32) : ParsedExpr => {
  let mut left = parse_mul(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }
    let op = stringCharCodeAt(src, j);
    if (!(op == 43 || op == 45)) { break; } // '+' or '-'
    let rhs = parse_mul(src, j + 1);
    let opStr = if (op == 43) "+" else "-";
    left = ParsedExpr("(" + left.v0 + " " + opStr + " " + rhs.v0 + ")", rhs.v1);
    j = left.v1;
  }
  left
}

fn parse_mul(src: String, i: I32) : ParsedExpr => {
  let mut left = parse_unary(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }
    let op = stringCharCodeAt(src, j);
    if (!(op == 42 || op == 47)) { break; } // '*' or '/'
    let rhs = parse_unary(src, j + 1);
    let opStr = if (op == 42) "*" else "/";
    left = ParsedExpr("(" + left.v0 + " " + opStr + " " + rhs.v0 + ")", rhs.v1);
    j = left.v1;
  }
  left
}

fn parse_unary(src: String, i: I32) : ParsedExpr => {
  let j = skip_ws(src, i);
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 33) { // '!'
    let inner = parse_unary(src, j + 1);
    yield ParsedExpr("(!" + inner.v0 + ")", inner.v1);
  }
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 45) { // '-'
    let inner = parse_unary(src, j + 1);
    yield ParsedExpr("(-" + inner.v0 + ")", inner.v1);
  }
  parse_postfix(src, i)
}
