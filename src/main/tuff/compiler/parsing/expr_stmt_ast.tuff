// Selfhost compiler: expression + statement parsing (AST-producing path).
// Split out of expr_stmt.tuff.

extern from rt::stdlib use { panic, stringLen, stringSlice, stringCharCodeAt, stringFromCharCode };
extern from rt::vec use { vec_new, vec_push, vec_len, vec_get };

from util::diagnostics use {
  panic_at,
  panic_at_help,
  find_struct_fields,
  is_identifier_too_short,
  warn_short_identifier
};

from util::lexing use {
  is_digit,
  is_ident_start,
  is_ident_part,
  skip_ws,
  starts_with_at
};

from parsing::primitives use {
  ParsedBool,
  ParsedIdent,
  ParsedNumber,
  parse_ident,
  parse_keyword,
  parse_number,
  parse_optional_semicolon
};

from parsing::types use { parse_type_expr };

from parsing::expr_stmt_types use {
  ParsedExprAst,
  ParsedMainAst,
  ParsedStmtAst,
  ParsedStmtsAst,
  ParsedExprListAst,
  ParsedTypeArgsForCallAst,
  ParsedTypeParamsForLambdaAst
};

from parsing::expr_stmt_helpers use { parse_mut_opt_impl };
from parsing::expr_stmt_stmt_starts use {
  is_assign_stmt_start_impl,
  is_field_assign_stmt_start_impl,
  is_index_assign_stmt_start_impl
};

from ast use {
  span,
  span_start,
  expr_span,

  // Expr constructors
  expr_undefined,
  expr_int,
  expr_float,
  expr_bool,
  expr_string,
  expr_ident,
  expr_path,
  expr_lambda,
  expr_struct_lit,
  expr_unary,
  expr_binary,
  expr_call,
  expr_call_typed,
  expr_if,
  expr_block,
  expr_vec_lit,
  expr_tuple_lit,
  expr_index,
  expr_tuple_index,
  expr_field,
  expr_match,
  expr_is_type,

  // Ops
  OpOr,
  OpAnd,
  OpEq,
  OpNe,
  OpLt,
  OpLe,
  OpGt,
  OpGe,
  OpAdd,
  OpSub,
  OpMul,
  OpDiv,
  OpNot,
  OpNeg,

  // Match constructors
  mk_match_arm,
  pat_wildcard,
  pat_int,
  pat_bool,
  pat_string,
  pat_variant,

  // Stmt constructors
  stmt_let,
  stmt_let_typed,
  stmt_assign,
  stmt_expr,
  stmt_yield,
  stmt_while,
  stmt_if,
  stmt_index_assign,
  stmt_field_assign
};

// ------------------------------------------------------------
// AST path (Phase 3)
// ------------------------------------------------------------

out fn parse_expr_ast_impl(src: String, i: I32) : ParsedExprAst => parse_expr_ast(src, i)
out fn parse_main_body_ast_impl(src: String, i: I32) : ParsedMainAst => parse_main_body_ast(src, i)

fn find_matching_rparen(src: String, openPos: I32) : I32 => {
  // Returns the index of the ')' that closes the '(' at openPos, or -1.
  // This is used only for lambda disambiguation.
  let mut i = openPos;
  let mut depth = 0;
  while (i < stringLen(src)) {
    let ch = stringCharCodeAt(src, i);

    // Skip string literals (minimal escape handling).
    if (ch == 34) { // '"'
      i = i + 1;
      while (i < stringLen(src)) {
        let c = stringCharCodeAt(src, i);
        if (c == 92) { // '\\'
          i = i + 2;
          continue;
        }
        if (c == 34) { i = i + 1; break; }
        i = i + 1;
      }
      continue;
    }

    // Skip char literals (minimal escape handling).
    if (ch == 39) { // '\''
      i = i + 1;
      while (i < stringLen(src)) {
        let c = stringCharCodeAt(src, i);
        if (c == 92) { // '\\'
          i = i + 2;
          continue;
        }
        if (c == 39) { i = i + 1; break; }
        i = i + 1;
      }
      continue;
    }

    if (ch == 40) { // '('
      depth = depth + 1;
      i = i + 1;
      continue;
    }
    if (ch == 41) { // ')'
      depth = depth - 1;
      if (depth == 0) { yield i; }
      i = i + 1;
      continue;
    }

    i = i + 1;
  }
  -1
}

// Lambda params list parser is only used when we've already determined this is
// a lambda expression (see `parse_primary_ast` disambiguation).
fn parse_lambda_expr_ast(src: String, i: I32) : ParsedExprAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "(");
  k = skip_ws(src, k);

  let params = vec_new();
  let paramTyAnns = vec_new();

  // Empty param list: ()
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
    k = k + 1;
  } else {
    // One or more params: name (':' Type)?
    while (true) {
      let name = parse_ident(src, k);
      vec_push(params, name.text);
      k = skip_ws(src, name.nextPos);

      // Optional parameter type annotation.
      let mut tyAnn = "";
      if (k < stringLen(src) && stringCharCodeAt(src, k) == 58) { // ':'
        k = parse_keyword(src, k, ":");
        let ty = parse_type_expr(src, k);
        tyAnn = ty.v0;
        k = ty.v1;
      }
      vec_push(paramTyAnns, tyAnn);
      k = skip_ws(src, k);

      if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in lambda params"); }
      let ch = stringCharCodeAt(src, k);
      if (ch == 44) { // ','
        k = k + 1;
        k = skip_ws(src, k);
        // Allow trailing comma: (a: I32,)
        if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
          k = k + 1;
          break;
        }
        continue;
      }
      if (ch == 41) { // ')'
        k = k + 1;
        break;
      }
      panic_at(src, k, "expected ',' or ')' in lambda params")
    }
  }

  // Optional return type annotation: `: Type`
  k = skip_ws(src, k);
  let mut retTyAnn = "";
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 58) { // ':'
    k = parse_keyword(src, k, ":");
    let ret = parse_type_expr(src, k);
    retTyAnn = ret.v0;
    k = ret.v1;
  }

  k = parse_keyword(src, k, "=>");

  let t = skip_ws(src, k);
  let body = if (t < stringLen(src) && stringCharCodeAt(src, t) == 123) parse_block_expr_ast(src, k) else parse_expr_ast(src, k);
  ParsedExprAst(expr_lambda(span(start, body.nextPos), vec_new(), params, paramTyAnns, retTyAnn, body.expr), body.nextPos)
}

fn parse_type_param_names_list_ast(src: String, i: I32) : ParsedTypeParamsForLambdaAst => {
  // parses: '<' (ident (',' ident)*)? '>'
  // empty list is allowed (but rare): fn f<>()
  let mut k = skip_ws(src, i);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 60)) { // '<'
    yield ParsedTypeParamsForLambdaAst(vec_new(), i);
  }
  k = k + 1;
  k = skip_ws(src, k);

  let names = vec_new();
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 62) { // '>'
    yield ParsedTypeParamsForLambdaAst(names, k + 1);
  }

  while (true) {
    let id = parse_ident(src, k);
    vec_push(names, id.text);
    k = skip_ws(src, id.nextPos);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '>' in type params"); }
    let ch = stringCharCodeAt(src, k);
    if (ch == 44) { // ','
      k = k + 1;
      k = skip_ws(src, k);
      continue;
    }
    if (ch == 62) { // '>'
      yield ParsedTypeParamsForLambdaAst(names, k + 1);
    }
    panic_at(src, k, "expected ',' or '>' in type params")
  }
  ParsedTypeParamsForLambdaAst(names, k)
}

fn parse_expr_ast(src: String, i: I32) : ParsedExprAst => parse_or_ast(src, i)

fn parse_or_ast(src: String, i: I32) : ParsedExprAst => {
  let mut left = parse_and_ast(src, i);
  let mut j = left.nextPos;
  while (true) {
    j = skip_ws(src, j);
    if (!(j + 1 < stringLen(src))) { break; }
    if (stringCharCodeAt(src, j) == 124 && stringCharCodeAt(src, j + 1) == 124) { // '||'
      let rhs = parse_and_ast(src, j + 2);
      let start = span_start(expr_span(left.expr));
      left = ParsedExprAst(expr_binary(span(start, rhs.nextPos), OpOr, left.expr, rhs.expr), rhs.nextPos);
      j = left.nextPos;
      continue;
    }
    break;
  }
  left
}

fn parse_and_ast(src: String, i: I32) : ParsedExprAst => {
  let mut left = parse_cmp_ast(src, i);
  let mut j = left.nextPos;
  while (true) {
    j = skip_ws(src, j);
    if (!(j + 1 < stringLen(src))) { break; }
    if (stringCharCodeAt(src, j) == 38 && stringCharCodeAt(src, j + 1) == 38) { // '&&'
      let rhs = parse_cmp_ast(src, j + 2);
      let start = span_start(expr_span(left.expr));
      left = ParsedExprAst(expr_binary(span(start, rhs.nextPos), OpAnd, left.expr, rhs.expr), rhs.nextPos);
      j = left.nextPos;
      continue;
    }
    break;
  }
  left
}

fn parse_cmp_ast(src: String, i: I32) : ParsedExprAst => {
  let mut left = parse_add_ast(src, i);
  let mut j = left.nextPos;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }

    // `is` narrowing operator (bootstrap subset):
    //   x is Some
    //   x is M::Some
    //   x is not Some
    // Desugars to:
    //   x is Some
    // so the analyzer can reuse its existing `.tag == "Variant"` narrowing logic.
    if (starts_with_at(src, j, "is")) {
      // Require a boundary after `is` so we don't treat identifiers like `island` as the operator.
      let afterIs = j + 2;
      let mut boundaryOk = true;
      if (afterIs < stringLen(src) && is_ident_part(stringCharCodeAt(src, afterIs))) { boundaryOk = false; }
      if (boundaryOk) {
        let mut k0 = skip_ws(src, afterIs);

        // Optional `not` keyword: `x is not Some`
        let mut isNot = false;
        if (starts_with_at(src, k0, "not")) {
          let afterNot = k0 + 3;
          let mut notBoundaryOk = true;
          if (afterNot < stringLen(src) && is_ident_part(stringCharCodeAt(src, afterNot))) { notBoundaryOk = false; }
          if (notBoundaryOk) {
            isNot = true;
            k0 = skip_ws(src, afterNot);
          }
        }

        // Variant name: identifier or module path (`A::B::Some`). Use the last segment.
        let first = parse_ident(src, k0);
        let mut k = first.nextPos;
        let mut variantName = first.text;
        while (true) {
          let t = skip_ws(src, k);
          if (!(t + 1 < stringLen(src))) { break; }
          if (!(stringCharCodeAt(src, t) == 58 && stringCharCodeAt(src, t + 1) == 58)) { break; }
          let next = parse_ident(src, t + 2);
          variantName = next.text;
          k = next.nextPos;
        }

        let start = span_start(expr_span(left.expr));
        let end = k;

        // Generate EIsType node instead of .tag == check
        let isCheck = expr_is_type(span(start, end), left.expr, variantName);
        if (isNot) {
          // `x is not Type` => !(x is Type)
          left = ParsedExprAst(expr_unary(span(start, end), OpNot, isCheck), end);
        } else {
          left = ParsedExprAst(isCheck, end);
        }
        j = left.nextPos;
        continue;
      }
    }

    let c0 = stringCharCodeAt(src, j);
    let c1 = if (j + 1 < stringLen(src)) stringCharCodeAt(src, j + 1) else 0;

    let mut opTag = "";
    let mut op = OpEq;
    let mut adv = 0;

    if (c0 == 61 && c1 == 61) { opTag = "=="; op = OpEq; adv = 2; }
    if (opTag == "" && c0 == 33 && c1 == 61) { opTag = "!="; op = OpNe; adv = 2; }
    if (opTag == "" && c0 == 60 && c1 == 61) { opTag = "<="; op = OpLe; adv = 2; }
    if (opTag == "" && c0 == 62 && c1 == 61) { opTag = ">="; op = OpGe; adv = 2; }
    if (opTag == "" && c0 == 60) { opTag = "<"; op = OpLt; adv = 1; }
    if (opTag == "" && c0 == 62) { opTag = ">"; op = OpGt; adv = 1; }

    if (opTag == "") { break; }

    let rhs = parse_add_ast(src, j + adv);
    let start = span_start(expr_span(left.expr));
    left = ParsedExprAst(expr_binary(span(start, rhs.nextPos), op, left.expr, rhs.expr), rhs.nextPos);
    j = left.nextPos;
  }
  left
}

fn parse_add_ast(src: String, i: I32) : ParsedExprAst => {
  let mut left = parse_mul_ast(src, i);
  let mut j = left.nextPos;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }
    let ch = stringCharCodeAt(src, j);
    if (!(ch == 43 || ch == 45)) { break; } // '+' or '-'
    let rhs = parse_mul_ast(src, j + 1);
    let op = if (ch == 43) OpAdd else OpSub;
    let start = span_start(expr_span(left.expr));
    left = ParsedExprAst(expr_binary(span(start, rhs.nextPos), op, left.expr, rhs.expr), rhs.nextPos);
    j = left.nextPos;
  }
  left
}

fn parse_mul_ast(src: String, i: I32) : ParsedExprAst => {
  let mut left = parse_unary_ast(src, i);
  let mut j = left.nextPos;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }
    let ch = stringCharCodeAt(src, j);
    if (!(ch == 42 || ch == 47)) { break; } // '*' or '/'
    let rhs = parse_unary_ast(src, j + 1);
    let op = if (ch == 42) OpMul else OpDiv;
    let start = span_start(expr_span(left.expr));
    left = ParsedExprAst(expr_binary(span(start, rhs.nextPos), op, left.expr, rhs.expr), rhs.nextPos);
    j = left.nextPos;
  }
  left
}

fn parse_unary_ast(src: String, i: I32) : ParsedExprAst => {
  let j = skip_ws(src, i);
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 33) { // '!'
    let inner = parse_unary_ast(src, j + 1);
    yield ParsedExprAst(expr_unary(span(j, inner.nextPos), OpNot, inner.expr), inner.nextPos);
  }
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 45) { // '-'
    let inner = parse_unary_ast(src, j + 1);
    yield ParsedExprAst(expr_unary(span(j, inner.nextPos), OpNeg, inner.expr), inner.nextPos);
  }
  parse_postfix_ast(src, i)
}

fn parse_postfix_ast(src: String, i: I32) : ParsedExprAst => {
  let mut left = parse_primary_ast(src, i);
  let mut j = left.nextPos;
  let mut pendingTypeArgs = vec_new();
  while (true) {
    j = skip_ws(src, j);

    // Generic call sugar: f<T>(...) or obj.f<T>(...).
    // IMPORTANT: only attempt this before parsing a call; after we already have
    // an ECall on the left, a following '<' should be treated as a comparison
    // operator (e.g. `f(x) < 2`).
    if (left.expr.tag != "ECall" && j < stringLen(src) && stringCharCodeAt(src, j) == 60) { // '<'
      let parsed = try_parse_type_args_for_call_ast(src, j);
      if (parsed.ok) {
        pendingTypeArgs = parsed.typeArgs;
        j = parsed.nextPos;
        continue;
      }
    }

    if (j < stringLen(src) && stringCharCodeAt(src, j) == 40) { // '('
      let args = parse_arg_list_ast(src, j);
      let start = span_start(expr_span(left.expr));
      let callSpan = span(start, args.nextPos);
      if (vec_len(pendingTypeArgs) > 0) {
        left = ParsedExprAst(expr_call_typed(callSpan, left.expr, pendingTypeArgs, args.items), args.nextPos);
        pendingTypeArgs = vec_new();
      } else {
        left = ParsedExprAst(expr_call(callSpan, left.expr, args.items), args.nextPos);
      }
      j = left.nextPos;
      continue;
    }

    if (j < stringLen(src) && stringCharCodeAt(src, j) == 46) { // '.'
      let t = skip_ws(src, j + 1);
      if (t < stringLen(src) && is_digit(stringCharCodeAt(src, t))) {
        let n = parse_number(src, t);
        let start = span_start(expr_span(left.expr));
        left = ParsedExprAst(expr_tuple_index(span(start, n.nextPos), left.expr, n.value), n.nextPos);
        j = left.nextPos;
        continue;
      }
      let next = parse_ident(src, j + 1);
      let start = span_start(expr_span(left.expr));
      left = ParsedExprAst(expr_field(span(start, next.nextPos), left.expr, next.text), next.nextPos);
      j = left.nextPos;
      continue;
    }

    if (j < stringLen(src) && stringCharCodeAt(src, j) == 91) { // '['
      let mut k = parse_keyword(src, j, "[");
      let idx = parse_expr_ast(src, k);
      k = idx.nextPos;
      k = skip_ws(src, k);
      if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 93)) { panic("expected ']'" ); }
      let start = span_start(expr_span(left.expr));
      left = ParsedExprAst(expr_index(span(start, k + 1), left.expr, idx.expr), k + 1);
      j = left.nextPos;
      continue;
    }

    break;
  }
  left
}

fn try_parse_type_args_for_call_ast(src: String, i: I32) : ParsedTypeArgsForCallAst => {
  // Returns ParsedTypeArgsForCallAst(true, typeArgs, endIndexAfterGreaterThan)
  // if `<...>` is balanced and followed by `(` (after ws). Otherwise ok=false.
  let mut k = skip_ws(src, i);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 60)) { // '<'
    yield ParsedTypeArgsForCallAst(false, vec_new(), i);
  }

  // First, do a non-panicking scan to find the matching '>' for this '<'.
  // If we can't find a match, or it isn't followed by '(', this is not a
  // generic call type-arg list (it's probably a comparison operator).
  let mut depth = 1;
  let mut scan = k + 1;
  let mut endGt = -1;
  while (scan < stringLen(src)) {
    let ch = stringCharCodeAt(src, scan);
    if (ch == 60) { depth = depth + 1; }
    if (ch == 62) {
      depth = depth - 1;
      if (depth == 0) { endGt = scan; break; }
    }
    scan = scan + 1;
  }
  if (endGt == -1) { yield ParsedTypeArgsForCallAst(false, vec_new(), i); }

  let after = skip_ws(src, endGt + 1);
  if (!(after < stringLen(src) && stringCharCodeAt(src, after) == 40)) { // '('
    yield ParsedTypeArgsForCallAst(false, vec_new(), i);
  }

  // Parse `<` typeExpr (',' typeExpr)* `>` (now that we know it closes).
  k = k + 1;
  k = skip_ws(src, k);
  let typeArgs = vec_new();

  // Empty type arg list is not allowed here.
  if (k == endGt) { yield ParsedTypeArgsForCallAst(false, vec_new(), i); }

  while (true) {
    let t = parse_type_expr(src, k);
    vec_push(typeArgs, t.v0);
    k = skip_ws(src, t.v1);
    if (k == endGt) {
      // ok: consumed up to '>'
      yield ParsedTypeArgsForCallAst(true, typeArgs, endGt + 1);
    }
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '>' in type args"); }
    let ch = stringCharCodeAt(src, k);
    if (ch == 44) { // ','
      k = k + 1;
      k = skip_ws(src, k);
      continue;
    }
    // We pre-scanned `endGt`, so anything else here is a real parse error.
    panic_at(src, k, "expected ',' or '>' in type args");
  }
  ParsedTypeArgsForCallAst(false, vec_new(), i)
}

fn parse_arg_list_ast(src: String, i: I32) : ParsedExprListAst => {
  // parses: '(' (expr (',' expr)*)? ')'
  let mut k = skip_ws(src, i);
  k = parse_keyword(src, k, "(");
  k = skip_ws(src, k);

  let items = vec_new();
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
    yield ParsedExprListAst(items, k + 1);
  }

  while (true) {
    let e = parse_expr_ast(src, k);
    vec_push(items, e.expr);
    k = skip_ws(src, e.nextPos);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in arg list"); }
    let c = stringCharCodeAt(src, k);
    if (c == 44) { k = k + 1; k = skip_ws(src, k); continue; }
    if (c == 41) { yield ParsedExprListAst(items, k + 1); }
    panic_at(src, k, "expected ',' or ')' in arg list")
  }
  ParsedExprListAst(items, k)
}

fn parse_string_lit_value(src: String, startQuote: I32) : ParsedIdent => {
  // Returns ParsedIdent(text=value, startPos=startQuote, nextPos=endPosAfterQuote)
  // NOTE: We reuse ParsedIdent for convenience.
  let mut k = startQuote + 1;
  let mut out = "";
  while (k < stringLen(src)) {
    let ch = stringCharCodeAt(src, k);
    if (ch == 34) { // '"'
      yield ParsedIdent(out, startQuote, k + 1);
    }
    if (ch == 92) { // '\\'
      k = k + 1;
      if (!(k < stringLen(src))) { panic_at(src, startQuote, "unterminated string"); }
      let esc = stringCharCodeAt(src, k);
      let code = match (esc) {
        110 => 10, // n
        114 => 13, // r
        116 => 9,  // t
        48 => 0,   // 0
        92 => 92,  // \\
        34 => 34,  // "
        _ => esc
      };
      out = out + stringFromCharCode(code);
      k = k + 1;
      continue;
    }
    out = out + stringFromCharCode(ch);
    k = k + 1;
  }
  panic_at(src, startQuote, "unterminated string")
}

fn parse_vec_lit_ast(src: String, i: I32) : ParsedExprAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "[");
  k = skip_ws(src, k);
  let items = vec_new();
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 93) { // ']'
    yield ParsedExprAst(expr_vec_lit(span(start, k + 1), items), k + 1);
  }
  while (true) {
    let e = parse_expr_ast(src, k);
    vec_push(items, e.expr);
    k = skip_ws(src, e.nextPos);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ']' in vec literal"); }
    let ch = stringCharCodeAt(src, k);
    if (ch == 44) { k = k + 1; continue; }
    if (ch == 93) { yield ParsedExprAst(expr_vec_lit(span(start, k + 1), items), k + 1); }
    panic_at(src, k, "expected ',' or ']' in vec literal")
  }
  ParsedExprAst(expr_vec_lit(span(start, k), items), k)
}

fn parse_stmt_block_ast(src: String, i: I32) : ParsedStmtsAst => {
  let mut k = skip_ws(src, i);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 123)) { panic_at(src, k, "expected '{'"); }
  k = k + 1;

  let body = vec_new();
  while (true) {
    let t = skip_ws(src, k);
    if (!(t < stringLen(src))) { panic_at(src, t, "expected '}'"); }
    if (stringCharCodeAt(src, t) == 125) { yield ParsedStmtsAst(body, t + 1); }
    let st = parse_stmt_ast(src, k);
    vec_push(body, st.stmt);
    k = st.nextPos;
  }
  ParsedStmtsAst(body, k)
}

fn scan_if_stmt_has_else(src: String, i: I32) : Bool => {
  // Best-effort scan: recognizes `if (<...>) { <...> } else`.
  // Used only to disambiguate statement-vs-expression parsing in blocks.
  let mut j = skip_ws(src, i);
  if (!starts_with_at(src, j, "if")) { yield false; }
  j = j + 2;
  j = skip_ws(src, j);
  if (!(j < stringLen(src) && stringCharCodeAt(src, j) == 40)) { yield false; } // '('

  // Skip condition parens.
  let mut k = j + 1;
  let mut depth = 1;
  while (k < stringLen(src) && depth > 0) {
    let ch = stringCharCodeAt(src, k);
    if (ch == 34) { // '"'
      k = k + 1;
      while (k < stringLen(src)) {
        let c = stringCharCodeAt(src, k);
        if (c == 92) { k = k + 2; continue; } // '\\'
        if (c == 34) { k = k + 1; break; }
        k = k + 1;
      }
      continue;
    }
    if (ch == 39) { // '\''
      k = k + 1;
      while (k < stringLen(src)) {
        let c = stringCharCodeAt(src, k);
        if (c == 92) { k = k + 2; continue; }
        if (c == 39) { k = k + 1; break; }
        k = k + 1;
      }
      continue;
    }
    if (ch == 40) { depth = depth + 1; k = k + 1; continue; }
    if (ch == 41) { depth = depth - 1; k = k + 1; continue; }
    k = k + 1;
  }

  k = skip_ws(src, k);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 123)) { yield false; } // '{'

  // Skip then block braces.
  k = k + 1;
  let mut bDepth = 1;
  while (k < stringLen(src) && bDepth > 0) {
    let ch = stringCharCodeAt(src, k);
    if (ch == 34) {
      k = k + 1;
      while (k < stringLen(src)) {
        let c = stringCharCodeAt(src, k);
        if (c == 92) { k = k + 2; continue; }
        if (c == 34) { k = k + 1; break; }
        k = k + 1;
      }
      continue;
    }
    if (ch == 39) {
      k = k + 1;
      while (k < stringLen(src)) {
        let c = stringCharCodeAt(src, k);
        if (c == 92) { k = k + 2; continue; }
        if (c == 39) { k = k + 1; break; }
        k = k + 1;
      }
      continue;
    }
    if (ch == 123) { bDepth = bDepth + 1; k = k + 1; continue; }
    if (ch == 125) { bDepth = bDepth - 1; k = k + 1; continue; }
    k = k + 1;
  }

  k = skip_ws(src, k);
  starts_with_at(src, k, "else")
}

fn parse_block_body_ast(src: String, i: I32) : ParsedMainAst => {
  let j = skip_ws(src, i);
  if (!(j < stringLen(src) && stringCharCodeAt(src, j) == 123)) { panic_at(src, j, "expected '{'"); }

  let mut k = j + 1;
  let body = vec_new();

  while (true) {
    let t = skip_ws(src, k);
    if (!(t < stringLen(src))) { panic_at(src, t, "expected '}'"); }
    if (stringCharCodeAt(src, t) == 125) { break; }

    // Disambiguation:
    // - `if` with `else` is an expression; allow it to be a tail expression.
    // - `ident[expr]` is only an index-assign statement if followed by `=`.
    let isStmt = starts_with_at(src, t, "let")
      || starts_with_at(src, t, "fn")
      || starts_with_at(src, t, "while")
      || (starts_with_at(src, t, "if") && !scan_if_stmt_has_else(src, t))
      || starts_with_at(src, t, "yield")
      || is_field_assign_stmt_start_impl(src, t)
      || is_assign_stmt_start_impl(src, t)
      || is_index_assign_stmt_start_impl(src, t);
    if (isStmt) {
      let st = parse_stmt_ast(src, k);
      vec_push(body, st.stmt);
      k = st.nextPos;
      continue;
    }

    // expression statement vs tail expression
    let e = parse_expr_ast(src, k);
    let after = skip_ws(src, e.nextPos);
    if (after < stringLen(src) && stringCharCodeAt(src, after) == 59) {
      vec_push(body, stmt_expr(span(span_start(expr_span(e.expr)), after + 1), e.expr));
      k = after + 1;
      continue;
    }
    if (after < stringLen(src) && stringCharCodeAt(src, after) != 125) {
      vec_push(body, stmt_expr(span(span_start(expr_span(e.expr)), e.nextPos), e.expr));
      k = e.nextPos;
      continue;
    }
    break;
  }

  let t2 = skip_ws(src, k);
  if (t2 < stringLen(src) && stringCharCodeAt(src, t2) == 125) {
    yield ParsedMainAst(body, expr_undefined(span(t2, t2)), t2 + 1);
  }

  let tail = parse_expr_ast(src, k);
  k = skip_ws(src, tail.nextPos);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 125)) { panic_at(src, k, "expected '}'"); }
  ParsedMainAst(body, tail.expr, k + 1)
}

fn parse_block_expr_ast(src: String, i: I32) : ParsedExprAst => {
  let start = skip_ws(src, i);
  let b = parse_block_body_ast(src, start);
  ParsedExprAst(expr_block(span(start, b.nextPos), b.body, b.tail), b.nextPos)
}

fn parse_if_expr_ast(src: String, i: I32) : ParsedExprAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "if");
  k = parse_keyword(src, k, "(");
  let cond = parse_expr_ast(src, k);
  k = cond.nextPos;
  k = parse_keyword(src, k, ")");
  let t1 = skip_ws(src, k);
  let thenE = if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 123) parse_block_expr_ast(src, k) else parse_expr_ast(src, k);
  k = thenE.nextPos;
  k = parse_keyword(src, k, "else");
  let t2 = skip_ws(src, k);
  let elseE = if (t2 < stringLen(src) && stringCharCodeAt(src, t2) == 123) parse_block_expr_ast(src, k) else parse_expr_ast(src, k);
  ParsedExprAst(expr_if(span(start, elseE.nextPos), cond.expr, thenE.expr, elseE.expr), elseE.nextPos)
}

fn parse_match_expr_ast(src: String, i: I32) : ParsedExprAst => {
  let start = skip_ws(src, i);
  let mut k = parse_keyword(src, start, "match");
  k = parse_keyword(src, k, "(");
  let scrut = parse_expr_ast(src, k);
  k = scrut.nextPos;
  k = parse_keyword(src, k, ")");
  k = parse_keyword(src, k, "{");

  let arms = vec_new();
  let mut sawDefault = false;
  let mut sawVariant = false;

  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
    if (stringCharCodeAt(src, k) == 125) { k = k + 1; break; }

    let patStart = k;
    let c0 = stringCharCodeAt(src, k);
    let mut pat = pat_wildcard(span(patStart, patStart));

    if (c0 == 34) {
      let lit = parse_string_lit_value(src, k);
      pat = pat_string(span(patStart, lit.nextPos), lit.text);
      k = lit.nextPos;
    } else {
      if (is_digit(c0)) {
        let n = parse_number(src, k);
        pat = pat_int(span(patStart, n.nextPos), n.value);
        k = n.nextPos;
      } else {
        let id = parse_ident(src, k);
        k = id.nextPos;

        // module path: A::B::C (use the last segment for variant matches)
        let mut name = id.text;
        while (true) {
          let t = skip_ws(src, k);
          if (!(t + 1 < stringLen(src))) { break; }
          if (!(stringCharCodeAt(src, t) == 58 && stringCharCodeAt(src, t + 1) == 58)) { break; }
          let next = parse_ident(src, t + 2);
          name = next.text;
          k = next.nextPos;
        }

        if (id.text == "_") {
          pat = pat_wildcard(span(patStart, k));
        } else {
          if (id.text == "true") {
            pat = pat_bool(span(patStart, k), true);
          } else {
            if (id.text == "false") {
              pat = pat_bool(span(patStart, k), false);
            } else {
              // Union variant pattern.
              pat = pat_variant(span(patStart, k), name);
              sawVariant = true;
            }
          }
        }
      }
    }

    k = parse_keyword(src, k, "=>");
    let t = skip_ws(src, k);
    let armE = if (t < stringLen(src) && stringCharCodeAt(src, t) == 123) parse_block_expr_ast(src, k) else parse_expr_ast(src, k);
    k = armE.nextPos;

    if (pat is MPWildcard) { sawDefault = true; }
    vec_push(arms, mk_match_arm(span(patStart, armE.nextPos), pat, armE.expr));

    k = skip_ws(src, k);
    if (k < stringLen(src)) {
      let ch = stringCharCodeAt(src, k);
      if (ch == 44 || ch == 59) { k = k + 1; }
    }
  }

  // Keep the old bootstrap restriction for non-variant matches.
  if (!sawDefault && !sawVariant) { panic_at(src, k, "match requires _ arm"); }
  ParsedExprAst(expr_match(span(start, k), scrut.expr, arms), k)
}

fn parse_primary_ast(src: String, i: I32) : ParsedExprAst => {
  let j = skip_ws(src, i);
  if (!(j < stringLen(src))) { panic_at(src, j, "expected expression"); }
  let c = stringCharCodeAt(src, j);

  if (starts_with_at(src, j, "if")) { yield parse_if_expr_ast(src, j); }
  if (starts_with_at(src, j, "match")) { yield parse_match_expr_ast(src, j); }
  if (c == 91) { yield parse_vec_lit_ast(src, j); }
  if (c == 123) { yield parse_block_expr_ast(src, j); }

  if (c == 39) { // char literal
    let start = j;
    let mut k = j + 1;
    if (!(k < stringLen(src))) { panic_at(src, start, "unterminated char literal"); }
    let mut code: I32 = 0;
    let ch0 = stringCharCodeAt(src, k);
    if (ch0 == 92) {
      k = k + 1;
      if (!(k < stringLen(src))) { panic_at(src, start, "unterminated char escape"); }
      let esc = stringCharCodeAt(src, k);
      code = match (esc) {
        110 => 10,
        114 => 13,
        116 => 9,
        48 => 0,
        92 => 92,
        39 => 39,
        34 => 34,
        _ => { panic_at(src, k, "unknown char escape"); 0 }
      };
      k = k + 1;
    } else {
      code = ch0;
      k = k + 1;
    }
    if (!(k < stringLen(src))) { panic_at(src, start, "unterminated char literal"); }
    if (stringCharCodeAt(src, k) != 39) { panic_at(src, start, "char literal must contain exactly one character"); }
    yield ParsedExprAst(expr_int(span(start, k + 1), code), k + 1);
  }

  if (c == 34) { // string literal
    let lit = parse_string_lit_value(src, j);
    yield ParsedExprAst(expr_string(span(j, lit.nextPos), lit.text), lit.nextPos);
  }

  if (c == 40) { // '('
    // Disambiguate lambdas from parenthesized expressions / tuples.
    // Lambdas are recognized by what comes *after* the matching ')':
    //   (params) => body
    //   (params) : Ret => body
    let rp = find_matching_rparen(src, j);
    if (rp != -1) {
      let after = skip_ws(src, rp + 1);
      if (after + 1 < stringLen(src) && stringCharCodeAt(src, after) == 61 && stringCharCodeAt(src, after + 1) == 62) {
        yield parse_lambda_expr_ast(src, j);
      }
      // ':' (optional return annotation) followed by '=>'
      if (after < stringLen(src) && stringCharCodeAt(src, after) == 58) {
        yield parse_lambda_expr_ast(src, j);
      }
    }

    let first = parse_expr_ast(src, j + 1);
    let mut k = skip_ws(src, first.nextPos);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) {
      yield ParsedExprAst(first.expr, k + 1);
    }
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 44) {
      let items = vec_new();
      vec_push(items, first.expr);
      while (true) {
        k = k + 1;
        k = skip_ws(src, k);
        if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) {
          yield ParsedExprAst(expr_tuple_lit(span(j, k + 1), items), k + 1);
        }
        let e = parse_expr_ast(src, k);
        vec_push(items, e.expr);
        k = skip_ws(src, e.nextPos);
        if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in tuple literal"); }
        let ch = stringCharCodeAt(src, k);
        if (ch == 44) { continue; }
        if (ch == 41) { yield ParsedExprAst(expr_tuple_lit(span(j, k + 1), items), k + 1); }
        panic_at(src, k, "expected ',' or ')' in tuple literal")
      }
    }
    panic_at_help(src, k, "expected ')'", "Add ')' to close the opening '('.")
  }

  if (is_digit(c)) {
    // Float literal: <digits> '.' <digits> [F32|F64]
    // Parse this before falling back to integer parsing so `2.0` doesn't get
    // interpreted as tuple indexing on the integer literal `2`.
    let mut k = j;
    while (k < stringLen(src) && is_digit(stringCharCodeAt(src, k))) {
      k = k + 1;
    }
    if (k + 1 < stringLen(src) && stringCharCodeAt(src, k) == 46 && is_digit(stringCharCodeAt(src, k + 1))) { // '.'
      let mut m = k + 1;
      while (m < stringLen(src) && is_digit(stringCharCodeAt(src, m))) {
        m = m + 1;
      }
      let text = stringSlice(src, j, m);

      // Check for optional suffix (F32 or F64)
      let mut suffix = "";
      let mut endPos = m;
      if (m + 2 < stringLen(src)) {
        let s1 = stringSlice(src, m, m + 3);
        if (s1 == "F32") {
          suffix = "F32";
          endPos = m + 3;
        } else {
          if (s1 == "F64") {
            suffix = "F64";
            endPos = m + 3;
          }
        }
      }

      yield ParsedExprAst(expr_float(span(j, endPos), text, suffix), endPos);
    }

    let n = parse_number(src, j);
    yield ParsedExprAst(expr_int(span(j, n.nextPos), n.value), n.nextPos);
  }

  if (is_ident_start(c)) {
    let id = parse_ident(src, j);
    let mut k = id.nextPos;

    // module path: A::B::C
    let parts = vec_new();
    vec_push(parts, id.text);
    while (true) {
      let t = skip_ws(src, k);
      if (!(t + 1 < stringLen(src))) { break; }
      if (!(stringCharCodeAt(src, t) == 58 && stringCharCodeAt(src, t + 1) == 58)) { break; }
      let next = parse_ident(src, t + 2);
      vec_push(parts, next.text);
      k = next.nextPos;
    }

    // Struct literal: Name { <expr>, ... }
    let t2 = skip_ws(src, k);
    if (t2 < stringLen(src) && stringCharCodeAt(src, t2) == 123) {
      let vals = parse_struct_lit_values_ast(src, t2);
      let nameExpr = expr_path(span(j, k), parts);
      yield ParsedExprAst(expr_struct_lit(span(j, vals.nextPos), nameExpr, vals.items), vals.nextPos);
    }

    // Plain identifier or module path
    if (vec_len(parts) == 1) {
      yield ParsedExprAst(expr_ident(span(j, k), vec_get(parts, 0)), k);
    }
    yield ParsedExprAst(expr_path(span(j, k), parts), k);
  }

  let mut end = j + 32;
  if (end > stringLen(src)) { end = stringLen(src); }
  panic_at(src, j, "expected expression near '" + stringSlice(src, j, end) + "'")
}

fn parse_struct_lit_values_ast(src: String, i: I32) : ParsedExprListAst => {
  // Parses: '{' (expr (',' expr)*)? '}'
  let mut k = skip_ws(src, i);
  k = parse_keyword(src, k, "{");
  k = skip_ws(src, k);
  let items = vec_new();
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 125) {
    yield ParsedExprListAst(items, k + 1);
  }
  while (true) {
    let e = parse_expr_ast(src, k);
    vec_push(items, e.expr);
    k = skip_ws(src, e.nextPos);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ',' or '}' in struct literal"); }
    let ch = stringCharCodeAt(src, k);
    if (ch == 44) { k = k + 1; continue; }
    if (ch == 125) { yield ParsedExprListAst(items, k + 1); }
    panic_at(src, k, "expected ',' or '}' in struct literal")
  }
  ParsedExprListAst(items, k)
}

fn parse_stmt_ast(src: String, i: I32) : ParsedStmtAst => {
  let mut k = skip_ws(src, i);
  let start = k;

  // yield / early return
  if (starts_with_at(src, k, "yield")) {
    k = parse_keyword(src, k, "yield");
    k = skip_ws(src, k);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 59) {
      yield ParsedStmtAst(stmt_yield(span(start, k + 1), expr_undefined(span(k, k))), k + 1);
    }
    let e = parse_expr_ast(src, k);
    k = parse_optional_semicolon(src, e.nextPos);
    yield ParsedStmtAst(stmt_yield(span(start, k), e.expr), k);
  }

  // let / let mut
  if (starts_with_at(src, k, "let")) {
    k = parse_keyword(src, k, "let");
    let mutOpt = parse_mut_opt_impl(src, k);
    k = mutOpt.nextPos;
    let name = parse_ident(src, k);
    k = name.nextPos;
    if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }
    let mut tyAnn = "";
    let t0 = skip_ws(src, k);
    if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) {
      let _ty = parse_type_expr(src, t0 + 1);
      tyAnn = _ty.v0;
      k = _ty.v1;
    }
    k = parse_keyword(src, k, "=");
    let e = parse_expr_ast(src, k);
    k = parse_optional_semicolon(src, e.nextPos);
    if (tyAnn == "") {
      yield ParsedStmtAst(stmt_let(span(start, k), mutOpt.ok, name.text, e.expr), k);
    }
    yield ParsedStmtAst(stmt_let_typed(span(start, k), mutOpt.ok, name.text, tyAnn, e.expr), k);
  }

  // local function declaration (statement):
  //   fn name(params...) (: RetTy)? => body;
  // Desugars to an immutable `let` bound to a lambda.
  if (starts_with_at(src, k, "fn")) {
    k = parse_keyword(src, k, "fn");
    let name = parse_ident(src, k);
    k = name.nextPos;
    if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

    // Optional generic params: fn id<T, U>(...)
    let mut typeParams = vec_new();
    let t0 = skip_ws(src, k);
    if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) { // '<'
      let tp = parse_type_param_names_list_ast(src, t0);
      typeParams = tp.typeParams;
      k = tp.nextPos;
    }

    // Parse params: (name (':' Type)? (',' ... )?)
    k = parse_keyword(src, k, "(");
    k = skip_ws(src, k);

    let params = vec_new();
    let paramTyAnns = vec_new();

    if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
      k = k + 1;
    } else {
      while (true) {
        let p = parse_ident(src, k);
        vec_push(params, p.text);
        k = skip_ws(src, p.nextPos);

        // Optional parameter type annotation.
        let mut tyAnn = "";
        if (k < stringLen(src) && stringCharCodeAt(src, k) == 58) { // ':'
          k = parse_keyword(src, k, ":");
          let ty = parse_type_expr(src, k);
          tyAnn = ty.v0;
          k = ty.v1;
        }
        vec_push(paramTyAnns, tyAnn);
        k = skip_ws(src, k);

        if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in fn params"); }
        let ch = stringCharCodeAt(src, k);
        if (ch == 44) { // ','
          k = k + 1;
          k = skip_ws(src, k);
          // Allow trailing comma: fn f(a: I32,)
          if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
            k = k + 1;
            break;
          }
          continue;
        }
        if (ch == 41) { // ')'
          k = k + 1;
          break;
        }
        panic_at(src, k, "expected ',' or ')' in fn params")
      }
    }

    // Optional return type annotation: `: Type`
    k = skip_ws(src, k);
    let mut retTyAnn = "";
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 58) { // ':'
      k = parse_keyword(src, k, ":");
      let ret = parse_type_expr(src, k);
      retTyAnn = ret.v0;
      k = ret.v1;
    }

    k = parse_keyword(src, k, "=>");
    let bodyStart = skip_ws(src, k);
    let body = parse_main_body_ast(src, k);
    k = body.nextPos;

    let bodyExpr = if (vec_len(body.body) == 0) body.tail else expr_block(span(bodyStart, body.nextPos), body.body, body.tail);
    let lam = expr_lambda(span(start, body.nextPos), typeParams, params, paramTyAnns, retTyAnn, bodyExpr);

    k = parse_optional_semicolon(src, k);
    yield ParsedStmtAst(stmt_let(span(start, k), false, name.text, lam), k);
  }

  // while (...) { ... }
  if (starts_with_at(src, k, "while")) {
    k = parse_keyword(src, k, "while");
    k = parse_keyword(src, k, "(");
    let cond = parse_expr_ast(src, k);
    k = parse_keyword(src, cond.nextPos, ")");
    let body = parse_stmt_block_ast(src, k);
    k = parse_optional_semicolon(src, body.nextPos);
    yield ParsedStmtAst(stmt_while(span(start, k), cond.expr, body.stmts), k);
  }

  // if (...) { ... } (else { ... })?
  if (starts_with_at(src, k, "if")) {
    k = parse_keyword(src, k, "if");
    k = parse_keyword(src, k, "(");
    let cond = parse_expr_ast(src, k);
    k = parse_keyword(src, cond.nextPos, ")");
    let thenB = parse_stmt_block_ast(src, k);
    k = thenB.nextPos;
    let j = skip_ws(src, k);
    if (starts_with_at(src, j, "else")) {
      k = parse_keyword(src, k, "else");
      let elseB = parse_stmt_block_ast(src, k);
      k = parse_optional_semicolon(src, elseB.nextPos);
      yield ParsedStmtAst(stmt_if(span(start, k), cond.expr, thenB.stmts, true, elseB.stmts), k);
    }
    k = parse_optional_semicolon(src, k);
    yield ParsedStmtAst(stmt_if(span(start, k), cond.expr, thenB.stmts, false, vec_new()), k);
  }

  // assignment: <ident> = <expr>;
  if (is_assign_stmt_start_impl(src, k)) {
    let name = parse_ident(src, k);
    k = parse_keyword(src, name.nextPos, "=");
    let e = parse_expr_ast(src, k);
    k = parse_optional_semicolon(src, e.nextPos);
    yield ParsedStmtAst(stmt_assign(span(start, k), name.text, e.expr), k);
  }

  // field assignment: <ident>.<field>(.<field>)* = <expr>;
  if (is_field_assign_stmt_start_impl(src, k)) {
    let base = parse_ident(src, k);
    k = base.nextPos;
    let fields = vec_new();
    while (true) {
      let t = skip_ws(src, k);
      if (!(t < stringLen(src) && stringCharCodeAt(src, t) == 46)) { break; }
      k = parse_keyword(src, k, ".");
      let part = parse_ident(src, k);
      vec_push(fields, part.text);
      k = part.nextPos;
    }
    k = parse_keyword(src, k, "=");
    let e = parse_expr_ast(src, k);
    k = parse_optional_semicolon(src, e.nextPos);
    let baseExpr = expr_ident(span(base.startPos, base.nextPos), base.text);
    yield ParsedStmtAst(stmt_field_assign(span(start, k), baseExpr, fields, e.expr), k);
  }

  // index assignment: <ident>[<expr>] = <expr>;
  if (is_index_assign_stmt_start_impl(src, k)) {
    let name = parse_ident(src, k);
    k = parse_keyword(src, name.nextPos, "[");
    let idx = parse_expr_ast(src, k);
    k = parse_keyword(src, idx.nextPos, "]");
    k = parse_keyword(src, k, "=");
    let val = parse_expr_ast(src, k);
    k = parse_optional_semicolon(src, val.nextPos);
    let baseExpr = expr_ident(span(name.startPos, name.nextPos), name.text);
    yield ParsedStmtAst(stmt_index_assign(span(start, k), baseExpr, idx.expr, val.expr), k);
  }

  // expression statement
  let e = parse_expr_ast(src, k);
  k = parse_optional_semicolon(src, e.nextPos);
  ParsedStmtAst(stmt_expr(span(start, k), e.expr), k)
}

fn parse_main_body_ast(src: String, i: I32) : ParsedMainAst => {
  let j = skip_ws(src, i);
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 123) {
    let b = parse_block_body_ast(src, i);
    yield b;
  }
  let e = parse_expr_ast(src, i);
  ParsedMainAst(vec_new(), e.expr, e.nextPos)
}
