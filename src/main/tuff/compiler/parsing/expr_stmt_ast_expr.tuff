// Selfhost compiler: expression parsing precedence chain (AST-producing path).
// Split out of expr_stmt_ast.tuff.

extern from rt::stdlib use { stringLen, stringCharCodeAt };

from util::lexing use { skip_ws, starts_with_at, is_ident_part };
from parsing::primitives use { parse_ident };

from parsing::expr_stmt_types use { ParsedExprAst };
from parsing::expr_stmt_ast_postfix use { parse_postfix_ast };

from ast use {
  span,
  span_start,
  expr_span,

  expr_field,
  expr_string,
  expr_unary,
  expr_binary,
  expr_is_type,

  OpOr,
  OpAnd,
  OpEq,
  OpNe,
  OpLt,
  OpLe,
  OpGt,
  OpGe,
  OpAdd,
  OpSub,
  OpMul,
  OpDiv,
  OpNot,
  OpNeg
};

out fn parse_expr_ast_impl(src: String, i: I32) : ParsedExprAst => parse_or_ast(src, i)

fn parse_or_ast(src: String, i: I32) : ParsedExprAst => {
  let mut left = parse_and_ast(src, i);
  let mut j = left.nextPos;
  while (true) {
    j = skip_ws(src, j);
    if (!(j + 1 < stringLen(src))) { break; }
    if (stringCharCodeAt(src, j) == 124 && stringCharCodeAt(src, j + 1) == 124) { // '||'
      let rhs = parse_and_ast(src, j + 2);
      let start = span_start(expr_span(left.expr));
      left = ParsedExprAst(expr_binary(span(start, rhs.nextPos), OpOr, left.expr, rhs.expr), rhs.nextPos);
      j = left.nextPos;
      continue;
    }
    break;
  }
  left
}

fn parse_and_ast(src: String, i: I32) : ParsedExprAst => {
  let mut left = parse_cmp_ast(src, i);
  let mut j = left.nextPos;
  while (true) {
    j = skip_ws(src, j);
    if (!(j + 1 < stringLen(src))) { break; }
    if (stringCharCodeAt(src, j) == 38 && stringCharCodeAt(src, j + 1) == 38) { // '&&'
      let rhs = parse_cmp_ast(src, j + 2);
      let start = span_start(expr_span(left.expr));
      left = ParsedExprAst(expr_binary(span(start, rhs.nextPos), OpAnd, left.expr, rhs.expr), rhs.nextPos);
      j = left.nextPos;
      continue;
    }
    break;
  }
  left
}

fn parse_cmp_ast(src: String, i: I32) : ParsedExprAst => {
  let mut left = parse_add_ast(src, i);
  let mut j = left.nextPos;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }

    // `is` narrowing operator (bootstrap subset):
    //   x is Some
    //   x is M::Some
    //   x is not Some
    // Desugars to:
    //   x is Some
    // so the analyzer can reuse its existing `.tag == "Variant"` narrowing logic.
    if (starts_with_at(src, j, "is")) {
      // Require a boundary after `is` so we don't treat identifiers like `island` as the operator.
      let afterIs = j + 2;
      let mut boundaryOk = true;
      if (afterIs < stringLen(src) && is_ident_part(stringCharCodeAt(src, afterIs))) { boundaryOk = false; }
      if (boundaryOk) {
        let mut k0 = skip_ws(src, afterIs);

        // Optional `not` keyword: `x is not Some`
        let mut isNot = false;
        if (starts_with_at(src, k0, "not")) {
          let afterNot = k0 + 3;
          let mut notBoundaryOk = true;
          if (afterNot < stringLen(src) && is_ident_part(stringCharCodeAt(src, afterNot))) { notBoundaryOk = false; }
          if (notBoundaryOk) {
            isNot = true;
            k0 = skip_ws(src, afterNot);
          }
        }

        // Variant name: identifier or module path (`A::B::Some`). Use the last segment.
        let first = parse_ident(src, k0);
        let mut k = first.nextPos;
        let mut variantName = first.text;
        while (true) {
          let t = skip_ws(src, k);
          if (!(t + 1 < stringLen(src))) { break; }
          if (!(stringCharCodeAt(src, t) == 58 && stringCharCodeAt(src, t + 1) == 58)) { break; }
          let next = parse_ident(src, t + 2);
          variantName = next.text;
          k = next.nextPos;
        }

        let start = span_start(expr_span(left.expr));
        let end = k;

        // Generate EIsType node instead of .tag == check
        let isCheck = expr_is_type(span(start, end), left.expr, variantName);
        if (isNot) {
          // `x is not Type` => !(x is Type)
          left = ParsedExprAst(expr_unary(span(start, end), OpNot, isCheck), end);
        } else {
          left = ParsedExprAst(isCheck, end);
        }
        j = left.nextPos;
        continue;
      }
    }

    let c0 = stringCharCodeAt(src, j);
    let c1 = if (j + 1 < stringLen(src)) stringCharCodeAt(src, j + 1) else 0;

    let mut opTag = "";
    let mut op = OpEq;
    let mut adv = 0;

    if (c0 == 61 && c1 == 61) { opTag = "=="; op = OpEq; adv = 2; }
    if (opTag == "" && c0 == 33 && c1 == 61) { opTag = "!="; op = OpNe; adv = 2; }
    if (opTag == "" && c0 == 60 && c1 == 61) { opTag = "<="; op = OpLe; adv = 2; }
    if (opTag == "" && c0 == 62 && c1 == 61) { opTag = ">="; op = OpGe; adv = 2; }
    if (opTag == "" && c0 == 60) { opTag = "<"; op = OpLt; adv = 1; }
    if (opTag == "" && c0 == 62) { opTag = ">"; op = OpGt; adv = 1; }

    if (opTag == "") { break; }

    let rhs = parse_add_ast(src, j + adv);
    let start = span_start(expr_span(left.expr));
    left = ParsedExprAst(expr_binary(span(start, rhs.nextPos), op, left.expr, rhs.expr), rhs.nextPos);
    j = left.nextPos;
  }
  left
}

fn parse_add_ast(src: String, i: I32) : ParsedExprAst => {
  let mut left = parse_mul_ast(src, i);
  let mut j = left.nextPos;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }
    let ch = stringCharCodeAt(src, j);
    if (!(ch == 43 || ch == 45)) { break; } // '+' or '-'
    let rhs = parse_mul_ast(src, j + 1);
    let op = if (ch == 43) OpAdd else OpSub;
    let start = span_start(expr_span(left.expr));
    left = ParsedExprAst(expr_binary(span(start, rhs.nextPos), op, left.expr, rhs.expr), rhs.nextPos);
    j = left.nextPos;
  }
  left
}

fn parse_mul_ast(src: String, i: I32) : ParsedExprAst => {
  let mut left = parse_unary_ast(src, i);
  let mut j = left.nextPos;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }
    let ch = stringCharCodeAt(src, j);
    if (!(ch == 42 || ch == 47)) { break; } // '*' or '/'
    let rhs = parse_unary_ast(src, j + 1);
    let op = if (ch == 42) OpMul else OpDiv;
    let start = span_start(expr_span(left.expr));
    left = ParsedExprAst(expr_binary(span(start, rhs.nextPos), op, left.expr, rhs.expr), rhs.nextPos);
    j = left.nextPos;
  }
  left
}

fn parse_unary_ast(src: String, i: I32) : ParsedExprAst => {
  let j = skip_ws(src, i);
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 33) { // '!'
    let inner = parse_unary_ast(src, j + 1);
    yield ParsedExprAst(expr_unary(span(j, inner.nextPos), OpNot, inner.expr), inner.nextPos);
  }
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 45) { // '-'
    let inner = parse_unary_ast(src, j + 1);
    yield ParsedExprAst(expr_unary(span(j, inner.nextPos), OpNeg, inner.expr), inner.nextPos);
  }
  parse_postfix_ast(src, i)
}
