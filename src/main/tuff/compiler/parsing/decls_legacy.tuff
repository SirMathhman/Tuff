// Selfhost compiler: legacy declaration parsing (string-emission path).
// These functions parse declarations and emit JS strings directly.
// Used by the legacy compilation path before the AST-based pipeline.

extern from rt::stdlib use { stringLen, stringSlice, stringCharCodeAt };
extern from rt::vec use { vec_new, vec_push };

from util::diagnostics use {
  panic_at,
  add_struct_def,
  is_identifier_too_short,
  warn_short_identifier
};

from util::lexing use { is_ident_part, skip_ws, starts_with_at };

from parsing::primitives use {
  parse_ident,
  parse_keyword,
  parse_module_path,
  module_path_to_relpath,
  parse_optional_semicolon
};

from parsing::types use { parse_type_expr, skip_angle_brackets };

from parsing::expr_stmt_types use { ParsedParams, ParsedStmt };

from parsing::expr_stmt use { parse_main_body };

out class fn ParsedImports(v0: String, v1: I32) => {}
out class fn ParsedFn(v0: String, v1: I32, v2: String) => {}

out fn parse_param_list(src: String, i: I32) : ParsedParams => {
  // parses: '(' (ident (',' ident)*)? ')'
  let mut k = parse_keyword(src, i, "(");
  k = skip_ws(src, k);
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
    yield ParsedParams("", k + 1);
  }
  let mut out = "";
  let mut first = true;
  while (true) {
    let id = parse_ident(src, k);
    k = id.nextPos;

    // Optional param type annotation: `name: Type`
    let t0 = skip_ws(src, k);
    if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) { // ':'
      let _ty = parse_type_expr(src, t0 + 1);
      k = _ty.v1;
    }

    if (first) { out = out + id.text; } else { out = out + ", " + id.text; }
    first = false;

    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected ')' in param list"); }
    let c = stringCharCodeAt(src, k);
    if (c == 44) { // ','
      k = k + 1;
      continue;
    }
    if (c == 41) { // ')'
      yield ParsedParams(out, k + 1);
    }
    panic_at(src, k, "expected ',' or ')' in param list")
  }
  ParsedParams(out, k)
}

out fn parse_extern_decl(src: String, i: I32) : ParsedStmt => {
  let mut k = i;
  let j0 = skip_ws(src, k);
  if (starts_with_at(src, j0, "out")) {
    // `out extern ...` (only meaningful for types today).
    k = parse_keyword(src, k, "out");
  }
  k = parse_keyword(src, k, "extern");
  let j1 = skip_ws(src, k);

  // `extern type ...;` has no JS import emission.
  if (starts_with_at(src, j1, "type")) {
    k = parse_keyword(src, k, "type");
    let _name = parse_ident(src, k);
    k = _name.nextPos;
    let t0 = skip_ws(src, k);
    if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) { // '<'
      k = skip_angle_brackets(src, t0);
    }
    k = parse_optional_semicolon(src, k);
    yield ParsedStmt("", k);
  }

  // `extern from <module> use { ... };`
  k = parse_keyword(src, k, "from");
  let mod = parse_module_path(src, k);
  k = mod.nextPos;
  k = parse_keyword(src, k, "use");
  k = parse_keyword(src, k, "{");

  let mut names = "";
  let mut first = true;
  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
    if (stringCharCodeAt(src, k) == 125) { k = k + 1; break; }
    let id = parse_ident(src, k);
    k = id.nextPos;
    if (first) { names = names + id.text; } else { names = names + ", " + id.text; }
    first = false;
    k = skip_ws(src, k);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 44) { k = k + 1; continue; }
    k = skip_ws(src, k);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 125) { k = k + 1; break; }
    panic_at(src, k, "expected ',' or '}' in extern list");
  }

  k = parse_optional_semicolon(src, k);

  let mut importPath = "";
  if (starts_with_at(mod.text, 0, "rt::")) { importPath = "./rt/" + stringSlice(mod.text, 4, stringLen(mod.text)) + ".mjs"; }
  if (importPath == "" && starts_with_at(mod.text, 0, "node::")) { importPath = "node:" + stringSlice(mod.text, 6, stringLen(mod.text)); }
  if (importPath == "") { panic_at(src, k, "unsupported extern module: " + mod.text); }

  ParsedStmt("import { " + names + " } from \"" + importPath + "\";\n", k)
}

out fn parse_imports(src: String, i: I32) : ParsedImports => {
  let mut k = i;
  let mut out = "";
  while (true) {
    let j = skip_ws(src, k);
    if (starts_with_at(src, j, "import")) {
      panic_at(src, j, "`import` is not supported. Use `from <module> use { ... };` instead.");
    }
    if (!starts_with_at(src, j, "from")) { break; }

    k = parse_keyword(src, k, "from");
    let mod = parse_module_path(src, k);
    k = mod.nextPos;
    k = parse_keyword(src, k, "use");
    k = parse_keyword(src, k, "{");

    let mut names = "";
    let mut first = true;
    while (true) {
      k = skip_ws(src, k);
      if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
      if (stringCharCodeAt(src, k) == 125) { k = k + 1; break; }
      let id = parse_ident(src, k);
      k = id.nextPos;
      if (first) { names = names + id.text; } else { names = names + ", " + id.text; }
      first = false;
      k = skip_ws(src, k);
      if (k < stringLen(src) && stringCharCodeAt(src, k) == 44) { k = k + 1; continue; }
      k = skip_ws(src, k);
      if (k < stringLen(src) && stringCharCodeAt(src, k) == 125) { k = k + 1; break; }
      panic_at(src, k, "expected ',' or '}' in import list");
    }

    k = parse_optional_semicolon(src, k);

    let importPath = "./" + module_path_to_relpath(mod.text) + ".mjs";
    out = out + ("import { " + names + " } from \"" + importPath + "\";\n");
  }
  ParsedImports(out, k)
}

out fn parse_fn_decl_named(src: String, i: I32, jsName: String, exportThis: Bool) : ParsedFn => {
  let mut k = parse_keyword(src, i, "fn");
  let name = parse_ident(src, k);
  k = name.nextPos;

  // Optional generic params: fn name<T, U>(...)
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) { // '<'
    k = skip_angle_brackets(src, t0);
  }

  let params = parse_param_list(src, k);
  k = params.v1;

  // Optional return type: : Type
  let t1 = skip_ws(src, k);
  if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 58) { // ':'
    let _rt = parse_type_expr(src, t1 + 1);
    k = _rt.v1;
  }

  k = parse_keyword(src, k, "=>");
  let body = parse_main_body(src, k);
  k = body.v1;

  let exportKw = if (exportThis) "export " else "";
  let js = exportKw + "function " + jsName + "(" + params.v0 + ") {\n" + body.body + "return " + body.expr + ";\n}\n";
  ParsedFn(js, k, name.text)
}

out fn parse_module_decl(src: String, i: I32, prefix: String, exportTop: Bool) : ParsedStmt => {
  // module Name { (fn ... | module ...)* }
  let mut k = parse_keyword(src, i, "module");
  let modName = parse_ident(src, k);
  k = modName.nextPos;
  k = parse_keyword(src, k, "{");

  let mut decls = "";
  let mut entries = "";
  let mut first = true;

  while (true) {
    let t = skip_ws(src, k);
    if (!(t < stringLen(src))) { panic_at(src, t, "expected '}'"); }
    if (stringCharCodeAt(src, t) == 125) { k = t + 1; break; }

    if (starts_with_at(src, t, "fn")) {
      let fnParsed = parse_fn_decl_named(src, k, prefix + "__" + modName.text + "__" + "fn" + "__" + "tmp", false);
      // we emitted with a temp name; re-emit with stable js name including function name
      // (parse again from the same start)
      let fn2 = parse_fn_decl_named(src, k, prefix + "__" + modName.text + "__" + fnParsed.v2, false);
      decls = decls + fn2.v0;
      if (first) { entries = entries + (fn2.v2 + ": " + (prefix + "__" + modName.text + "__" + fn2.v2)); }
      else { entries = entries + (", " + fn2.v2 + ": " + (prefix + "__" + modName.text + "__" + fn2.v2)); }
      first = false;
      k = fn2.v1;
      continue;
    }

    if (starts_with_at(src, t, "module")) {
      let inner = parse_module_decl(src, k, prefix + "__" + modName.text, false);
      decls = decls + inner.v0;
      // inner module exports as const with its own name; include it as property
      // since `exportTop` is false here, inner will be `const <Inner> = {...}`
      // and we reference that name.
      let innerName = parse_ident(src, parse_keyword(src, k, "module"));
      // NOTE: parse_ident above is safe since parse_module_decl already parsed it; this is a tiny hack to recover name.
      let prop = innerName.text;
      if (first) { entries = entries + (prop + ": " + prop); }
      else { entries = entries + (", " + prop + ": " + prop); }
      first = false;
      k = inner.v1;
      continue;
    }

    panic_at(src, t, "expected fn or module inside module")
  }

  let obj = "{ " + entries + " }";
  let header = if (exportTop) "export const " else "const ";
  let code = decls + header + modName.text + " = " + obj + ";\n";
  ParsedStmt(code, k)
}

out fn parse_fn_decl2(src: String, i: I32, exportAll: Bool) : ParsedStmt => {
  let mut k = parse_keyword(src, i, "fn");
  let name = parse_ident(src, k);
  k = name.nextPos;
  if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

  // Optional generic params: fn name<T, U>(...)
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) { // '<'
    k = skip_angle_brackets(src, t0);
  }

  let params = parse_param_list(src, k);
  k = params.v1;

  // Optional return type: : Type
  let t1 = skip_ws(src, k);
  if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 58) { // ':'
    let _rt = parse_type_expr(src, t1 + 1);
    k = _rt.v1;
  }

  k = parse_keyword(src, k, "=>");
  let body = parse_main_body(src, k);
  k = body.v1;

  let exportKw = if (exportAll || name.text == "main") "export " else "";
  let js = exportKw + "function " + name.text + "(" + params.v0 + ") {\n" + body.body + "return " + body.expr + ";\n}\n";
  ParsedStmt(js, k)
}

out fn parse_class_fn_decl2(src: String, i: I32, exportAll: Bool) : ParsedStmt => {
  let mut k = parse_keyword(src, i, "class");
  k = parse_keyword(src, k, "fn");
  let name = parse_ident(src, k);
  k = name.nextPos;
  if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

  // Optional generic params: class fn name<T, U>(...)
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) { // '<'
    k = skip_angle_brackets(src, t0);
  }

  let params = parse_param_list(src, k);
  k = params.v1;

  // Optional return type: : Type
  let t1 = skip_ws(src, k);
  if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 58) { // ':'
    let _rt = parse_type_expr(src, t1 + 1);
    k = _rt.v1;
  }

  k = parse_keyword(src, k, "=>");
  let body = parse_main_body(src, k);
  k = body.v1;

  // Minimal `class fn` lowering: execute body statements then yield `this`.
  // For now, `this` is just an object containing parameters.
  // (This is sufficient for our compiler's internal record-like classes.)
  let exportKw = if (exportAll || name.text == "main") "export " else "";
  let mut fields = "";
  // params.v0 is the comma-joined param list; we need `{ a: a, b: b }`.
  // Build it by re-parsing the param list text.
  let mut pi = 0;
  let mut first = true;
  while (pi < stringLen(params.v0)) {
    // skip spaces/commas
    while (pi < stringLen(params.v0)) {
      let ch = stringCharCodeAt(params.v0, pi);
      if (ch == 32 || ch == 9 || ch == 10 || ch == 13 || ch == 44) { pi = pi + 1; continue; }
      break;
    }
    if (!(pi < stringLen(params.v0))) { break; }
    let start = pi;
    while (pi < stringLen(params.v0)) {
      let ch = stringCharCodeAt(params.v0, pi);
      if (ch == 44) { break; }
      pi = pi + 1;
    }
    let p = stringSlice(params.v0, start, pi);
    // trim trailing spaces
    let mut end = stringLen(p);
    while (end > 0) {
      let ch = stringCharCodeAt(p, end - 1);
      if (ch == 32 || ch == 9 || ch == 10 || ch == 13) { end = end - 1; continue; }
      break;
    }
    let nameOnly = stringSlice(p, 0, end);
    if (nameOnly != "") {
      if (first) { fields = fields + (nameOnly + ": " + nameOnly); }
      else { fields = fields + (", " + nameOnly + ": " + nameOnly); }
      first = false;
    }
  }

  // Also include `let`/`const` locals from the generated JS body.
  // This is a simple text scan over `body.body` (which is JS), used only by
  // the tiny compiler path.
  let mut bi = 0;
  while (bi < stringLen(body.body)) {
    // Find "let " or "const ".
    if (starts_with_at(body.body, bi, "let ") || starts_with_at(body.body, bi, "const ")) {
      bi = bi + (if (starts_with_at(body.body, bi, "let ")) 4 else 6);
      // Read identifier
      let start2 = bi;
      while (bi < stringLen(body.body) && is_ident_part(stringCharCodeAt(body.body, bi))) {
        bi = bi + 1;
      }
      let n = stringSlice(body.body, start2, bi);
      // Avoid duplicates: look for the exact substring "<name>: <name>".
      let mut already = false;
      if (n != "") {
        let pat = n + ": " + n;
        let mut si = 0;
        while (si + stringLen(pat) <= stringLen(fields)) {
          if (stringSlice(fields, si, si + stringLen(pat)) == pat) {
            already = true;
            si = stringLen(fields);
          } else {
            si = si + 1;
          }
        }
      }
      if (n != "" && !already) {
        if (first) { fields = fields + (n + ": " + n); }
        else { fields = fields + (", " + n + ": " + n); }
        first = false;
      }
      continue;
    }
    bi = bi + 1;
  }

  let js = exportKw + "function " + name.text + "(" + params.v0 + ") {\n" + body.body + "return { " + fields + " };\n}\n";
  ParsedStmt(js, k)
}

out fn parse_fn_decl(src: String, i: I32) : ParsedStmt => parse_fn_decl2(src, i, false)

out fn parse_struct_decl(src: String, i: I32) : ParsedStmt => {
  // struct Name { field: Type, ... }
  let mut k = parse_keyword(src, i, "struct");
  let name = parse_ident(src, k);
  k = name.nextPos;
  if (is_identifier_too_short(name.text)) { warn_short_identifier(src, name.startPos, name.text); }

  // Optional generic params: struct Name<T, U> { ... }
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) { // '<'
    k = skip_angle_brackets(src, t0);
  }

  k = parse_keyword(src, k, "{");

  let fields = vec_new();

  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic_at(src, k, "expected '}'"); }
    if (stringCharCodeAt(src, k) == 125) { // '}'
      k = k + 1;
      break;
    }

    let field = parse_ident(src, k);
    k = field.nextPos;
    k = parse_keyword(src, k, ":");
    let _ty = parse_type_expr(src, k);
    k = _ty.v1;

    vec_push(fields, field.text);

    k = skip_ws(src, k);
    if (k < stringLen(src)) {
      let ch = stringCharCodeAt(src, k);
      if (ch == 44 || ch == 59) { // ',' or ';'
        k = k + 1;
      }
    }
  }

  add_struct_def(name.text, fields);
  ParsedStmt("", k)
}

out fn parse_type_union_decl(src: String, i: I32, exportAll: Bool) : ParsedStmt => {
  // type Name<T, ...> = Variant1<X> | Variant2 | ...;
  let mut k = parse_keyword(src, i, "type");
  let _name = parse_ident(src, k);
  k = _name.nextPos;
  if (is_identifier_too_short(_name.text)) { warn_short_identifier(src, _name.startPos, _name.text); }

  // optional type params on the alias name
  let t0 = skip_ws(src, k);
  if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 60) { // '<'
    k = skip_angle_brackets(src, t0);
  }

  k = parse_keyword(src, k, "=");

  let mut out = "";
  let mut first = true;
  while (true) {
    if (!first) { k = parse_keyword(src, k, "|"); }
    first = false;

    let v = parse_ident(src, k);
    let variant = v.text;
    k = v.nextPos;

    let mut hasPayload = false;
    let t1 = skip_ws(src, k);
    if (t1 < stringLen(src) && stringCharCodeAt(src, t1) == 60) { // '<'
      hasPayload = true;
      k = skip_angle_brackets(src, t1);
    }

    let header = if (exportAll) "export const " else "const ";
    if (hasPayload) {
      out = out + (header + variant + " = (value) => ({ tag: \"" + variant + "\", value });\n");
    } else {
      out = out + (header + variant + " = { tag: \"" + variant + "\" };\n");
    }

    let t2 = skip_ws(src, k);
    if (!(t2 < stringLen(src))) { yield ParsedStmt(out, k); }
    let ch = stringCharCodeAt(src, t2);
    if (ch == 59) { // ';'
      k = t2 + 1;
      break;
    }
    if (ch == 124) { // '|'
      // continue parsing variants
      continue;
    }
    panic_at(src, t2, "expected '|' or ';' in union type")
  }

  ParsedStmt(out, k)
}
