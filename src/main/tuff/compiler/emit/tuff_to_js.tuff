// Tuff-to-JS Transpiler Demo
// This demonstrates wiring the Tuff parser (input grammar) 
// with a JS emitter (output grammar) using the bidirectional grammar system

extern from rt::stdlib use { stringLen, stringSlice, stringCharCodeAt, stringFromCharCode, print };
extern from rt::vec use { vec_new, vec_push, vec_len, vec_get };

// Import the actual Tuff compiler AST (same compiler module - shares scope)
// The AST types like EInt, EBool etc are union variants accessible without import

// =============================================================================
// JS Emit Context
// =============================================================================

struct JsEmitCtx {
  indentLevel: I32,
  indentStr: String
}

out fn mk_ctx() : JsEmitCtx => JsEmitCtx { 0, "  " }

fn indent_ctx(ctx: JsEmitCtx) : JsEmitCtx =>
  JsEmitCtx { ctx.indentLevel + 1, ctx.indentStr }

fn get_indent(ctx: JsEmitCtx) : String => {
  let mut s = "";
  let mut i = 0;
  while (i < ctx.indentLevel) {
    s = s + ctx.indentStr;
    i = i + 1;
  }
  s
}

// =============================================================================
// Binary Operator to JS Operator Mapping
// =============================================================================

fn binop_to_js(op: BinOp) : String => {
  if (op is OpAdd) { yield "+"; }
  if (op is OpSub) { yield "-"; }
  if (op is OpMul) { yield "*"; }
  if (op is OpDiv) { yield "/"; }
  if (op is OpEq) { yield "==="; }   // Strict equality in JS
  if (op is OpNe) { yield "!=="; }   // Strict inequality in JS
  if (op is OpLt) { yield "<"; }
  if (op is OpLe) { yield "<="; }
  if (op is OpGt) { yield ">"; }
  if (op is OpGe) { yield ">="; }
  if (op is OpAnd) { yield "&&"; }
  if (op is OpOr) { yield "||"; }
  "/* unknown op */"
}

fn unop_to_js(op: UnOp) : String => {
  if (op is OpNot) { yield "!"; }
  if (op is OpNeg) { yield "-"; }
  "/* unknown unop */"
}

// =============================================================================
// Emit Expressions
// =============================================================================

out fn emit_expr(e: Expr, ctx: JsEmitCtx) : String => {
  if (e is EInt) {
    yield i32_to_string(e.value);
  }
  
  if (e is EFloat) {
    yield e.text;  // Already a string representation
  }
  
  if (e is EBool) {
    if (e.value) { yield "true"; }
    yield "false";
  }
  
  if (e is EString) {
    yield "\"" + escape_js_string(e.value) + "\"";
  }
  
  if (e is EIdent) {
    yield e.name;
  }
  
  if (e is EPath) {
    // Path like std::io -> std.io in JS
    let mut result = "";
    let mut i = 0;
    while (i < vec_len(e.parts)) {
      if (i > 0) { result = result + "."; }
      result = result + vec_get(e.parts, i);
      i = i + 1;
    }
    yield result;
  }
  
  if (e is EBinary) {
    let left = emit_expr(e.left, ctx);
    let right = emit_expr(e.right, ctx);
    let jsOp = binop_to_js(e.op);
    yield "(" + left + " " + jsOp + " " + right + ")";
  }
  
  if (e is EUnary) {
    let operand = emit_expr(e.expr, ctx);
    let jsOp = unop_to_js(e.op);
    yield "(" + jsOp + operand + ")";
  }
  
  if (e is ECall) {
    let callee = emit_expr(e.callee, ctx);
    let mut args = "";
    let mut i = 0;
    while (i < vec_len(e.args)) {
      if (i > 0) { args = args + ", "; }
      args = args + emit_expr(vec_get(e.args, i), ctx);
      i = i + 1;
    }
    yield callee + "(" + args + ")";
  }
  
  if (e is EIndex) {
    let base = emit_expr(e.base, ctx);
    let index = emit_expr(e.index, ctx);
    yield base + "[" + index + "]";
  }
  
  if (e is ETupleIndex) {
    let base = emit_expr(e.base, ctx);
    yield base + "[" + i32_to_string(e.index) + "]";
  }
  
  if (e is EField) {
    let base = emit_expr(e.base, ctx);
    yield base + "." + e.field;
  }
  
  if (e is EIf) {
    // Emit as ternary for expressions
    let cond = emit_expr(e.cond, ctx);
    let thenE = emit_expr(e.thenExpr, ctx);
    let elseE = emit_expr(e.elseExpr, ctx);
    yield "(" + cond + " ? " + thenE + " : " + elseE + ")";
  }
  
  if (e is EBlock) {
    yield emit_block_expr(e, ctx);
  }
  
  if (e is ELambda) {
    yield emit_lambda(e, ctx);
  }
  
  if (e is EStructLit) {
    yield emit_struct_lit(e, ctx);
  }
  
  if (e is ETupleLit) {
    yield emit_tuple_lit(e, ctx);
  }
  
  if (e is EVecLit) {
    yield emit_vec_lit(e, ctx);
  }
  
  if (e is EMatch) {
    yield emit_match_expr(e, ctx);
  }
  
  if (e is EIsType) {
    // `expr is Type` -> check __variant property
    let base = emit_expr(e.expr, ctx);
    yield "(" + base + "?.__variant === \"" + e.typeToCheck + "\")";
  }
  
  // Fallback
  "/* unknown expr */"
}

fn i32_to_string(n: I32) : String => {
  if (n == 0) { yield "0"; }
  
  let mut result = "";
  let mut val = n;
  let isNeg = val < 0;
  if (isNeg) { val = 0 - val; }
  
  while (val > 0) {
    let digit = val - (val / 10) * 10;  // val % 10
    result = stringFromCharCode(48 + digit) + result;
    val = val / 10;
  }
  
  if (isNeg) { yield "-" + result; }
  result
}

fn escape_js_string(s: String) : String => {
  let len = stringLen(s);
  let mut result = "";
  let mut i = 0;
  while (i < len) {
    let c = stringCharCodeAt(s, i);
    if (c == 34) { result = result + "\\\""; }       // "
    if (c == 92) { result = result + "\\\\"; }       // \
    if (c == 10) { result = result + "\\n"; }        // newline
    if (c == 13) { result = result + "\\r"; }        // carriage return
    if (c == 9) { result = result + "\\t"; }         // tab
    if (c != 34 && c != 92 && c != 10 && c != 13 && c != 9) {
      result = result + stringFromCharCode(c);
    }
    i = i + 1;
  }
  result
}

fn emit_block_expr(e: EBlock, ctx: JsEmitCtx) : String => {
  // Block expressions become IIFEs in JS
  let ind = get_indent(ctx);
  let innerCtx = indent_ctx(ctx);
  let innerInd = get_indent(innerCtx);
  
  let mut code = "(() => {\n";
  
  // Emit statements
  let mut i = 0;
  while (i < vec_len(e.body)) {
    code = code + innerInd + emit_stmt(vec_get(e.body, i), innerCtx) + "\n";
    i = i + 1;
  }
  
  // Emit tail expression as return
  code = code + innerInd + "return " + emit_expr(e.tail, innerCtx) + ";\n";
  
  code = code + ind + "})()";
  code
}

fn emit_lambda(e: ELambda, ctx: JsEmitCtx) : String => {
  let mut params = "";
  let mut i = 0;
  while (i < vec_len(e.params)) {
    if (i > 0) { params = params + ", "; }
    params = params + vec_get(e.params, i);
    i = i + 1;
  }
  
  let body = emit_expr(e.body, ctx);
  
  "(" + params + ") => " + body
}

fn emit_struct_lit(e: EStructLit, ctx: JsEmitCtx) : String => {
  // Structs become constructor calls in JS
  let name = emit_expr(e.nameExpr, ctx);
  let mut args = "";
  let mut i = 0;
  while (i < vec_len(e.values)) {
    if (i > 0) { args = args + ", "; }
    args = args + emit_expr(vec_get(e.values, i), ctx);
    i = i + 1;
  }
  name + "(" + args + ")"
}

fn emit_tuple_lit(e: ETupleLit, ctx: JsEmitCtx) : String => {
  // Tuples become arrays in JS
  let mut code = "[";
  let mut i = 0;
  while (i < vec_len(e.items)) {
    if (i > 0) { code = code + ", "; }
    code = code + emit_expr(vec_get(e.items, i), ctx);
    i = i + 1;
  }
  code + "]"
}

fn emit_vec_lit(e: EVecLit, ctx: JsEmitCtx) : String => {
  let mut code = "[";
  let mut i = 0;
  while (i < vec_len(e.items)) {
    if (i > 0) { code = code + ", "; }
    code = code + emit_expr(vec_get(e.items, i), ctx);
    i = i + 1;
  }
  code + "]"
}

fn emit_match_expr(e: EMatch, ctx: JsEmitCtx) : String => {
  // Match expressions become switch-like IIFEs in JS
  let scrutinee = emit_expr(e.scrut, ctx);
  let ind = get_indent(ctx);
  let innerCtx = indent_ctx(ctx);
  let innerInd = get_indent(innerCtx);
  
  let mut code = "(() => {\n";
  code = code + innerInd + "const __match = " + scrutinee + ";\n";
  
  let mut i = 0;
  while (i < vec_len(e.arms)) {
    let arm = vec_get(e.arms, i);
    let patStr = emit_match_pattern(arm.pat);
    
    if (i == 0) {
      code = code + innerInd + "if (" + patStr + ") {\n";
    } else {
      code = code + " else if (" + patStr + ") {\n";
    }
    code = code + innerInd + "  return " + emit_expr(arm.expr, indent_ctx(innerCtx)) + ";\n";
    code = code + innerInd + "}";
    i = i + 1;
  }
  
  code = code + "\n" + ind + "})()";
  code
}

fn emit_match_pattern(pat: MatchPat) : String => {
  if (pat is MPWildcard) {
    yield "true";
  }
  if (pat is MPInt) {
    yield "__match === " + i32_to_string(pat.value);
  }
  if (pat is MPBool) {
    if (pat.value) { yield "__match === true"; }
    yield "__match === false";
  }
  if (pat is MPString) {
    yield "__match === \"" + escape_js_string(pat.value) + "\"";
  }
  if (pat is MPVariant) {
    yield "__match?.__variant === \"" + pat.name + "\"";
  }
  "true"
}

// =============================================================================
// Emit Statements
// =============================================================================

out fn emit_stmt(s: Stmt, ctx: JsEmitCtx) : String => {
  if (s is SLet) {
    let init = emit_expr(s.init, ctx);
    yield "let " + s.name + " = " + init + ";";
  }
  
  if (s is SAssign) {
    let value = emit_expr(s.value, ctx);
    yield s.name + " = " + value + ";";
  }
  
  if (s is SExpr) {
    yield emit_expr(s.expr, ctx) + ";";
  }
  
  if (s is SIf) {
    yield emit_if_stmt(s, ctx);
  }
  
  if (s is SWhile) {
    let cond = emit_expr(s.cond, ctx);
    let body = emit_stmt_body(s.body, ctx);
    yield "while (" + cond + ") " + body;
  }
  
  if (s is SYield) {
    yield "return " + emit_expr(s.expr, ctx) + ";";
  }
  
  if (s is SIndexAssign) {
    let base = emit_expr(s.base, ctx);
    let index = emit_expr(s.index, ctx);
    let value = emit_expr(s.value, ctx);
    yield base + "[" + index + "] = " + value + ";";
  }
  
  if (s is SFieldAssign) {
    let base = emit_expr(s.base, ctx);
    let mut fields = "";
    let mut i = 0;
    while (i < vec_len(s.fields)) {
      fields = fields + "." + vec_get(s.fields, i);
      i = i + 1;
    }
    let value = emit_expr(s.value, ctx);
    yield base + fields + " = " + value + ";";
  }

  if (s is SDerefAssign) {
    // *ptr = value -> ptr.value = value
    if (s.ptr is EUnary && s.ptr.op is OpDeref) {
      let ptrCode = emit_expr(s.ptr.expr, ctx);
      yield ptrCode + ".value = " + emit_expr(s.value, ctx) + ";";
    }
    let ptrCode = emit_expr(s.ptr, ctx);
    yield ptrCode + " = " + emit_expr(s.value, ctx) + ";";
  }
  
  "/* unknown stmt */"
}

fn emit_if_stmt(s: SIf, ctx: JsEmitCtx) : String => {
  let cond = emit_expr(s.cond, ctx);
  let thenBody = emit_stmt_body(s.thenBody, ctx);
  
  let mut code = "if (" + cond + ") " + thenBody;
  
  if (s.hasElse) {
    code = code + " else " + emit_stmt_body(s.elseBody, ctx);
  }
  
  code
}

fn emit_stmt_body(stmts: Vec<Stmt>, ctx: JsEmitCtx) : String => {
  let ind = get_indent(ctx);
  let innerCtx = indent_ctx(ctx);
  let innerInd = get_indent(innerCtx);
  
  let mut code = "{\n";
  let mut i = 0;
  while (i < vec_len(stmts)) {
    code = code + innerInd + emit_stmt(vec_get(stmts, i), innerCtx) + "\n";
    i = i + 1;
  }
  code = code + ind + "}";
  code
}

// =============================================================================
// Emit Declarations
// =============================================================================

out fn emit_decl(d: Decl, ctx: JsEmitCtx) : String => {
  let ind = get_indent(ctx);
  
  if (d is DFn) {
    if (d.isClass) {
      yield emit_class_fn_decl(d, ctx);
    }
    if (d.isExtern) {
      // extern fn without body - emit nothing
      yield "";
    }
    yield emit_fn_decl(d, ctx);
  }
  
  if (d is DStruct) {
    yield emit_struct_decl(d, ctx);
  }
  
  if (d is DTypeUnion) {
    yield emit_union_decl(d, ctx);
  }
  
  if (d is DLet) {
    let init = emit_expr(d.init, ctx);
    let mut prefix = "";
    if (d.isMut) { prefix = "let "; }
    if (!d.isMut) { prefix = "const "; }
    yield prefix + d.name + " = " + init + ";";
  }
  
  if (d is DExternFrom) {
    yield emit_extern_from_decl(d, ctx);
  }
  
  if (d is DExternType) {
    yield "// extern type " + d.name;
  }
  
  if (d is DImport) {
    yield emit_import_decl(d, ctx);
  }
  
  "/* unknown decl */"
}

fn emit_fn_decl(d: DFn, ctx: JsEmitCtx) : String => {
  let mut params = "";
  let mut i = 0;
  while (i < vec_len(d.params)) {
    if (i > 0) { params = params + ", "; }
    params = params + vec_get(d.params, i);
    i = i + 1;
  }
  
  let ind = get_indent(ctx);
  let innerCtx = indent_ctx(ctx);
  let innerInd = get_indent(innerCtx);
  
  let mut prefix = "";
  if (d.isOut) { prefix = "export "; }
  
  let mut code = prefix + "function " + d.name + "(" + params + ") {\n";
  
  // Emit body statements
  let mut j = 0;
  while (j < vec_len(d.body)) {
    code = code + innerInd + emit_stmt(vec_get(d.body, j), innerCtx) + "\n";
    j = j + 1;
  }
  
  // Emit tail expression as return
  code = code + innerInd + "return " + emit_expr(d.tail, innerCtx) + ";\n";
  code = code + ind + "}";
  code
}

fn emit_class_fn_decl(d: DFn, ctx: JsEmitCtx) : String => {
  // Class functions become factory functions in JS
  let mut params = "";
  let mut i = 0;
  while (i < vec_len(d.params)) {
    if (i > 0) { params = params + ", "; }
    params = params + vec_get(d.params, i);
    i = i + 1;
  }
  
  let ind = get_indent(ctx);
  let innerCtx = indent_ctx(ctx);
  let innerInd = get_indent(innerCtx);
  
  let mut prefix = "";
  if (d.isOut) { prefix = "export "; }
  
  let mut code = prefix + "function " + d.name + "(" + params + ") {\n";
  
  // Emit body statements (these define methods and additional fields)
  let mut j = 0;
  while (j < vec_len(d.body)) {
    code = code + innerInd + emit_stmt(vec_get(d.body, j), innerCtx) + "\n";
    j = j + 1;
  }
  
  // Return object with params as fields
  code = code + innerInd + "return {\n";
  let mut k = 0;
  while (k < vec_len(d.params)) {
    let p = vec_get(d.params, k);
    code = code + innerInd + "  " + p + ",\n";
    k = k + 1;
  }
  code = code + innerInd + "};\n";
  code = code + ind + "}";
  code
}

fn emit_struct_decl(d: DStruct, ctx: JsEmitCtx) : String => {
  // Structs become factory functions in JS
  let mut params = "";
  let mut fields = "";
  let mut i = 0;
  while (i < vec_len(d.fields)) {
    if (i > 0) { 
      params = params + ", "; 
      fields = fields + ", ";
    }
    let f = vec_get(d.fields, i);
    params = params + f;
    fields = fields + f;
    i = i + 1;
  }
  
  "function " + d.name + "(" + params + ") { return { " + fields + " }; }"
}

fn emit_union_decl(d: DTypeUnion, ctx: JsEmitCtx) : String => {
  // Union types become factory functions for each variant
  let mut code = "// type " + d.name + "\n";
  
  let mut i = 0;
  while (i < vec_len(d.variants)) {
    let v = vec_get(d.variants, i);
    if (v.hasPayload) {
      code = code + "function " + v.name + "(value) { return { __variant: \"" + v.name + "\", value }; }\n";
    } else {
      code = code + "const " + v.name + " = { __variant: \"" + v.name + "\" };\n";
    }
    i = i + 1;
  }
  
  code
}

fn emit_import_decl(d: DImport, ctx: JsEmitCtx) : String => {
  let mut imports = "";
  let mut i = 0;
  while (i < vec_len(d.names)) {
    if (i > 0) { imports = imports + ", "; }
    imports = imports + vec_get(d.names, i);
    i = i + 1;
  }
  
  // Convert Tuff module path to JS module path
  let jsPath = module_path_to_js(d.modulePath);
  
  "import { " + imports + " } from \"" + jsPath + "\";"
}

fn emit_extern_from_decl(d: DExternFrom, ctx: JsEmitCtx) : String => {
  let mut imports = "";
  let mut i = 0;
  while (i < vec_len(d.names)) {
    if (i > 0) { imports = imports + ", "; }
    imports = imports + vec_get(d.names, i);
    i = i + 1;
  }
  
  let jsPath = module_path_to_js(d.modulePath);
  
  "import { " + imports + " } from \"" + jsPath + "\";"
}

fn module_path_to_js(path: String) : String => {
  // Convert Tuff :: path to JS / path
  let len = stringLen(path);
  let mut result = "./";
  let mut i = 0;
  while (i < len) {
    let c = stringCharCodeAt(path, i);
    if (c == 58 && i + 1 < len && stringCharCodeAt(path, i + 1) == 58) {
      result = result + "/";
      i = i + 2;
    } else {
      result = result + stringFromCharCode(c);
      i = i + 1;
    }
  }
  result + ".mjs"
}

// =============================================================================
// Emit Program
// =============================================================================

out fn emit_program(decls: Vec<Decl>) : String => {
  let ctx = mk_ctx();
  let mut code = "// Generated JavaScript - DO NOT EDIT\n";
  code = code + "// Transpiled from Tuff\n\n";
  
  let mut i = 0;
  while (i < vec_len(decls)) {
    code = code + emit_decl(vec_get(decls, i), ctx) + "\n\n";
    i = i + 1;
  }
  
  code
}
