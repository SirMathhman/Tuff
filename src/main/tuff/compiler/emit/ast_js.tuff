// Phase 3 scaffold: JS-only emitter for the canonical AST.
//
// This module is intentionally small and only supports the current subset of
// `compiler/ast.tuff` nodes.

extern from rt::stdlib use { panic, stringLen, stringCharAt, stringFromChar, stringSlice };
extern from rt::vec use { vec_new, vec_push, vec_len, vec_get, vec_set };

from util::diagnostics use { find_struct_fields };
from util::lexing use { starts_with_at };
from parsing::primitives use { module_path_to_relpath };

let mut __current_file_path = "";

// Runtime vec helpers used by emitted JS (e.g. vec literals, indexing).
// We import them under internal aliases to avoid collisions with user code.
fn emit_runtime_vec_imports_js() : String => {
  let importPath = rel_import_path("rt/vec.mjs");
  "import { vec_new as __tuff_vec_new, vec_push as __tuff_vec_push, vec_get as __tuff_vec_get, vec_set as __tuff_vec_set } from \"" + importPath + "\";\n"
}

fn expr_needs_vec_rt(e: Expr) : Bool => {
  // True when emitting this expression will reference __tuff_vec_* helpers.
  if (e.tag == "EVecLit") { yield true; }
  if (e.tag == "EIndex") { yield true; }

  if (e.tag == "EUnary") { yield expr_needs_vec_rt(e.expr); }

  if (e.tag == "EBinary") {
    if (expr_needs_vec_rt(e.left)) { yield true; }
    yield expr_needs_vec_rt(e.right);
  }

  if (e.tag == "ECall") {
    if (expr_needs_vec_rt(e.callee)) { yield true; }
    let mut i = 0;
    while (i < vec_len(e.args)) {
      if (expr_needs_vec_rt(vec_get(e.args, i))) { yield true; }
      i = i + 1;
    }
    yield false;
  }

  if (e.tag == "EIf") {
    if (expr_needs_vec_rt(e.cond)) { yield true; }
    if (expr_needs_vec_rt(e.thenExpr)) { yield true; }
    yield expr_needs_vec_rt(e.elseExpr);
  }

  if (e.tag == "EBlock") {
    let mut i = 0;
    while (i < vec_len(e.body)) {
      if (stmt_needs_vec_rt(vec_get(e.body, i))) { yield true; }
      i = i + 1;
    }
    yield expr_needs_vec_rt(e.tail);
  }

  if (e.tag == "ELambda") {
    // Body may be an expr or an EBlock.
    yield expr_needs_vec_rt(e.body);
  }

  if (e.tag == "EStructLit") {
    if (expr_needs_vec_rt(e.nameExpr)) { yield true; }
    let mut i = 0;
    while (i < vec_len(e.values)) {
      if (expr_needs_vec_rt(vec_get(e.values, i))) { yield true; }
      i = i + 1;
    }
    yield false;
  }

  if (e.tag == "ETupleLit") {
    let mut i = 0;
    while (i < vec_len(e.items)) {
      if (expr_needs_vec_rt(vec_get(e.items, i))) { yield true; }
      i = i + 1;
    }
    yield false;
  }

  if (e.tag == "ETupleIndex") { yield expr_needs_vec_rt(e.base); }
  if (e.tag == "EField") { yield expr_needs_vec_rt(e.base); }

  if (e.tag == "EMatch") {
    if (expr_needs_vec_rt(e.scrut)) { yield true; }
    let mut i = 0;
    while (i < vec_len(e.arms)) {
      let arm = vec_get(e.arms, i);
      if (expr_needs_vec_rt(arm.expr)) { yield true; }
      i = i + 1;
    }
    yield false;
  }

  // Leaf nodes / not currently relevant.
  false
}

fn stmt_needs_vec_rt(s: Stmt) : Bool => {
  if (s.tag == "SIndexAssign") { yield true; }

  if (s.tag == "SLet") { yield expr_needs_vec_rt(s.init); }
  if (s.tag == "SAssign") { yield expr_needs_vec_rt(s.value); }
  if (s.tag == "SExpr") { yield expr_needs_vec_rt(s.expr); }
  if (s.tag == "SYield") { yield expr_needs_vec_rt(s.expr); }
  if (s.tag == "SWhile") {
    if (expr_needs_vec_rt(s.cond)) { yield true; }
    let mut i = 0;
    while (i < vec_len(s.body)) {
      if (stmt_needs_vec_rt(vec_get(s.body, i))) { yield true; }
      i = i + 1;
    }
    yield false;
  }
  if (s.tag == "SIf") {
    if (expr_needs_vec_rt(s.cond)) { yield true; }
    let mut i = 0;
    while (i < vec_len(s.thenBody)) {
      if (stmt_needs_vec_rt(vec_get(s.thenBody, i))) { yield true; }
      i = i + 1;
    }
    if (s.hasElse) {
      i = 0;
      while (i < vec_len(s.elseBody)) {
        if (stmt_needs_vec_rt(vec_get(s.elseBody, i))) { yield true; }
        i = i + 1;
      }
    }
    yield false;
  }
  if (s.tag == "SFieldAssign") {
    if (expr_needs_vec_rt(s.base)) { yield true; }
    yield expr_needs_vec_rt(s.value);
  }

  false
}

fn decl_needs_vec_rt(d: Decl) : Bool => {
  if (d.tag == "DLet") { yield expr_needs_vec_rt(d.init); }
  if (d.tag == "DFn") {
    let mut i = 0;
    while (i < vec_len(d.body)) {
      if (stmt_needs_vec_rt(vec_get(d.body, i))) { yield true; }
      i = i + 1;
    }
    yield expr_needs_vec_rt(d.tail);
  }
  if (d.tag == "DClassFn") {
    let mut i = 0;
    while (i < vec_len(d.body)) {
      if (stmt_needs_vec_rt(vec_get(d.body, i))) { yield true; }
      i = i + 1;
    }
    yield false;
  }
  if (d.tag == "DModule") {
    let mut i = 0;
    while (i < vec_len(d.decls)) {
      if (decl_needs_vec_rt(vec_get(d.decls, i))) { yield true; }
      i = i + 1;
    }
    yield false;
  }
  false
}

fn decls_needs_vec_rt(decls: Vec<Decl>) : Bool => {
  let mut i = 0;
  while (i < vec_len(decls)) {
    if (decl_needs_vec_rt(vec_get(decls, i))) { yield true; }
    i = i + 1;
  }
  false
}

fn set_current_file_path(path: String) : Void => {
  __current_file_path = path;
}

fn normalize_path_seps(p: String) : String => {
  // Normalize Windows path separators to '/' so relative-path logic is stable.
  let mut out = "";
  let mut i = 0;
  while (i < stringLen(p)) {
    let ch = stringCharAt(p, i);
    if (ch == 92) { // '\\'
      out = out + "/";
      i = i + 1;
      continue;
    }
    out = out + stringFromChar(ch);
    i = i + 1;
  }
  out
}

fn split_path(p: String) => {
  // Split on '/'. Empty segments are skipped.
  let mut segs = vec_new();
  let mut start = 0;
  let mut i = 0;
  while (i <= stringLen(p)) {
    if (i == stringLen(p) || stringCharAt(p, i) == 47) {
      if (i > start) {
        vec_push(segs, stringSlice(p, start, i));
      }
      start = i + 1;
      i = i + 1;
      continue;
    }
    i = i + 1;
  }
  segs
}

fn rel_import_path(targetRelPath: String) : String => {
  // Compute a relative import specifier from the current module path to target.
  // Both paths are expected to be project-relative like:
  //   __current_file_path = "util/diagnostics.tuff"
  //   targetRelPath       = "rt/stdlib.mjs" or "util/lexing.mjs"
  let from = normalize_path_seps(__current_file_path);
  let to = normalize_path_seps(targetRelPath);

  let fromParts = split_path(from);
  let toParts = split_path(to);

  // Directory parts for "from" exclude the file name.
  let mut fromDirLen = vec_len(fromParts) - 1;
  if (vec_len(fromParts) == 0) { fromDirLen = 0; }

  // Common prefix length.
  let mut common = 0;
  while (common < fromDirLen && common < vec_len(toParts)) {
    if (vec_get(fromParts, common) != vec_get(toParts, common)) { break; }
    common = common + 1;
  }

  // How many dirs to go up from fromDir.
  let mut up = fromDirLen - common;
  let mut prefix = "";
  if (up == 0) {
    prefix = "./";
  } else {
    while (up > 0) {
      prefix = prefix + "../";
      up = up - 1;
    }
  }

  // Join remaining target parts.
  let mut rest = "";
  let mut i = common;
  while (i < vec_len(toParts)) {
    if (stringLen(rest) == 0) { rest = vec_get(toParts, i); }
    else { rest = rest + "/" + vec_get(toParts, i); }
    i = i + 1;
  }

  prefix + rest
}

fn escape_js_string(s: String) : String => {
  // Minimal JS string escaping for double-quoted literals.
  // (More escapes can be added as the AST grows.)
  let mut out = "";
  let mut i = 0;
  while (i < stringLen(s)) {
    let ch = stringCharAt(s, i);
    // '"'
    if (ch == 34) {
      out = out + "\\\"";
      i = i + 1;
      continue;
    }

    // '\\'
    if (ch == 92) {
      out = out + "\\\\";
      i = i + 1;
      continue;
    }

    // '\n'
    if (ch == 10) {
      out = out + "\\n";
      i = i + 1;
      continue;
    }

    // '\r'
    if (ch == 13) {
      out = out + "\\r";
      i = i + 1;
      continue;
    }

    // '\t'
    if (ch == 9) {
      out = out + "\\t";
      i = i + 1;
      continue;
    }

    out = out + stringFromChar(ch);
    i = i + 1;
  }
  out
}

fn emit_binop_js(op: BinOp) : String => {
  // NOTE: The current selfhost JS emitter does not fully support `if` as an
  // expression (it compiles it as a statement). So we avoid relying on the
  // value of `if` here and in `emit_expr_js`.
  let mut out = "??";
  if (op.tag == "OpAdd") { out = "+"; }
  if (op.tag == "OpSub") { out = "-"; }
  if (op.tag == "OpMul") { out = "*"; }
  if (op.tag == "OpEq") { out = "=="; }
  if (op.tag == "OpNe") { out = "!="; }
  if (op.tag == "OpLt") { out = "<"; }
  if (op.tag == "OpLe") { out = "<="; }
  if (op.tag == "OpGt") { out = ">"; }
  if (op.tag == "OpGe") { out = ">="; }
  if (op.tag == "OpAnd") { out = "&&"; }
  if (op.tag == "OpOr") { out = "||"; }
  out
}

fn emit_unop_js(op: UnOp) : String => {
  let mut out = "??";
  if (op.tag == "OpNot") { out = "!"; }
  if (op.tag == "OpNeg") { out = "-"; }
  out
}

// JS precedence (subset) for minimal parenthesization.
// Higher number = binds tighter.
fn binop_prec_js(op: BinOp) : I32 => {
  if (op.tag == "OpMul") { yield 14; }
  if (op.tag == "OpAdd" || op.tag == "OpSub") { yield 13; }
  if (op.tag == "OpLt" || op.tag == "OpLe" || op.tag == "OpGt" || op.tag == "OpGe") { yield 11; }
  if (op.tag == "OpEq" || op.tag == "OpNe") { yield 10; }
  if (op.tag == "OpAnd") { yield 6; }
  if (op.tag == "OpOr") { yield 5; }
  0
}

fn expr_prec_js(e: Expr) : I32 => {
  if (e.tag == "EIf") { yield 4; }
  if (e.tag == "EBinary") { yield binop_prec_js(e.op); }
  if (e.tag == "EUnary") { yield 17; }
  // Calls/field/index and primaries bind tight enough for our needs.
  20
}

fn needs_parens_binop_child(childTag: String) : Bool => {
  childTag == "EBinary"
}

fn emit_path_js(parts: Vec<String>) : String => {
  let mut out = "";
  let mut i = 0;
  while (i < vec_len(parts)) {
    if (i > 0) { out = out + "."; }
    out = out + vec_get(parts, i);
    i = i + 1;
  }
  out
}

fn struct_name_for_lookup(nameExpr: Expr) : String => {
  if (nameExpr.tag == "EIdent") { yield nameExpr.name; }
  if (nameExpr.tag == "EPath") { yield emit_path_js(nameExpr.parts); }
  panic("struct literal name must be ident or path")
}

fn emit_struct_lit_js(nameExpr: Expr, values: Vec<Expr>) : String => {
  let structName = struct_name_for_lookup(nameExpr);
  let fields = find_struct_fields(structName);

  if (!(vec_len(fields) == vec_len(values))) {
    panic("wrong number of values in struct literal for " + structName);
  }

  let mut out = "({ ";
  let mut i = 0;
  while (i < vec_len(fields)) {
    if (i > 0) { out = out + ", "; }
    out = out + (vec_get(fields, i) + ": " + emit_expr_js(vec_get(values, i)));
    i = i + 1;
  }
  out = out + " })";
  out
}

out fn emit_expr_js(e: Expr) : String => {
  // Default fallback for nodes we haven't implemented yet.
  let mut out = "undefined";

  if (e.tag == "EUndefined") { out = "undefined"; }

  if (e.tag == "EInt") { out = "" + e.value; }

  if (e.tag == "EFloat") {
    // For F32, wrap in Math.fround to simulate 32-bit precision.
    // For F64 or untyped, emit the literal directly.
    if (e.suffix == "F32") {
      out = "Math.fround(" + e.text + ")";
    } else {
      out = e.text;
    }
  }

  if (e.tag == "EBool") {
    if (e.value) { out = "true"; }
    else { out = "false"; }
  }

  if (e.tag == "EString") { out = "\"" + escape_js_string(e.value) + "\""; }
  if (e.tag == "EIdent") { out = e.name; }

  if (e.tag == "EPath") { out = emit_path_js(e.parts); }

  if (e.tag == "ELambda") {
    let params = emit_names_csv(e.params);
    if (e.body.tag == "EBlock") {
      out = "((" + params + ") => {\n" + emit_stmts_js(e.body.body) + "return " + emit_expr_js(e.body.tail) + ";\n})";
    } else {
      out = "((" + params + ") => " + emit_expr_js(e.body) + ")";
    }
  }

  if (e.tag == "EStructLit") {
    out = emit_struct_lit_js(e.nameExpr, e.values);
  }

  if (e.tag == "EUnary") {
    let inner = emit_expr_js(e.expr);
    // Parenthesize only when the operand binds looser than unary.
    // Example: `!(a < b)` must emit as `!(a < b)`, not `!a < b`.
    let innerStr = if (expr_prec_js(e.expr) < 17) "(" + inner + ")" else inner;
    out = emit_unop_js(e.op) + innerStr;
  }

  if (e.tag == "EBinary") {
    let left = emit_expr_js(e.left);
    let right = emit_expr_js(e.right);
    let curPrec = binop_prec_js(e.op);
    let leftStr = if (expr_prec_js(e.left) < curPrec) "(" + left + ")" else left;
    // For left-associative ops, we parenthesize RHS when it binds looser OR equally,
    // preserving explicit grouping like `a - (b - c)`.
    let rightStr = if (expr_prec_js(e.right) <= curPrec) "(" + right + ")" else right;
    out = leftStr + " " + emit_binop_js(e.op) + " " + rightStr;
  }

  if (e.tag == "ECall") {
    let mut s = emit_expr_js(e.callee) + "(";
    let mut i = 0;
    while (i < vec_len(e.args)) {
      if (i > 0) { s = s + ", "; }
      s = s + emit_expr_js(vec_get(e.args, i));
      i = i + 1;
    }
    s = s + ")";
    out = s;
  }

  if (e.tag == "EIf") {
    out = "(" + emit_expr_js(e.cond) + " ? " + emit_expr_js(e.thenExpr) + " : " + emit_expr_js(e.elseExpr) + ")";
  }

  if (e.tag == "EBlock") {
    out = "(() => {\n" + emit_stmts_js(e.body) + "return " + emit_expr_js(e.tail) + ";\n})()";
  }

  if (e.tag == "EVecLit") {
    let mut pushes = "";
    let mut i = 0;
    while (i < vec_len(e.items)) {
      pushes = pushes + ("__tuff_vec_push(__v, " + emit_expr_js(vec_get(e.items, i)) + ");\n");
      i = i + 1;
    }
    out = "(() => { const __v = __tuff_vec_new();\n" + pushes + "return __v;\n})()";
  }

  if (e.tag == "ETupleLit") {
    let mut s = "[";
    let mut i = 0;
    while (i < vec_len(e.items)) {
      if (i > 0) { s = s + ", "; }
      s = s + emit_expr_js(vec_get(e.items, i));
      i = i + 1;
    }
    s = s + "]";
    out = s;
  }

  if (e.tag == "EIndex") {
    out = "__tuff_vec_get(" + emit_expr_js(e.base) + ", " + emit_expr_js(e.index) + ")";
  }

  if (e.tag == "ETupleIndex") {
    out = emit_expr_js(e.base) + "[" + ("" + e.index) + "]";
  }

  if (e.tag == "EField") {
    out = emit_expr_js(e.base) + "." + e.field;
  }

  if (e.tag == "EMatch") {
    let mut cases = "";
    let mut def = "";
    let mut sawVariant = false;
    let mut i = 0;
    while (i < vec_len(e.arms)) {
      let arm = vec_get(e.arms, i);
      if (arm.pat.tag == "MPWildcard") {
        def = emit_expr_js(arm.expr);
      } else {
        let mut patJs = "";
        if (arm.pat.tag == "MPInt") { patJs = "" + arm.pat.value; }
        if (arm.pat.tag == "MPBool") { patJs = if (arm.pat.value) "true" else "false"; }
        if (arm.pat.tag == "MPString") { patJs = "\"" + escape_js_string(arm.pat.value) + "\""; }
        if (arm.pat.tag == "MPVariant") {
          patJs = "\"" + escape_js_string(arm.pat.name) + "\"";
          sawVariant = true;
        }
        cases = cases + ("case " + patJs + ": return " + emit_expr_js(arm.expr) + ";\n");
      }
      i = i + 1;
    }
    if (def == "" && !sawVariant) { panic("match requires _ arm"); }
    if (def == "" && sawVariant) {
      def = "(() => { throw new Error(\"non-exhaustive match\"); })()";
    }
    let scrutJs = if (sawVariant) "(" + emit_expr_js(e.scrut) + ").tag" else emit_expr_js(e.scrut);
    out = "(() => { switch (" + scrutJs + ") {\n" + cases + "default: return " + def + ";\n} })()";
  }

  out
}

fn emit_stmt_js(s: Stmt) : String => {
  let mut out = "";

  if (s.tag == "SLet") {
    let kw = if (s.isMut) "let" else "const";
    out = kw + " " + s.name + " = " + emit_expr_js(s.init) + ";\n";
  }

  if (s.tag == "SAssign") {
    out = s.name + " = " + emit_expr_js(s.value) + ";\n";
  }

  if (s.tag == "SExpr") {
    // Standalone expression statements are needed for side effects.
    // Example: `println("hi");` or `compile_project(inPath, outPath);`
    out = emit_expr_js(s.expr) + ";\n";
  }

  if (s.tag == "SYield") {
    if (s.expr.tag == "EUndefined") { out = "return;\n"; }
    else { out = "return " + emit_expr_js(s.expr) + ";\n"; }
  }

  if (s.tag == "SWhile") {
    let cond = emit_expr_js(s.cond);
    out = "while (" + cond + ") {\n" + emit_stmts_js(s.body) + "}\n";
  }

  if (s.tag == "SIf") {
    if (s.hasElse) {
      out = "if (" + emit_expr_js(s.cond) + ") {\n" + emit_stmts_js(s.thenBody) + "} else {\n" + emit_stmts_js(s.elseBody) + "}\n";
    } else {
      out = "if (" + emit_expr_js(s.cond) + ") {\n" + emit_stmts_js(s.thenBody) + "}\n";
    }
  }

  if (s.tag == "SIndexAssign") {
    out = "__tuff_vec_set(" + emit_expr_js(s.base) + ", " + emit_expr_js(s.index) + ", " + emit_expr_js(s.value) + ");\n";
  }

  if (s.tag == "SFieldAssign") {
    let mut lhs = emit_expr_js(s.base);
    let mut i = 0;
    while (i < vec_len(s.fields)) {
      lhs = lhs + "." + vec_get(s.fields, i);
      i = i + 1;
    }
    out = lhs + " = " + emit_expr_js(s.value) + ";\n";
  }

  out
}

fn emit_stmts_js(stmts: Vec<Stmt>) : String => {
  let mut out = "";
  let mut i = 0;
  while (i < vec_len(stmts)) {
    out = out + emit_stmt_js(vec_get(stmts, i));
    i = i + 1;
  }
  out
}

fn emit_names_csv(names: Vec<String>) : String => {
  let mut out = "";
  let mut i = 0;
  while (i < vec_len(names)) {
    if (i > 0) { out = out + ", "; }
    out = out + vec_get(names, i);
    i = i + 1;
  }
  out
}

fn emit_extern_import_path(modPath: String) : String => {
  if (starts_with_at(modPath, 0, "rt::")) {
    let rel = "rt/" + stringSlice(modPath, 4, stringLen(modPath)) + ".mjs";
    yield rel_import_path(rel);
  }
  if (starts_with_at(modPath, 0, "node::")) {
    yield "node:" + stringSlice(modPath, 6, stringLen(modPath));
  }
  panic("unsupported extern module: " + modPath)
}

fn emit_fn_decl_js(d: DFn, exportAll: Bool, jsName: String, exportThis: Bool) : String => {
  let exportKw = if (exportThis) "export " else "";
  let params = emit_names_csv(d.params);
  exportKw + "function " + jsName + "(" + params + ") {\n" + emit_stmts_js(d.body) + "return " + emit_expr_js(d.tail) + ";\n}\n"
}

fn emit_type_union_js(d: DTypeUnion, exportAll: Bool) : String => {
  let mut out = "";
  let dq = "\"";
  let mut i = 0;
  while (i < vec_len(d.variants)) {
    let v = vec_get(d.variants, i);
    // Union variants are runtime constructors/constants and need to be importable
    // across modules (e.g. `from X use { Some, None }`).
    // `out fn` gates function exports; unions are always emitted as exported consts.
    let header = "export const ";
    if (v.hasPayload) {
      out = out + (header + v.name + " = (value) => { return { tag: " + dq + v.name + dq + ", value: value }; };\n");
    } else {
      out = out + (header + v.name + " = { tag: " + dq + v.name + dq + " };\n");
    }
    i = i + 1;
  }
  out
}

fn emit_module_decl_js(d: DModule, prefix: String, exportThis: Bool) : String => {
  // Emit inner decls as top-level functions/consts, then expose an object.
  let mut decls = "";
  let mut entries = "";
  let mut first = true;

  let mut i = 0;
  while (i < vec_len(d.decls)) {
    let inner = vec_get(d.decls, i);

    if (inner.tag == "DFn") {
      let jsName = prefix + "__" + d.name + "__" + inner.name;
      decls = decls + emit_fn_decl_js(inner, false, jsName, false);
      if (first) { entries = entries + (inner.name + ": " + jsName); }
      else { entries = entries + (", " + inner.name + ": " + jsName); }
      first = false;
      i = i + 1;
      continue;
    }

    if (inner.tag == "DModule") {
      let innerCode = emit_module_decl_js(inner, prefix + "__" + d.name, false);
      decls = decls + innerCode;
      let prop = inner.name;
      if (first) { entries = entries + (prop + ": " + prop); }
      else { entries = entries + (", " + prop + ": " + prop); }
      first = false;
      i = i + 1;
      continue;
    }

    panic("unsupported decl inside module")
  }

  let header = if (exportThis) "export const " else "const ";
  decls + header + d.name + " = { " + entries + " };\n"
}

fn emit_decl_js(d: Decl, exportAll: Bool) : String => {
  let mut out = "";

  if (d.tag == "DExternFrom") {
    let importPath = emit_extern_import_path(d.modulePath);
    out = "import { " + emit_names_csv(d.names) + " } from \"" + importPath + "\";\n";
  }

  if (d.tag == "DImport") {
    let mut targetModulePath = d.modulePath;
    // Allow importing compiler modules using the repository-root path
    // `src::main::tuff::compiler::...`, but link them using the compiler-root
    // layout (e.g. `./emit/ast_js.mjs`).
    let compilerSrcPrefix = "src::main::tuff::compiler::";
    if (starts_with_at(targetModulePath, 0, compilerSrcPrefix)) {
      targetModulePath = stringSlice(targetModulePath, stringLen(compilerSrcPrefix), stringLen(targetModulePath));
    }

    let targetRel = module_path_to_relpath(targetModulePath) + ".mjs";
    let importPath = rel_import_path(targetRel);
    out = "import { " + emit_names_csv(d.names) + " } from \"" + importPath + "\";\n";
  }

  if (d.tag == "DTypeUnion") {
    out = emit_type_union_js(d, exportAll);
  }

  if (d.tag == "DStruct") {
    // Structs are compile-time only for now (field order table is updated during parsing).
    out = "";
  }

  if (d.tag == "DLet") {
    let kw = if (d.isMut) "let" else "const";
    out = kw + " " + d.name + " = " + emit_expr_js(d.init) + ";\n";
  }

  if (d.tag == "DFn") {
    let exportThis = exportAll || d.isOut || d.name == "main";
    out = emit_fn_decl_js(d, exportAll, d.name, exportThis);
  }

  if (d.tag == "DClassFn") {
    // `class fn` becomes a function returning an object of scope fields.
    // In this bootstrap subset, we approximate `this` by returning all params
    // plus any `let` bindings declared in the body (in source order).
    let exportThis = exportAll || d.isOut || d.name == "main";
    let exportKw = if (exportThis) "export " else "";
    let params = emit_names_csv(d.params);

    let fieldNames = vec_new();
    let mut i = 0;
    while (i < vec_len(d.params)) {
      vec_push(fieldNames, vec_get(d.params, i));
      i = i + 1;
    }

    i = 0;
    while (i < vec_len(d.body)) {
      let s = vec_get(d.body, i);
      if (s.tag == "SLet") {
        let mut found = false;
        let mut j = 0;
        while (j < vec_len(fieldNames)) {
          if (vec_get(fieldNames, j) == s.name) {
            found = true;
            j = vec_len(fieldNames);
          } else {
            j = j + 1;
          }
        }
        if (!found) { vec_push(fieldNames, s.name); }
      }
      i = i + 1;
    }

    let mut fields = "";
    i = 0;
    while (i < vec_len(fieldNames)) {
      if (i > 0) { fields = fields + ", "; }
      let p = vec_get(fieldNames, i);
      fields = fields + (p + ": " + p);
      i = i + 1;
    }

    out = exportKw + "function " + d.name + "(" + params + ") {\n" + emit_stmts_js(d.body) + "return { " + fields + " };\n}\n";
  }

  if (d.tag == "DModule") {
    out = emit_module_decl_js(d, "M", true);
  }

  out
}
