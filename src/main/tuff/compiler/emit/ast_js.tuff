// Phase 3 scaffold: JS-only emitter for the canonical AST.
//
// This module is intentionally small and only supports the current subset of
// `compiler/ast.tuff` nodes.

extern from rt::stdlib use { panic, stringLen, stringSlice, stringCharCodeAt };
extern from rt::vec use { vec_new, vec_push, vec_len, vec_get };

from util::diagnostics use { find_struct_fields };
from util::lexing use { starts_with_at };
from parsing::primitives use { module_path_to_relpath };
from emit::emit_helpers use {
  set_current_file_path, emit_runtime_vec_imports_js, decls_needs_vec_rt,
  rel_import_path, escape_js_string
};

// DroppableVar: tracks a variable that needs drop() on scope exit
struct DroppableVar {
  name: String,
  dropFn: String
}

// Check if type annotation has !drop suffix
fn ty_ann_has_drop(tyAnn: String) : Bool => {
  let mut i = 0;
  while (i < stringLen(tyAnn)) {
    if (stringCharCodeAt(tyAnn, i) == 33) { // '!'
      yield true;
    }
    i = i + 1;
  }
  false
}

// Extract drop function name from type annotation (e.g., "I32!drop" -> "drop")
fn ty_ann_get_drop_fn(tyAnn: String) : String => {
  let mut i = 0;
  while (i < stringLen(tyAnn)) {
    if (stringCharCodeAt(tyAnn, i) == 33) { // '!'
      yield stringSlice(tyAnn, i + 1, stringLen(tyAnn));
    }
    i = i + 1;
  }
  ""
}

fn emit_binop_js(op: BinOp) : String => {
  // NOTE: The current selfhost JS emitter does not fully support `if` as an
  // expression (it compiles it as a statement). So we avoid relying on the
  // value of `if` here and in `emit_expr_js`.
  let mut out = "??";
  if (op is OpAdd) { out = "+"; }
  if (op is OpSub) { out = "-"; }
  if (op is OpMul) { out = "*"; }
  if (op is OpDiv) { out = "/"; }
  if (op is OpEq) { out = "=="; }
  if (op is OpNe) { out = "!="; }
  if (op is OpLt) { out = "<"; }
  if (op is OpLe) { out = "<="; }
  if (op is OpGt) { out = ">"; }
  if (op is OpGe) { out = ">="; }
  if (op is OpAnd) { out = "&&"; }
  if (op is OpOr) { out = "||"; }
  out
}

fn emit_unop_js(op: UnOp) : String => {
  let mut out = "??";
  if (op is OpNot) { out = "!"; }
  if (op is OpNeg) { out = "-"; }
  out
}

// JS precedence (subset) for minimal parenthesization.
// Higher number = binds tighter.
fn binop_prec_js(op: BinOp) : I32 => {
  if (op is OpMul || op is OpDiv) { yield 14; }
  if (op is OpAdd || op is OpSub) { yield 13; }
  if (op is OpLt || op is OpLe || op is OpGt || op is OpGe) { yield 11; }
  if (op is OpEq || op is OpNe) { yield 10; }
  if (op is OpAnd) { yield 6; }
  if (op is OpOr) { yield 5; }
  0
}

fn expr_prec_js(e: Expr) : I32 => {
  if (e is EIf) { yield 4; }
  if (e is EBinary) { yield binop_prec_js(e.op); }
  if (e is EUnary) { yield 17; }
  // Calls/field/index and primaries bind tight enough for our needs.
  20
}

fn emit_path_js(parts: Vec<String>) : String => {
  let mut out = "";
  let mut i = 0;
  while (i < vec_len(parts)) {
    if (i > 0) { out = out + "."; }
    out = out + vec_get(parts, i);
    i = i + 1;
  }
  out
}

fn struct_name_for_lookup(nameExpr: Expr) : String => {
  if (nameExpr is EIdent) { yield nameExpr.name; }
  if (nameExpr is EPath) { yield emit_path_js(nameExpr.parts); }
  panic("struct literal name must be ident or path")
}

fn vec_contains_str(v: Vec<String>, s: String) : Bool => {
  let mut i = 0;
  while (i < vec_len(v)) {
    if (vec_get(v, i) == s) { yield true; }
    i = i + 1;
  }
  false
}

fn emit_struct_lit_js(nameExpr: Expr, values: Vec<Expr>) : String => {
  let structName = struct_name_for_lookup(nameExpr);
  let fields = find_struct_fields(structName);

  if (!(vec_len(fields) == vec_len(values))) {
    panic("wrong number of values in struct literal for " + structName);
  }

  // Emit a JS object literal, defensively asserting that we never generate
  // duplicate object keys (especially `tag`, which historically caused OOMs in
  // prebuilt output when emitted twice).
  let mut entries = vec_new();
  let mut seen = vec_new();

  // Inject tag field for union variant discrimination, but only if the struct
  // does not already define a real `tag` field.
  if (!vec_contains_str(fields, "tag")) {
    vec_push(entries, "tag: \"" + structName + "\"");
    vec_push(seen, "tag");
  }

  let mut i = 0;
  while (i < vec_len(fields)) {
    let fieldName = vec_get(fields, i);
    if (vec_contains_str(seen, fieldName)) {
      panic("duplicate field '" + fieldName + "' in struct literal for " + structName);
    }
    vec_push(seen, fieldName);
    vec_push(entries, fieldName + ": " + emit_expr_js(vec_get(values, i)));
    i = i + 1;
  }

  "({ " + emit_names_csv(entries) + " })"
}

out fn emit_expr_js(e: Expr) : String => {
  // Default fallback for nodes we haven't implemented yet.
  let mut out = "undefined";

  if (e is EUndefined) { out = "undefined"; }

  if (e is EInt) { out = "" + e.value; }

  if (e is EFloat) {
    // For F32, wrap in Math.fround to simulate 32-bit precision.
    // For F64 or untyped, emit the literal directly.
    if (e.suffix == "F32") {
      out = "Math.fround(" + e.text + ")";
    } else {
      out = e.text;
    }
  }

  if (e is EBool) {
    if (e.value) { out = "true"; }
    else { out = "false"; }
  }

  if (e is EString) { out = "\"" + escape_js_string(e.value) + "\""; }
  if (e is EIdent) { out = e.name; }

  if (e is EPath) { out = emit_path_js(e.parts); }

  if (e is ELambda) {
    let params = emit_names_csv(e.params);
    if (e.body is EBlock) {
      let drops = collect_drops(e.body.body);
      let stmts = emit_stmts_js(e.body.body);
      if (vec_len(drops) > 0) {
        let dropCode = emit_drops_js(drops);
        out = "((" + params + ") => {\n" + stmts + "const __tuff_result = " + emit_expr_js(e.body.tail) + ";\n" + dropCode + "return __tuff_result;\n})";
      } else {
        out = "((" + params + ") => {\n" + stmts + "return " + emit_expr_js(e.body.tail) + ";\n})";
      }
    } else {
      out = "((" + params + ") => " + emit_expr_js(e.body) + ")";
    }
  }

  if (e is EStructLit) {
    out = emit_struct_lit_js(e.nameExpr, e.values);
  }

  if (e is EUnary) {
    let inner = emit_expr_js(e.expr);
    // Parenthesize only when the operand binds looser than unary.
    // Example: `!(a < b)` must emit as `!(a < b)`, not `!a < b`.
    let innerStr = if (expr_prec_js(e.expr) < 17) "(" + inner + ")" else inner;
    out = emit_unop_js(e.op) + innerStr;
  }

  if (e is EBinary) {
    let left = emit_expr_js(e.left);
    let right = emit_expr_js(e.right);
    let curPrec = binop_prec_js(e.op);
    let leftStr = if (expr_prec_js(e.left) < curPrec) "(" + left + ")" else left;
    // For left-associative ops, we parenthesize RHS when it binds looser OR equally,
    // preserving explicit grouping like `a - (b - c)`.
    let rightStr = if (expr_prec_js(e.right) <= curPrec) "(" + right + ")" else right;
    out = leftStr + " " + emit_binop_js(e.op) + " " + rightStr;
  }

  if (e is ECall) {
    let mut s = emit_expr_js(e.callee) + "(";
    let mut i = 0;
    while (i < vec_len(e.args)) {
      if (i > 0) { s = s + ", "; }
      s = s + emit_expr_js(vec_get(e.args, i));
      i = i + 1;
    }
    s = s + ")";
    out = s;
  }

  if (e is EIf) {
    out = "(" + emit_expr_js(e.cond) + " ? " + emit_expr_js(e.thenExpr) + " : " + emit_expr_js(e.elseExpr) + ")";
  }

  if (e is EBlock) {
    let drops = collect_drops(e.body);
    let stmts = emit_stmts_js(e.body);
    if (vec_len(drops) > 0) {
      let dropCode = emit_drops_js(drops);
      out = "(() => {\n" + stmts + "const __tuff_result = " + emit_expr_js(e.tail) + ";\n" + dropCode + "return __tuff_result;\n})()";
    } else {
      out = "(() => {\n" + stmts + "return " + emit_expr_js(e.tail) + ";\n})()";
    }
  }

  if (e is EVecLit) {
    let mut pushes = "";
    let mut i = 0;
    while (i < vec_len(e.items)) {
      pushes = pushes + ("__tuff_vec_push(__v, " + emit_expr_js(vec_get(e.items, i)) + ");\n");
      i = i + 1;
    }
    out = "(() => { const __v = __tuff_vec_new();\n" + pushes + "return __v;\n})()";
  }

  if (e is ETupleLit) {
    let mut s = "[";
    let mut i = 0;
    while (i < vec_len(e.items)) {
      if (i > 0) { s = s + ", "; }
      s = s + emit_expr_js(vec_get(e.items, i));
      i = i + 1;
    }
    s = s + "]";
    out = s;
  }

  if (e is EIndex) {
    out = "__tuff_vec_get(" + emit_expr_js(e.base) + ", " + emit_expr_js(e.index) + ")";
  }

  if (e is ETupleIndex) {
    out = emit_expr_js(e.base) + "[" + ("" + e.index) + "]";
  }

  if (e is EField) {
    out = emit_expr_js(e.base) + "." + e.field;
  }

  if (e is EIsType) {
    // Emit runtime type check: expr.tag === "TypeName"
    // TODO: optimize to true/false for statically known types
    out = "(" + emit_expr_js(e.expr) + ".tag === \"" + e.typeToCheck + "\")";
  }

  if (e is EMatch) {
    let mut cases = "";
    let mut def = "";
    let mut sawVariant = false;
    let mut i = 0;
    while (i < vec_len(e.arms)) {
      let arm = vec_get(e.arms, i);
      if (arm.pat is MPWildcard) {
        def = emit_expr_js(arm.expr);
      } else {
        let mut patJs = "";
        if (arm.pat is MPInt) { patJs = "" + arm.pat.value; }
        if (arm.pat is MPBool) { patJs = if (arm.pat.value) "true" else "false"; }
        if (arm.pat is MPString) { patJs = "\"" + escape_js_string(arm.pat.value) + "\""; }
        if (arm.pat is MPVariant) {
          patJs = "\"" + escape_js_string(arm.pat.name) + "\"";
          sawVariant = true;
        }
        cases = cases + ("case " + patJs + ": return " + emit_expr_js(arm.expr) + ";\n");
      }
      i = i + 1;
    }
    if (def == "" && !sawVariant) { panic("match requires _ arm"); }
    if (def == "" && sawVariant) {
      def = "(() => { throw new Error(\"non-exhaustive match\"); })()";
    }
    let scrutJs = if (sawVariant) "(" + emit_expr_js(e.scrut) + ").tag" else emit_expr_js(e.scrut);
    out = "(() => { switch (" + scrutJs + ") {\n" + cases + "default: return " + def + ";\n} })()";
  }

  out
}

fn emit_stmt_js(s: Stmt) : String => {
  let mut out = "";

  if (s is SLet) {
    let kw = if (s.isMut) "let" else "const";
    out = kw + " " + s.name + " = " + emit_expr_js(s.init) + ";\n";
  }

  if (s is SAssign) {
    out = s.name + " = " + emit_expr_js(s.value) + ";\n";
  }

  if (s is SExpr) {
    // Standalone expression statements are needed for side effects.
    // Example: `println("hi");` or `compile_project(inPath, outPath);`
    out = emit_expr_js(s.expr) + ";\n";
  }

  if (s is SYield) {
    if (s.expr is EUndefined) { out = "return;\n"; }
    else { out = "return " + emit_expr_js(s.expr) + ";\n"; }
  }

  if (s is SWhile) {
    let cond = emit_expr_js(s.cond);
    out = "while (" + cond + ") {\n" + emit_stmts_js(s.body) + "}\n";
  }

  if (s is SIf) {
    if (s.hasElse) {
      out = "if (" + emit_expr_js(s.cond) + ") {\n" + emit_stmts_js(s.thenBody) + "} else {\n" + emit_stmts_js(s.elseBody) + "}\n";
    } else {
      out = "if (" + emit_expr_js(s.cond) + ") {\n" + emit_stmts_js(s.thenBody) + "}\n";
    }
  }

  if (s is SIndexAssign) {
    out = "__tuff_vec_set(" + emit_expr_js(s.base) + ", " + emit_expr_js(s.index) + ", " + emit_expr_js(s.value) + ");\n";
  }

  if (s is SFieldAssign) {
    let mut lhs = emit_expr_js(s.base);
    let mut i = 0;
    while (i < vec_len(s.fields)) {
      lhs = lhs + "." + vec_get(s.fields, i);
      i = i + 1;
    }
    out = lhs + " = " + emit_expr_js(s.value) + ";\n";
  }

  out
}

// Collect droppable variables from a list of statements
fn collect_drops(stmts: Vec<Stmt>) : Vec<DroppableVar> => {
  let drops = vec_new();
  let mut i = 0;
  while (i < vec_len(stmts)) {
    let s = vec_get(stmts, i);
    if (s is SLet) {
      if (ty_ann_has_drop(s.tyAnn)) {
        let dropFn = ty_ann_get_drop_fn(s.tyAnn);
        vec_push(drops, DroppableVar { s.name, dropFn });
      }
    }
    i = i + 1;
  }
  drops
}

// Emit drop calls in LIFO order (reverse of declaration order)
fn emit_drops_js(drops: Vec<DroppableVar>) : String => {
  let mut out = "";
  let mut i = vec_len(drops) - 1;
  while (i >= 0) {
    let d = vec_get(drops, i);
    out = out + d.dropFn + "(" + d.name + ");\n";
    i = i - 1;
  }
  out
}

out fn emit_stmts_js(stmts: Vec<Stmt>) : String => {
  let mut out = "";
  let mut i = 0;
  while (i < vec_len(stmts)) {
    out = out + emit_stmt_js(vec_get(stmts, i));
    i = i + 1;
  }
  out
}

// Emit statements with drops at the end (for scopes without tail expr)
out fn emit_stmts_js_with_drops(stmts: Vec<Stmt>) : String => {
  let mut out = "";
  let mut i = 0;
  while (i < vec_len(stmts)) {
    out = out + emit_stmt_js(vec_get(stmts, i));
    i = i + 1;
  }
  // Emit drops at the end of the scope
  let drops = collect_drops(stmts);
  out = out + emit_drops_js(drops);
  out
}

out fn emit_names_csv(names: Vec<String>) : String => {
  let mut out = "";
  let mut i = 0;
  while (i < vec_len(names)) {
    if (i > 0) { out = out + ", "; }
    out = out + vec_get(names, i);
    i = i + 1;
  }
  out
}

fn emit_extern_import_path(modPath: String) : String => {
  if (starts_with_at(modPath, 0, "rt::")) {
    let rel = "rt/" + stringSlice(modPath, 4, stringLen(modPath)) + ".mjs";
    yield rel_import_path(rel);
  }
  if (starts_with_at(modPath, 0, "node::")) {
    yield "node:" + stringSlice(modPath, 6, stringLen(modPath));
  }
  panic("unsupported extern module: " + modPath)
}

fn emit_fn_decl_js(d: DFn, exportAll: Bool, jsName: String, exportThis: Bool) : String => {
  let exportKw = if (exportThis) "export " else "";
  let params = emit_names_csv(d.params);
  let drops = collect_drops(d.body);
  let stmts = emit_stmts_js(d.body);
  // If there are droppable variables, save result, drop, then return
  if (vec_len(drops) > 0) {
    let dropCode = emit_drops_js(drops);
    yield exportKw + "function " + jsName + "(" + params + ") {\n" + stmts + "const __tuff_result = " + emit_expr_js(d.tail) + ";\n" + dropCode + "return __tuff_result;\n}\n";
  }
  exportKw + "function " + jsName + "(" + params + ") {\n" + stmts + "return " + emit_expr_js(d.tail) + ";\n}\n"
}

fn emit_type_union_js(d: DTypeUnion, exportAll: Bool) : String => {
  let mut out = "";
  let dq = "\"";
  let mut i = 0;
  while (i < vec_len(d.variants)) {
    let v = vec_get(d.variants, i);
    // Union variants are runtime constructors/constants and need to be importable
    // across modules (e.g. `from X use { Some, None }`).
    // `out fn` gates function exports; unions are always emitted as exported consts.
    let header = "export const ";
    if (v.hasPayload) {
      out = out + (header + v.name + " = (value) => { return { tag: " + dq + v.name + dq + ", value: value }; };\n");
    } else {
      out = out + (header + v.name + " = { tag: " + dq + v.name + dq + " };\n");
    }
    i = i + 1;
  }
  out
}

fn emit_module_decl_js(d: DModule, prefix: String, exportThis: Bool) : String => {
  // Emit inner decls as top-level functions/consts, then expose an object.
  let mut decls = "";
  let mut entries = "";
  let mut first = true;

  let mut i = 0;
  while (i < vec_len(d.decls)) {
    let inner = vec_get(d.decls, i);

    if (inner is DFn) {
      let jsName = prefix + "__" + d.name + "__" + inner.name;
      decls = decls + emit_fn_decl_js(inner, false, jsName, false);
      if (first) { entries = entries + (inner.name + ": " + jsName); }
      else { entries = entries + (", " + inner.name + ": " + jsName); }
      first = false;
      i = i + 1;
      continue;
    }

    if (inner is DModule) {
      let innerCode = emit_module_decl_js(inner, prefix + "__" + d.name, false);
      decls = decls + innerCode;
      let prop = inner.name;
      if (first) { entries = entries + (prop + ": " + prop); }
      else { entries = entries + (", " + prop + ": " + prop); }
      first = false;
      i = i + 1;
      continue;
    }

    panic("unsupported decl inside module")
  }

  let header = if (exportThis) "export const " else "const ";
  decls + header + d.name + " = { " + entries + " };\n"
}

out fn emit_decl_js(d: Decl, exportAll: Bool) : String => {
  let mut out = "";

  if (d is DExternFrom) {
    let importPath = emit_extern_import_path(d.modulePath);
    out = "import { " + emit_names_csv(d.names) + " } from \"" + importPath + "\";\n";
  }

  if (d is DExternType) {
    // No runtime output for types.
    out = "";
  }

  if (d is DImport) {
    let mut targetModulePath = d.modulePath;
    // Allow importing compiler modules using the repository-root path
    // `src::main::tuff::compiler::...`, but link them using the compiler-root
    // layout (e.g. `./emit/ast_js.mjs`).
    let compilerSrcPrefix = "src::main::tuff::compiler::";
    if (starts_with_at(targetModulePath, 0, compilerSrcPrefix)) {
      targetModulePath = stringSlice(targetModulePath, stringLen(compilerSrcPrefix), stringLen(targetModulePath));
    }

    let targetRel = module_path_to_relpath(targetModulePath) + ".mjs";
    let importPath = rel_import_path(targetRel);
    out = "import { " + emit_names_csv(d.names) + " } from \"" + importPath + "\";\n";
  }

  if (d is DTypeUnion) {
    out = emit_type_union_js(d, exportAll);
  }

  if (d is DStruct) {
    // Structs are compile-time only for now (field order table is updated during parsing).
    out = "";
  }

  if (d is DLet) {
    let kw = if (d.isMut) "let" else "const";
    out = kw + " " + d.name + " = " + emit_expr_js(d.init) + ";\n";
  }

  if (d is DFn) {
    if (d.isClass) {
      // `class fn` becomes a function returning an object of scope fields.
      // In this bootstrap subset, we approximate `this` by returning all params
      // plus any `let` bindings declared in the body (in source order).
      let exportThis = exportAll || d.isOut || d.name == "main";
      let exportKw = if (exportThis) "export " else "";
      let params = emit_names_csv(d.params);

      let fieldNames = vec_new();
      let mut i = 0;
      while (i < vec_len(d.params)) {
        vec_push(fieldNames, vec_get(d.params, i));
        i = i + 1;
      }

      i = 0;
      while (i < vec_len(d.body)) {
        let s = vec_get(d.body, i);
        if (s is SLet) {
          let mut found = false;
          let mut j = 0;
          while (j < vec_len(fieldNames)) {
            if (vec_get(fieldNames, j) == s.name) {
              found = true;
              j = vec_len(fieldNames);
            } else {
              j = j + 1;
            }
          }
          if (!found) { vec_push(fieldNames, s.name); }
        }
        i = i + 1;
      }

      let mut fields = "";
      i = 0;
      while (i < vec_len(fieldNames)) {
        if (i > 0) { fields = fields + ", "; }
        let p = vec_get(fieldNames, i);
        fields = fields + (p + ": " + p);
        i = i + 1;
      }

      let drops = collect_drops(d.body);
      let stmts = emit_stmts_js(d.body);
      if (vec_len(drops) > 0) {
        let dropCode = emit_drops_js(drops);
        out = exportKw + "function " + d.name + "(" + params + ") {\n" + stmts + "const __tuff_result = { " + fields + " };\n" + dropCode + "return __tuff_result;\n}\n";
      } else {
        out = exportKw + "function " + d.name + "(" + params + ") {\n" + stmts + "return { " + fields + " };\n}\n";
      }
    } else {
      if (d.isExtern) {
        // extern fn without body - emit nothing (declaration only, no implementation)
        out = "";
      } else {
        // Regular function
        let exportThis = exportAll || d.isOut || d.name == "main";
        out = emit_fn_decl_js(d, exportAll, d.name, exportThis);
      }
    }
  }

  if (d is DModule) {
    out = emit_module_decl_js(d, "M", true);
  }

  out
}
