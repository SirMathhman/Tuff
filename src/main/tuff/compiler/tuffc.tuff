// Self-hosted compiler entrypoint.

extern from rt::stdlib use { println, stringLen, stringCharCodeAt, readTextFile, writeTextFile };
extern from rt::vec use { vec_len, vec_get, vec_push, vec_new };

from tuffc_lib use { compile_project_to_outputs };
from analyzer use { set_fluff_options };
from build_config use { load_fluff_config };
from util::diagnostics use { set_diagnostics_format };

fn print_usage() : Void => {
  println("usage: tuffc [options] <in.tuff> <out.mjs>");
  println("options:");
  println("  --format <human|json>          Diagnostics output format");
  println("config:");
  println("  build.json (auto-discovered upward from <in.tuff>) controls Fluff rules");
}

// When run as a program, compile file input.
out fn run(argv: Vec<String>) => {
  let mut format = "human";

  let mut inPath = "";
  let mut outPath = "";

  let mut i = 0;
  while (i < vec_len(argv)) {
    let a = vec_get(argv, i);

    if (a == "--format") {
      if (i + 1 >= vec_len(argv)) {
        print_usage();
        yield 1;
      }
      format = vec_get(argv, i + 1);
      i = i + 2;
      continue;
    }

    // Unknown option.
    if (stringLen(a) > 0 && stringCharCodeAt(a, 0) == 45) {
      println("unknown option: " + a);
      print_usage();
      yield 1;
    }

    if (inPath == "") { inPath = a; i = i + 1; continue; }
    if (outPath == "") { outPath = a; i = i + 1; continue; }

    println("too many arguments");
    print_usage();
    yield 1;
  }

  if (inPath == "" || outPath == "") {
    print_usage();
    yield 1;
  }

  set_diagnostics_format(format);

  let cfg = load_fluff_config(inPath);
  set_fluff_options(cfg.unusedLocals, cfg.unusedParams);

  // Compile (no writes), then emit outputs at the CLI layer.
  let r = compile_project_to_outputs(inPath, outPath, readTextFile);
  let outFiles = r.0;
  let jsOutputs = r.1;

  let mut oi = 0;
  while (oi < vec_len(outFiles)) {
    writeTextFile(vec_get(outFiles, oi), vec_get(jsOutputs, oi));
    oi = oi + 1;
  }
  0
}
