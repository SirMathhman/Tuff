// LSP (Language Server Protocol) support for the Tuff compiler.
// Provides go-to-definition, diagnostics, and symbol resolution.

extern from rt::stdlib use { stringLen, stringSlice, stringCharCodeAt };
extern from rt::vec use { vec_new, vec_len, vec_push, vec_get };

from util::diagnostics use {
  set_current_file,
  reset_errors,
  reset_warnings,
  reset_struct_defs,
  get_error_infos,
  get_warning_infos,
  line_col_at,
  DiagInfo,
  LineCol
};

from util::lexing use { is_ident_start, is_ident_part, skip_ws, starts_with_at };

from parsing::primitives use {
  parse_keyword,
  parse_ident,
  module_path_to_relpath,
  parse_optional_semicolon
};

from parsing::types use { parse_type_expr };

from parsing::expr_stmt use { parse_expr_ast, parse_mut_opt };

from parsing::decls use {
  parse_imports_ast,
  parse_extern_decl_ast,
  parse_module_decl_ast,
  parse_fn_decl_ast2,
  parse_class_fn_decl_ast2,
  parse_struct_decl_ast,
  parse_type_union_decl_ast
};

from ast use { span, span_start, span_end, decl_let, decl_let_typed };

from analyzer use { analyze_program };

// ------------------------------------------------------------
// LSP Structs
// ------------------------------------------------------------

// Definition entry for the simple symbol table
struct LspDef {
  tag: String,
  name: String,
  defStart: I32,
  defEnd: I32,
  kind: String,
  defFile: String
}

// Symbol reference with resolved definition
struct LspRef {
  tag: String,
  refStart: I32,
  refEnd: I32,
  defStart: I32,
  defEnd: I32,
  defFile: String
}

// Result of a go-to-definition lookup.
out class fn DefLocation(found: Bool, defStart: I32, defEnd: I32, defFile: String) => {}

// ------------------------------------------------------------
// LSP Constructor helpers
// ------------------------------------------------------------

out fn lsp_def(name: String, defStart: I32, defEnd: I32, kind: String) : LspDef =>
  LspDef { "LspDef", name, defStart, defEnd, kind, "" }

out fn lsp_def_ext(name: String, defStart: I32, defEnd: I32, kind: String, defFile: String) : LspDef =>
  LspDef { "LspDef", name, defStart, defEnd, kind, defFile }

out fn lsp_ref(refStart: I32, refEnd: I32, defStart: I32, defEnd: I32) : LspRef =>
  LspRef { "LspRef", refStart, refEnd, defStart, defEnd, "" }

out fn lsp_ref_ext(refStart: I32, refEnd: I32, defStart: I32, defEnd: I32, defFile: String) : LspRef =>
  LspRef { "LspRef", refStart, refEnd, defStart, defEnd, defFile }

// ------------------------------------------------------------
// Path resolution helpers
// ------------------------------------------------------------

fn find_substring(hay: String, needle: String) : I32 => {
  let mut i = 0;
  while (i + stringLen(needle) <= stringLen(hay)) {
    if (starts_with_at(hay, i, needle)) { yield i; }
    i = i + 1;
  }
  -1
}

fn workspace_root_from_path(p: String) : String => {
  let mut i = find_substring(p, "\\src\\");
  if (i != -1) { yield stringSlice(p, 0, i); }
  i = find_substring(p, "/src/");
  if (i != -1) { yield stringSlice(p, 0, i); }
  i = find_substring(p, "\\std\\");
  if (i != -1) { yield stringSlice(p, 0, i); }
  i = find_substring(p, "/std/");
  if (i != -1) { yield stringSlice(p, 0, i); }
  // fallback: use parent directory
  let mut end = stringLen(p) - 1;
  while (end >= 0) {
    let ch = stringCharCodeAt(p, end);
    if (ch == 47 || ch == 92) { yield stringSlice(p, 0, end); }
    end = end - 1;
  }
  p
}

fn compiler_root_from_path(p: String) : String => {
  let needle1 = "\\src\\main\\tuff\\compiler\\";
  let mut i = find_substring(p, needle1);
  if (i != -1) { yield stringSlice(p, 0, i + stringLen(needle1)); }
  let needle2 = "/src/main/tuff/compiler/";
  i = find_substring(p, needle2);
  if (i != -1) { yield stringSlice(p, 0, i + stringLen(needle2)); }
  ""
}

fn path_join(base: String, rel: String) : String => {
  if (stringLen(base) == 0) { yield rel; }
  let lastCh = stringCharCodeAt(base, stringLen(base) - 1);
  if (lastCh == 47 || lastCh == 92) { yield base + rel; }
  base + "/" + rel
}

fn path_dirname(p: String) : String => {
  let mut i = stringLen(p) - 1;
  while (i >= 0) {
    let ch = stringCharCodeAt(p, i);
    if (ch == 47 || ch == 92) { yield stringSlice(p, 0, i); }
    i = i - 1;
  }
  ""
}

// Resolve a module path (e.g., "util::diagnostics") to an absolute file path.
out fn lsp_resolve_module_path(modulePath: String, currentFilePath: String) : String => {
  let workspaceRoot = workspace_root_from_path(currentFilePath);
  let rel = module_path_to_relpath(modulePath);
  let mut baseDir = path_dirname(currentFilePath);
  let compilerSrcPrefix = "src::main::tuff::compiler::";
  let mut rel2 = rel;

  if (starts_with_at(modulePath, 0, compilerSrcPrefix)) {
    let compilerRootDir = path_join(workspaceRoot, "src/main/tuff/compiler");
    baseDir = compilerRootDir;
    let rest = stringSlice(modulePath, stringLen(compilerSrcPrefix), stringLen(modulePath));
    rel2 = module_path_to_relpath(rest);
  } else {
    if (starts_with_at(modulePath, 0, "src::") || starts_with_at(modulePath, 0, "std::")) {
      baseDir = workspaceRoot;
    } else {
      let cr = compiler_root_from_path(currentFilePath);
      if (stringLen(cr) > 0) { baseDir = cr; }
    }
  }

  path_join(baseDir, rel2 + ".tuff")
}

// ------------------------------------------------------------
// Extern declaration detection helper
// ------------------------------------------------------------

fn kw_at(src: String, i: I32, kw: String) : Bool => {
  if (!starts_with_at(src, i, kw)) { yield false; }
  let end = i + stringLen(kw);
  if (end < stringLen(src) && is_ident_part(stringCharCodeAt(src, end))) { yield false; }
  true
}

fn is_extern_decl_start(src: String, i: I32) : Bool => {
  let j = skip_ws(src, i);
  if (kw_at(src, j, "extern")) { yield true; }
  if (kw_at(src, j, "out")) {
    let k = skip_ws(src, j + 3);
    if (kw_at(src, k, "extern")) { yield true; }
  }
  false
}

// ------------------------------------------------------------
// Symbol table lookup
// ------------------------------------------------------------

// Simple scoped symbol table
out fn lsp_lookup(defs: Vec<LspDef>, name: String) : LspDef => {
  // Search from end (most recent) to handle scoping
  let mut i = vec_len(defs) - 1;
  while (i >= 0) {
    let d = vec_get(defs, i);
    if (d.name == name) { yield d; }
    i = i - 1;
  }
  lsp_def("", -1, -1, "")
}

out fn lsp_lookup_type(defs: Vec<LspDef>, name: String) : LspDef => {
  let mut i = vec_len(defs) - 1;
  while (i >= 0) {
    let d = vec_get(defs, i);
    if (d.name == name && (d.kind == "struct" || d.kind == "type")) { yield d; }
    i = i - 1;
  }
  lsp_def("", -1, -1, "")
}

out fn lsp_lookup_field(defs: Vec<LspDef>, structName: String, fieldName: String) : LspDef => {
  let fullName = structName + "." + fieldName;
  let mut i = 0;
  while (i < vec_len(defs)) {
    let d = vec_get(defs, i);
    if (d.name == fullName && d.kind == "field") { yield d; }
    i = i + 1;
  }
  lsp_def("", -1, -1, "")
}

// Check if offset is in range [start, end)
fn lsp_in_range(offset: I32, start: I32, end: I32) : Bool => offset >= start && offset < end

// ------------------------------------------------------------
// Declaration collection
// ------------------------------------------------------------

out fn lsp_collect_decls(decls: Vec<Decl>, defs: Vec<LspDef>, filePath: String) : Void => {
  let mut i = 0;
  while (i < vec_len(decls)) {
    lsp_collect_decl(vec_get(decls, i), defs, filePath);
    i = i + 1;
  }
}

out fn lsp_collect_decl(d: Decl, defs: Vec<LspDef>, filePath: String) : Void => {
  if (d.tag == "DExternFrom") {
    let mut ni = 0;
    while (ni < vec_len(d.names)) {
      vec_push(defs, lsp_def(vec_get(d.names, ni), span_start(d.span), span_end(d.span), "extern"));
      ni = ni + 1;
    }
  }
  if (d.tag == "DImport") {
    let targetFile = lsp_resolve_module_path(d.modulePath, filePath);
    let mut ni = 0;
    while (ni < vec_len(d.names)) {
      vec_push(defs, lsp_def_ext(vec_get(d.names, ni), 0, 0, "import", targetFile));
      ni = ni + 1;
    }
  }
  if (d.tag == "DLet") {
    vec_push(defs, lsp_def(d.name, span_start(d.span), span_end(d.span), "var"));
  }
  if (d.tag == "DFn") {
    vec_push(defs, lsp_def(d.name, span_start(d.span), span_end(d.span), "fn"));
  }
  if (d.tag == "DClassFn") {
    vec_push(defs, lsp_def(d.name, span_start(d.span), span_end(d.span), "fn"));
  }
  if (d.tag == "DStruct") {
    vec_push(defs, lsp_def(d.name, span_start(d.span), span_end(d.span), "struct"));
    let mut fi = 0;
    while (fi < vec_len(d.fields)) {
      let fieldName = vec_get(d.fields, fi);
      vec_push(defs, lsp_def(d.name + "." + fieldName, span_start(d.span), span_end(d.span), "field"));
      fi = fi + 1;
    }
  }
  if (d.tag == "DTypeUnion") {
    vec_push(defs, lsp_def(d.name, span_start(d.span), span_end(d.span), "type"));
    let mut vi = 0;
    while (vi < vec_len(d.variants)) {
      let v = vec_get(d.variants, vi);
      vec_push(defs, lsp_def(v.name, span_start(v.span), span_end(v.span), "variant"));
      vi = vi + 1;
    }
  }
  if (d.tag == "DModule") {
    vec_push(defs, lsp_def(d.name, span_start(d.span), span_end(d.span), "module"));
    lsp_collect_decls(d.decls, defs, filePath);
  }
}

// ------------------------------------------------------------
// Reference resolution
// ------------------------------------------------------------

// Resolve references in expressions. Returns inferred type name for field access.
out fn lsp_resolve_expr(e: Expr, defs: Vec<LspDef>, refs: Vec<LspRef>) : String => {
  if (e.tag == "EIdent") {
    let d = lsp_lookup(defs, e.name);
    if (d.defStart >= 0 || stringLen(d.defFile) > 0) {
      vec_push(refs, lsp_ref_ext(span_start(e.span), span_end(e.span), d.defStart, d.defEnd, d.defFile));
    }
    yield "";
  }
  
  if (e.tag == "EStructLit") {
    let mut structName = "";
    let mut nameSpan = e.span;
    if (e.nameExpr.tag == "EIdent") {
      structName = e.nameExpr.name;
      nameSpan = e.nameExpr.span;
    }
    if (e.nameExpr.tag == "EPath") {
      if (vec_len(e.nameExpr.parts) > 0) {
        structName = vec_get(e.nameExpr.parts, vec_len(e.nameExpr.parts) - 1);
        nameSpan = e.nameExpr.span;
      }
    }

    if (stringLen(structName) > 0) {
      let tyDef = lsp_lookup_type(defs, structName);
      if (tyDef.defStart >= 0 || stringLen(tyDef.defFile) > 0) {
        vec_push(refs, lsp_ref_ext(span_start(nameSpan), span_end(nameSpan), tyDef.defStart, tyDef.defEnd, tyDef.defFile));
      }
    }
    let mut vi = 0;
    while (vi < vec_len(e.values)) {
      lsp_resolve_expr(vec_get(e.values, vi), defs, refs);
      vi = vi + 1;
    }
    yield structName;
  }
  
  if (e.tag == "EField") {
    let baseTy = lsp_resolve_expr(e.base, defs, refs);
    if (stringLen(baseTy) > 0) {
      let fieldDef = lsp_lookup_field(defs, baseTy, e.field);
      if (fieldDef.defStart >= 0) {
        let fieldStart = span_end(e.base.span) + 1;
        vec_push(refs, lsp_ref_ext(fieldStart, span_end(e.span), fieldDef.defStart, fieldDef.defEnd, fieldDef.defFile));
      }
    }
    yield "";
  }
  
  if (e.tag == "ECall") {
    lsp_resolve_expr(e.callee, defs, refs);
    let mut ai = 0;
    while (ai < vec_len(e.args)) {
      lsp_resolve_expr(vec_get(e.args, ai), defs, refs);
      ai = ai + 1;
    }
  }
  
  if (e.tag == "EBinary") {
    lsp_resolve_expr(e.left, defs, refs);
    lsp_resolve_expr(e.right, defs, refs);
  }
  
  if (e.tag == "EUnary") {
    lsp_resolve_expr(e.expr, defs, refs);
  }
  
  if (e.tag == "EIf") {
    lsp_resolve_expr(e.cond, defs, refs);
    lsp_resolve_expr(e.thenExpr, defs, refs);
    lsp_resolve_expr(e.elseExpr, defs, refs);
  }
  
  if (e.tag == "EBlock") {
    lsp_resolve_stmts(e.body, defs, refs);
    lsp_resolve_expr(e.tail, defs, refs);
  }
  
  if (e.tag == "ELambda") {
    let mut pi = 0;
    while (pi < vec_len(e.params)) {
      vec_push(defs, lsp_def(vec_get(e.params, pi), span_start(e.span), span_end(e.span), "param"));
      pi = pi + 1;
    }
    lsp_resolve_expr(e.body, defs, refs);
  }
  
  if (e.tag == "EMatch") {
    lsp_resolve_expr(e.scrut, defs, refs);
    let mut mi = 0;
    while (mi < vec_len(e.arms)) {
      let arm = vec_get(e.arms, mi);
      let mut bi = 0;
      while (bi < vec_len(arm.bindings)) {
        vec_push(defs, lsp_def(vec_get(arm.bindings, bi), span_start(arm.span), span_end(arm.span), "binding"));
        bi = bi + 1;
      }
      lsp_resolve_expr(arm.expr, defs, refs);
      mi = mi + 1;
    }
  }
  
  if (e.tag == "EIndex") {
    lsp_resolve_expr(e.base, defs, refs);
    lsp_resolve_expr(e.index, defs, refs);
  }
  
  if (e.tag == "ETupleIndex") {
    lsp_resolve_expr(e.base, defs, refs);
  }
  
  if (e.tag == "EVecLit") {
    let mut ii = 0;
    while (ii < vec_len(e.items)) {
      lsp_resolve_expr(vec_get(e.items, ii), defs, refs);
      ii = ii + 1;
    }
  }
  
  if (e.tag == "ETupleLit") {
    let mut ii = 0;
    while (ii < vec_len(e.items)) {
      lsp_resolve_expr(vec_get(e.items, ii), defs, refs);
      ii = ii + 1;
    }
  }
  
  ""
}

out fn lsp_resolve_stmt(s: Stmt, defs: Vec<LspDef>, refs: Vec<LspRef>) : Void => {
  if (s.tag == "SLet") {
    lsp_resolve_expr(s.init, defs, refs);
    vec_push(defs, lsp_def(s.name, span_start(s.span), span_end(s.span), "var"));
  }
  
  if (s.tag == "SAssign") {
    let d = lsp_lookup(defs, s.name);
    if (d.defStart >= 0) {
      vec_push(refs, lsp_ref(span_start(s.span), span_start(s.span) + stringLen(s.name), d.defStart, d.defEnd));
    }
    lsp_resolve_expr(s.value, defs, refs);
  }
  
  if (s.tag == "SExpr") {
    lsp_resolve_expr(s.expr, defs, refs);
  }
  
  if (s.tag == "SYield") {
    lsp_resolve_expr(s.expr, defs, refs);
  }
  
  if (s.tag == "SWhile") {
    lsp_resolve_expr(s.cond, defs, refs);
    lsp_resolve_stmts(s.body, defs, refs);
  }
  
  if (s.tag == "SIf") {
    lsp_resolve_expr(s.cond, defs, refs);
    lsp_resolve_stmts(s.thenBody, defs, refs);
    if (s.hasElse) {
      lsp_resolve_stmts(s.elseBody, defs, refs);
    }
  }
  
  if (s.tag == "SIndexAssign") {
    lsp_resolve_expr(s.base, defs, refs);
    lsp_resolve_expr(s.index, defs, refs);
    lsp_resolve_expr(s.value, defs, refs);
  }
  
  if (s.tag == "SFieldAssign") {
    lsp_resolve_expr(s.base, defs, refs);
    lsp_resolve_expr(s.value, defs, refs);
  }
}

out fn lsp_resolve_stmts(stmts: Vec<Stmt>, defs: Vec<LspDef>, refs: Vec<LspRef>) : Void => {
  let mut i = 0;
  while (i < vec_len(stmts)) {
    lsp_resolve_stmt(vec_get(stmts, i), defs, refs);
    i = i + 1;
  }
}

out fn lsp_resolve_decl(d: Decl, defs: Vec<LspDef>, refs: Vec<LspRef>) : Void => {
  if (d.tag == "DLet") {
    lsp_resolve_expr(d.init, defs, refs);
  }
  
  if (d.tag == "DFn") {
    let mut pi = 0;
    while (pi < vec_len(d.params)) {
      vec_push(defs, lsp_def(vec_get(d.params, pi), span_start(d.span), span_end(d.span), "param"));
      pi = pi + 1;
    }
    lsp_resolve_stmts(d.body, defs, refs);
    lsp_resolve_expr(d.tail, defs, refs);
  }
  
  if (d.tag == "DClassFn") {
    let mut pi = 0;
    while (pi < vec_len(d.params)) {
      vec_push(defs, lsp_def(vec_get(d.params, pi), span_start(d.span), span_end(d.span), "param"));
      pi = pi + 1;
    }
    lsp_resolve_stmts(d.body, defs, refs);
    lsp_resolve_expr(d.tail, defs, refs);
  }
  
  if (d.tag == "DModule") {
    lsp_resolve_decls(d.decls, defs, refs);
  }
}

out fn lsp_resolve_decls(decls: Vec<Decl>, defs: Vec<LspDef>, refs: Vec<LspRef>) : Void => {
  let mut i = 0;
  while (i < vec_len(decls)) {
    lsp_resolve_decl(vec_get(decls, i), defs, refs);
    i = i + 1;
  }
}

fn lsp_find_ref_at(refs: Vec<LspRef>, offset: I32) : LspRef => {
  let mut i = 0;
  while (i < vec_len(refs)) {
    let r = vec_get(refs, i);
    if (lsp_in_range(offset, r.refStart, r.refEnd)) { yield r; }
    i = i + 1;
  }
  lsp_ref_ext(-1, -1, -1, -1, "")
}

// ------------------------------------------------------------
// Identifier extraction helpers
// ------------------------------------------------------------

// Fallback: extract identifier under (or just left of) the cursor.
fn lsp_ident_at(src: String, offset: I32) : String => {
  if (offset < 0 || offset >= stringLen(src)) { yield ""; }

  let mut i = offset;
  if (!is_ident_part(stringCharCodeAt(src, i)) && i > 0 && is_ident_part(stringCharCodeAt(src, i - 1))) {
    i = i - 1;
  }
  if (!is_ident_part(stringCharCodeAt(src, i))) { yield ""; }

  let mut start = i;
  while (start > 0 && is_ident_part(stringCharCodeAt(src, start - 1))) { start = start - 1; }
  if (!is_ident_start(stringCharCodeAt(src, start))) { yield ""; }

  let mut end = i + 1;
  while (end < stringLen(src) && is_ident_part(stringCharCodeAt(src, end))) { end = end + 1; }

  stringSlice(src, start, end)
}

fn lsp_has_double_colon(s: String) : Bool => {
  let mut i = 0;
  while (i + 1 < stringLen(s)) {
    if (stringCharCodeAt(s, i) == 58 && stringCharCodeAt(s, i + 1) == 58) { yield true; }
    i = i + 1;
  }
  false
}

fn lsp_is_module_path_part(code: I32) : Bool => is_ident_part(code) || code == 58

// Fallback: extract module path (containing ::) under the cursor.
fn lsp_module_path_at(src: String, offset: I32) : String => {
  if (offset < 0 || offset >= stringLen(src)) { yield ""; }
  let mut i = offset;

  if (!lsp_is_module_path_part(stringCharCodeAt(src, i)) && i > 0 && lsp_is_module_path_part(stringCharCodeAt(src, i - 1))) {
    i = i - 1;
  }
  if (!lsp_is_module_path_part(stringCharCodeAt(src, i))) { yield ""; }

  let mut start = i;
  while (start > 0 && lsp_is_module_path_part(stringCharCodeAt(src, start - 1))) { start = start - 1; }
  let mut end = i + 1;
  while (end < stringLen(src) && lsp_is_module_path_part(stringCharCodeAt(src, end))) { end = end + 1; }

  let mut s = stringSlice(src, start, end);

  // trim leading/trailing ':'
  while (stringLen(s) > 0 && stringCharCodeAt(s, 0) == 58) {
    s = stringSlice(s, 1, stringLen(s));
  }
  while (stringLen(s) > 0 && stringCharCodeAt(s, stringLen(s) - 1) == 58) {
    s = stringSlice(s, 0, stringLen(s) - 1);
  }

  if (!lsp_has_double_colon(s)) { yield ""; }
  s
}

// ------------------------------------------------------------
// File parsing helper
// ------------------------------------------------------------

out fn lsp_parse_file(src: String) : Vec<Decl> => {
  let decls = vec_new();
  let mut i = 0;

  // zero or more extern declarations
  while (true) {
    if (is_extern_decl_start(src, i)) {
      let ex = parse_extern_decl_ast(src, i);
      vec_push(decls, ex.decl);
      i = ex.nextPos;
      continue;
    }
    break;
  }

  // zero or more imports
  let imps = parse_imports_ast(src, i);
  let mut ii = 0;
  while (ii < vec_len(imps.decls)) {
    vec_push(decls, vec_get(imps.decls, ii));
    ii = ii + 1;
  }
  i = imps.nextPos;

  // Parse all declarations in any order
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "module")) {
      let m = parse_module_decl_ast(src, i);
      vec_push(decls, m.decl);
      i = m.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "type")) {
      let td = parse_type_union_decl_ast(src, i, false);
      vec_push(decls, td.decl);
      i = td.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "struct")) {
      let sd = parse_struct_decl_ast(src, i);
      vec_push(decls, sd.decl);
      i = sd.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "let")) {
      let start = skip_ws(src, i);
      i = parse_keyword(src, i, "let");
      let mutOpt = parse_mut_opt(src, i);
      i = mutOpt.nextPos;
      let name = parse_ident(src, i);
      i = name.nextPos;

      let mut tyAnn = "";
      let t0 = skip_ws(src, i);
      if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) {
        let _ty = parse_type_expr(src, t0 + 1);
        tyAnn = _ty.v0;
        i = _ty.v1;
      }

      i = parse_keyword(src, i, "=");
      let expr = parse_expr_ast(src, i);
      i = expr.nextPos;
      i = parse_optional_semicolon(src, i);
      if (tyAnn == "") {
        vec_push(decls, decl_let(span(start, i), mutOpt.ok, name.text, expr.expr));
      } else {
        vec_push(decls, decl_let_typed(span(start, i), mutOpt.ok, name.text, tyAnn, expr.expr));
      }
      continue;
    }
    if (starts_with_at(src, j, "fn")) {
      let f = parse_fn_decl_ast2(src, i, false);
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "class")) {
      let f = parse_class_fn_decl_ast2(src, i, false);
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "out")) {
      let k0 = parse_keyword(src, i, "out");
      let j2 = skip_ws(src, k0);
      if (starts_with_at(src, j2, "class")) {
        let f = parse_class_fn_decl_ast2(src, i, false);
        vec_push(decls, f.decl);
        i = f.nextPos;
        continue;
      }
      let f = parse_fn_decl_ast2(src, i, false);
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    break;
  }

  decls
}

// ------------------------------------------------------------
// Public LSP API
// ------------------------------------------------------------

// Parse+analyze a single file and collect diagnostics without panicking.
// Returns false if there are errors.
out fn lsp_check_file(src: String, filePath: String) : Bool => {
  reset_struct_defs();
  reset_errors();
  reset_warnings();
  set_current_file(filePath);

  let decls = lsp_parse_file(src);

  // Run analyzer (won't panic, just collects errors)
  analyze_program(src, decls);

  // Return true if no errors
  vec_len(get_error_infos()) == 0
}

// Re-export diagnostic accessors for TypeScript interop.
out fn lsp_get_errors() : Vec<DiagInfo> => get_error_infos()
out fn lsp_get_warnings() : Vec<DiagInfo> => get_warning_infos()
out fn lsp_line_col(src: String, offset: I32) : LineCol => line_col_at(src, offset)

// Main LSP go-to-definition API.
out fn lsp_find_definition(src: String, offset: I32, filePath: String) : DefLocation => {
  reset_struct_defs();
  reset_errors();
  reset_warnings();
  set_current_file(filePath);

  let decls = lsp_parse_file(src);
  
  let defs = vec_new();
  let refs = vec_new();
  
  // Pass 1: collect all declarations
  lsp_collect_decls(decls, defs, filePath);
  
  // Pass 2: resolve references
  lsp_resolve_decls(decls, defs, refs);
  
  // Find reference at offset
  let r = lsp_find_ref_at(refs, offset);
  if (r.refStart < 0) {
    // Fallback for non-expression positions.
    let modulePath = lsp_module_path_at(src, offset);
    if (stringLen(modulePath) > 0) {
      let targetFile = lsp_resolve_module_path(modulePath, filePath);
      yield DefLocation(true, 0, 0, targetFile);
    }

    let ident = lsp_ident_at(src, offset);
    if (stringLen(ident) > 0) {
      let d = lsp_lookup(defs, ident);
      if (d.defStart >= 0 || stringLen(d.defFile) > 0) {
        yield DefLocation(true, d.defStart, d.defEnd, d.defFile);
      }
    }

    yield DefLocation(false, 0, 0, "");
  }
  
  DefLocation(true, r.defStart, r.defEnd, r.defFile)
}
