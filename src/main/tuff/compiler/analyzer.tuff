// Phase 4 (initial): Analyzer pass.
//
// For now, this module focuses on enforcing the language's no-shadowing rule
// (a name may not be redeclared in an enclosing scope).

extern from rt::stdlib use { stringLen, stringCharCodeAt, stringSlice };
extern from rt::vec use { vec_new, vec_len, vec_push, vec_get, vec_set };

from util::diagnostics use { panic_at };
from ast use { span_start };

// ------------------------------------------------------------
// Phase 4a/4b: minimal type environment
// ------------------------------------------------------------

struct StructDef {
  tag: String,
  name: String,
  fields: Vec<String>,
  fieldTyAnns: Vec<String>
}

struct FnSig {
  tag: String,
  name: String,
  // Optional generic params (fn id<T>(...)).
  typeParams: Vec<String>,
  params: Vec<String>,
  paramTyAnns: Vec<String>,
  retTyAnn: String
}

struct UnionDef {
  tag: String,
  name: String,
  // Optional generic params (type Option<T> = ...).
  typeParams: Vec<String>,
  variants: Vec<UnionVariantInfo>
}

struct UnionVariantInfo {
  tag: String,
  name: String,
  hasPayload: Bool,
  payloadTyAnns: Vec<String>
}

// Binding info tracked per-scope.
// tyTag is a tiny, analyzer-internal type approximation for Phase 4.
struct Binding {
  tag: String,
  name: String,
  isMut: Bool,
  tyTag: String
}

// Generic substitution entry: T -> I32, etc.
struct TySubst {
  tag: String,
  name: String,
  ty: String
}

// Flow-sensitive narrowing (Phase 4 completion scaffold).
// Tracks that a union-typed binding is known to have a particular `tag`.
struct NarrowedTag {
  tag: String,
  name: String,
  variant: String
}

fn this_struct_name(className: String) : String => "__This__" + className

fn mk_union_variant_info(name: String, hasPayload: Bool, payloadTyAnns: Vec<String>) =>
  UnionVariantInfo { "UnionVariantInfo", name, hasPayload, payloadTyAnns }

fn mk_struct_def(name: String, fields: Vec<String>, fieldTyAnns: Vec<String>) =>
  StructDef { "StructDef", name, fields, fieldTyAnns }

fn mk_fn_sig(name: String, typeParams, params: Vec<String>, paramTyAnns: Vec<String>, retTyAnn: String) =>
  FnSig { "FnSig", name, typeParams, params, paramTyAnns, retTyAnn }

fn mk_union_def(name: String, typeParams, variants) => UnionDef { "UnionDef", name, typeParams, variants }

fn mk_binding(name: String, isMut: Bool, tyTag: String) => Binding { "Binding", name, isMut, tyTag }
fn mk_subst(name: String, ty: String) => TySubst { "TySubst", name, ty }
fn mk_narrowed_tag(name: String, variant: String) => NarrowedTag { "NarrowedTag", name, variant }

fn narrow_lookup(narrowed, name: String) : String => {
  let mut i = 0;
  while (i < vec_len(narrowed)) {
    let n = vec_get(narrowed, i);
    if (n.name == name) { yield n.variant; }
    i = i + 1;
  }
  ""
}

fn narrow_clone(narrowed) => {
  let out = vec_new();
  let mut i = 0;
  while (i < vec_len(narrowed)) {
    vec_push(out, vec_get(narrowed, i));
    i = i + 1;
  }
  out
}

fn subst_lookup(subst, name: String) : String => {
  let mut i = 0;
  while (i < vec_len(subst)) {
    let s = vec_get(subst, i);
    if (s.name == name) { yield s.ty; }
    i = i + 1;
  }
  ""
}

fn subst_bind(subst, name: String, ty: String) : Void => {
  let mut i = 0;
  while (i < vec_len(subst)) {
    let s = vec_get(subst, i);
    if (s.name == name) {
      // If already bound, keep the existing binding (must match after normalization).
      if (normalize_ty_ann(s.ty) != normalize_ty_ann(ty)) {
        vec_set(subst, i, mk_subst(name, ty_unknown()));
      }
      yield;
    }
    i = i + 1;
  }
  vec_push(subst, mk_subst(name, ty));
}

fn infer_int_const(e) : I32 => {
  if (e.tag == "EInt") { yield e.value; }
  -1
}

fn type_is_ws(ch: I32) : Bool => ch == 32 || ch == 9 || ch == 10 || ch == 13
fn ty_is_digit(ch: I32) : Bool => ch >= 48 && ch <= 57

fn ty_skip_ws(t: String, i: I32) : I32 => {
  let mut k = i;
  while (k < stringLen(t) && type_is_ws(stringCharCodeAt(t, k))) { k = k + 1; }
  k
}

fn ty_starts_with(t: String, i: I32, s: String) : Bool => {
  let mut j = 0;
  while (j < stringLen(s)) {
    if (!(i + j < stringLen(t))) { yield false; }
    if (stringCharCodeAt(t, i + j) != stringCharCodeAt(s, j)) { yield false; }
    j = j + 1;
  }
  true
}

fn ty_unknown() : String => "Unknown"
fn ty_int_lit() : String => "IntLit"
fn ty_float_lit() : String => "FloatLit"
fn ty_bool() : String => "Bool"
fn ty_i32() : String => "I32"
fn ty_i8() : String => "I8"
fn ty_i16() : String => "I16"
fn ty_i64() : String => "I64"
fn ty_f32() : String => "F32"
fn ty_f64() : String => "F64"
fn ty_u32() : String => "U32"
fn ty_u8() : String => "U8"
fn ty_u16() : String => "U16"
fn ty_u64() : String => "U64"
fn ty_char() : String => "Char"
fn ty_string() : String => "String"
fn ty_void() : String => "Void"

fn ty_fn_type(typeParams, paramTyAnns, retTyAnn: String) : String => {
  // Compact function type tag used internally by the analyzer.
  // Example: Fn(I32,I32)->I32
  // Generic example: Fn<T>(T)->T
  let mut out = "Fn";
  if (vec_len(typeParams) > 0) {
    out = out + "<";
    let mut ti = 0;
    while (ti < vec_len(typeParams)) {
      if (ti > 0) { out = out + ","; }
      out = out + normalize_ty_ann(vec_get(typeParams, ti));
      ti = ti + 1;
    }
    out = out + ">";
  }
  out = out + "(";
  let mut i = 0;
  while (i < vec_len(paramTyAnns)) {
    if (i > 0) { out = out + ","; }
    let t = vec_get(paramTyAnns, i);
    out = out + normalize_ty_ann(if (t == "") ty_unknown() else t);
    i = i + 1;
  }
  let rt = if (retTyAnn == "") ty_unknown() else normalize_ty_ann(retTyAnn);
  out = out + ")->" + rt;
  out
}

fn ty_is_fn_type(t: String) : Bool => {
  // `Fn(...)->Ret` or `Fn<T>(...)->Ret`
  if (stringLen(t) < 2) { yield false; }
  if (!(stringSlice(t, 0, 2) == "Fn")) { yield false; }
  true
}

fn ty_fn_type_params(t: String) => {
  // Extract type params from `Fn<T,U>(...)->...`.
  // Returns empty vec for non-generic `Fn(...)->...`.
  let out = vec_new();
  if (stringLen(t) < 3) { yield out; }
  if (!(stringSlice(t, 0, 2) == "Fn")) { yield out; }
  if (!(stringLen(t) >= 3 && stringCharCodeAt(t, 2) == 60)) { yield out; } // '<'

  let mut i = 3;
  let mut start = i;
  while (i < stringLen(t)) {
    let ch = stringCharCodeAt(t, i);
    if (ch == 44) { // ','
      vec_push(out, normalize_ty_ann(stringSlice(t, start, i)));
      i = i + 1;
      start = i;
      continue;
    }
    if (ch == 62) { // '>'
      if (i > start) { vec_push(out, normalize_ty_ann(stringSlice(t, start, i))); }
      yield out;
    }
    i = i + 1;
  }
  out
}

fn ty_fn_ret(t: String) : String => {
  // Extract Ret from `Fn(...)->Ret`.
  let pat = ")->";
  let mut i = 0;
  while (i + stringLen(pat) <= stringLen(t)) {
    if (stringSlice(t, i, i + stringLen(pat)) == pat) {
      yield stringSlice(t, i + stringLen(pat), stringLen(t));
    }
    i = i + 1;
  }
  ty_unknown()
}

fn ty_fn_param_tys(t: String) => {
  // Extract param types from `Fn(...)->Ret` or `Fn<T>(...)->Ret`.
  // Returns a vec of normalized types; Unknown for unannotated params.
  let out = vec_new();
  if (!ty_is_fn_type(t)) { yield out; }

  let mut i = 2; // after "Fn"
  // Skip optional generic params `Fn<...>`.
  if (i < stringLen(t) && stringCharCodeAt(t, i) == 60) { // '<'
    let mut depth = 1;
    i = i + 1;
    while (i < stringLen(t) && depth > 0) {
      let ch = stringCharCodeAt(t, i);
      if (ch == 60) { depth = depth + 1; }
      if (ch == 62) { depth = depth - 1; }
      i = i + 1;
    }
  }

  // Find '('
  while (i < stringLen(t) && stringCharCodeAt(t, i) != 40) { i = i + 1; }
  if (!(i < stringLen(t) && stringCharCodeAt(t, i) == 40)) { yield out; }

  let mut k = i + 1;
  let mut start = k;
  let mut angleDepth = 0;
  let mut bracketDepth = 0;
  while (k < stringLen(t)) {
    let ch = stringCharCodeAt(t, k);
    if (ch == 60) { angleDepth = angleDepth + 1; k = k + 1; continue; } // '<'
    if (ch == 62) { if (angleDepth > 0) { angleDepth = angleDepth - 1; } k = k + 1; continue; } // '>'
    if (ch == 91) { bracketDepth = bracketDepth + 1; k = k + 1; continue; } // '['
    if (ch == 93) { if (bracketDepth > 0) { bracketDepth = bracketDepth - 1; } k = k + 1; continue; } // ']'

    if (ch == 44 && angleDepth == 0 && bracketDepth == 0) { // ','
      let part = stringSlice(t, start, k);
      let trimmedStart = ty_skip_ws(part, 0);
      let mut trimmedEnd = stringLen(part);
      while (trimmedEnd > 0 && type_is_ws(stringCharCodeAt(part, trimmedEnd - 1))) { trimmedEnd = trimmedEnd - 1; }
      if (trimmedEnd > trimmedStart) { vec_push(out, normalize_ty_ann(stringSlice(part, trimmedStart, trimmedEnd))); }
      k = k + 1;
      start = k;
      continue;
    }

    if (ch == 41 && angleDepth == 0 && bracketDepth == 0) { // ')'
      let part = stringSlice(t, start, k);
      let trimmedStart = ty_skip_ws(part, 0);
      let mut trimmedEnd = stringLen(part);
      while (trimmedEnd > 0 && type_is_ws(stringCharCodeAt(part, trimmedEnd - 1))) { trimmedEnd = trimmedEnd - 1; }
      if (trimmedEnd > trimmedStart) { vec_push(out, normalize_ty_ann(stringSlice(part, trimmedStart, trimmedEnd))); }
      yield out;
    }

    k = k + 1;
  }
  out
}

fn normalize_ty_ann(t: String) : String => {
  // Keep this minimal (Phase 4). We mostly do string equality checks.
  if (t == "Int") { yield ty_i32(); }
  if (t == "I8") { yield ty_i8(); }
  if (t == "I16") { yield ty_i16(); }
  if (t == "I32") { yield ty_i32(); }
  if (t == "I64") { yield ty_i64(); }
  if (t == "F32") { yield ty_f32(); }
  if (t == "F64") { yield ty_f64(); }
  if (t == "U8") { yield ty_u8(); }
  if (t == "U16") { yield ty_u16(); }
  if (t == "U32") { yield ty_u32(); }
  if (t == "U64") { yield ty_u64(); }
  if (t == "Char") { yield ty_char(); }
  if (t == "Bool") { yield ty_bool(); }
  if (t == "String") { yield ty_string(); }
  if (t == "Void") { yield ty_void(); }
  t
}

class fn ParsedTyApp(ok: Bool, callee: String, args, nextPos: I32) => {}
class fn ParsedTyArray(ok: Bool, elem: String, init: I32, len: I32) => {}

fn vec_contains_str(v, s: String) : Bool => {
  let mut i = 0;
  while (i < vec_len(v)) {
    if (vec_get(v, i) == s) { yield true; }
    i = i + 1;
  }
  false
}

fn ty_is_type_var(typeParams, t: String) : Bool => vec_contains_str(typeParams, t)

fn ty_parse_app(t: String) : ParsedTyApp => {
  // Parse `Name<...>` at top-level. Returns ok=false if not an app.
  let mut i = 0;
  i = ty_skip_ws(t, i);
  let mut lt = -1;
  // Find first '<' at depth 0.
  let mut depth = 0;
  while (i < stringLen(t)) {
    let ch = stringCharCodeAt(t, i);
    if (ch == 60) { // '<'
      if (depth == 0) { lt = i; break; }
      depth = depth + 1;
      i = i + 1;
      continue;
    }
    if (ch == 62) { // '>'
      if (depth > 0) { depth = depth - 1; }
      i = i + 1;
      continue;
    }
    i = i + 1;
  }
  if (lt == -1) { yield ParsedTyApp(false, "", vec_new(), 0); }

  let callee = stringSlice(t, 0, lt);
  // Parse args inside <...>
  let mut k = lt + 1;
  let args = vec_new();
  let mut start = k;
  let mut aDepth = 0;
  while (k < stringLen(t)) {
    let ch = stringCharCodeAt(t, k);
    if (ch == 60) { aDepth = aDepth + 1; k = k + 1; continue; }
    if (ch == 62) {
      if (aDepth == 0) {
        let part = stringSlice(t, start, k);
        let trimmedStart = ty_skip_ws(part, 0);
        let mut trimmedEnd = stringLen(part);
        while (trimmedEnd > 0 && type_is_ws(stringCharCodeAt(part, trimmedEnd - 1))) { trimmedEnd = trimmedEnd - 1; }
        vec_push(args, stringSlice(part, trimmedStart, trimmedEnd));
        yield ParsedTyApp(true, callee, args, k + 1);
      }
      aDepth = aDepth - 1;
      k = k + 1;
      continue;
    }
    if (ch == 44 && aDepth == 0) { // ','
      let part = stringSlice(t, start, k);
      let trimmedStart = ty_skip_ws(part, 0);
      let mut trimmedEnd = stringLen(part);
      while (trimmedEnd > 0 && type_is_ws(stringCharCodeAt(part, trimmedEnd - 1))) { trimmedEnd = trimmedEnd - 1; }
      vec_push(args, stringSlice(part, trimmedStart, trimmedEnd));
      k = k + 1;
      start = k;
      continue;
    }
    k = k + 1;
  }
  ParsedTyApp(false, "", vec_new(), 0)
}

fn ty_parse_array(t: String) : ParsedTyArray => {
  // Parse `[Elem;init;len]` (numbers required). Returns ok=false if not array.
  let mut i = ty_skip_ws(t, 0);
  if (!(i < stringLen(t) && stringCharCodeAt(t, i) == 91)) { yield ParsedTyArray(false, "", 0, 0); } // '['
  let mut end = stringLen(t);
  while (end > 0 && type_is_ws(stringCharCodeAt(t, end - 1))) { end = end - 1; }
  if (!(end > 0 && stringCharCodeAt(t, end - 1) == 93)) { yield ParsedTyArray(false, "", 0, 0); } // ']'

  // Split inner by ';' at depth 0.
  let mut k = i + 1;
  let mut partStart = k;
  let parts = vec_new();
  let mut depth = 0;
  while (k < end - 1) {
    let ch = stringCharCodeAt(t, k);
    if (ch == 60) { depth = depth + 1; k = k + 1; continue; }
    if (ch == 62) { if (depth > 0) { depth = depth - 1; } k = k + 1; continue; }
    if (ch == 59 && depth == 0) { // ';'
      vec_push(parts, stringSlice(t, partStart, k));
      k = k + 1;
      partStart = k;
      continue;
    }
    k = k + 1;
  }
  vec_push(parts, stringSlice(t, partStart, end - 1));
  if (vec_len(parts) != 3) { yield ParsedTyArray(false, "", 0, 0); }

  let elemRaw = vec_get(parts, 0);
  let elem = stringSlice(elemRaw, ty_skip_ws(elemRaw, 0), stringLen(elemRaw));
  let initStr = vec_get(parts, 1);
  let lenStr = vec_get(parts, 2);

  // Parse integers (no sign).
  let mut p = ty_skip_ws(initStr, 0);
  let mut init: I32 = 0;
  while (p < stringLen(initStr) && ty_is_digit(stringCharCodeAt(initStr, p))) {
    init = init * 10 + (stringCharCodeAt(initStr, p) - 48);
    p = p + 1;
  }
  p = ty_skip_ws(lenStr, 0);
  let mut len: I32 = 0;
  while (p < stringLen(lenStr) && ty_is_digit(stringCharCodeAt(lenStr, p))) {
    len = len * 10 + (stringCharCodeAt(lenStr, p) - 48);
    p = p + 1;
  }
  ParsedTyArray(true, elem, init, len)
}

fn ty_is_slice(t: String) : Bool => {
  let i = ty_skip_ws(t, 0);
  ty_starts_with(t, i, "*[")
}

fn ty_slice_inner(t: String) : String => {
  // assumes ty_is_slice
  let i = ty_skip_ws(t, 0);
  let mut k = i + 2;
  let mut end = stringLen(t);
  while (end > 0 && type_is_ws(stringCharCodeAt(t, end - 1))) { end = end - 1; }
  // ends with ']'
  stringSlice(t, k, end - 1)
}

fn ty_apply_subst(typeParams, subst, t: String) : String => {
  let tt = normalize_ty_ann(t);
  if (ty_is_type_var(typeParams, tt)) {
    let b = subst_lookup(subst, tt);
    if (b == "") { yield tt; }
    yield normalize_ty_ann(b);
  }

  let arr = ty_parse_array(tt);
  if (arr.ok) {
    let inner = ty_apply_subst(typeParams, subst, arr.elem);
    yield "[" + inner + ";" + ("" + arr.init) + ";" + ("" + arr.len) + "]";
  }

  if (ty_is_slice(tt)) {
    let inner = ty_apply_subst(typeParams, subst, ty_slice_inner(tt));
    yield "*[" + inner + "]";
  }

  let app = ty_parse_app(tt);
  if (app.ok) {
    let mut out = stringSlice(app.callee, ty_skip_ws(app.callee, 0), stringLen(app.callee));
    out = out + "<";
    let mut i = 0;
    while (i < vec_len(app.args)) {
      if (i > 0) { out = out + ", "; }
      out = out + ty_apply_subst(typeParams, subst, vec_get(app.args, i));
      i = i + 1;
    }
    out = out + ">";
    yield out;
  }

  tt
}

fn type_is_unknown(t: String) : Bool => t == ty_unknown() || t == ""

fn type_is_int_like(t: String) : Bool => {
  let tt = normalize_ty_ann(t);
  if (tt == ty_int_lit()) { yield true; }
  if (tt == ty_i8()) { yield true; }
  if (tt == ty_i16()) { yield true; }
  if (tt == ty_i32()) { yield true; }
  if (tt == ty_i64()) { yield true; }
  if (tt == ty_u8()) { yield true; }
  if (tt == ty_u16()) { yield true; }
  if (tt == ty_u32()) { yield true; }
  if (tt == ty_u64()) { yield true; }
  if (tt == ty_char()) { yield true; }
  false
}

fn type_is_concrete_int(t: String) : Bool => {
  // Like type_is_int_like, but excludes literals (IntLit) and Char.
  let tt = normalize_ty_ann(t);
  if (tt == ty_i8()) { yield true; }
  if (tt == ty_i16()) { yield true; }
  if (tt == ty_i32()) { yield true; }
  if (tt == ty_i64()) { yield true; }
  if (tt == ty_u8()) { yield true; }
  if (tt == ty_u16()) { yield true; }
  if (tt == ty_u32()) { yield true; }
  if (tt == ty_u64()) { yield true; }
  false
}

fn type_is_float_like(t: String) : Bool => {
  let tt = normalize_ty_ann(t);
  if (tt == ty_float_lit()) { yield true; }
  if (tt == ty_f32()) { yield true; }
  if (tt == ty_f64()) { yield true; }
  false
}

fn type_is_concrete_float(t: String) : Bool => {
  let tt = normalize_ty_ann(t);
  if (tt == ty_f32()) { yield true; }
  if (tt == ty_f64()) { yield true; }
  false
}

fn should_enforce_expected_type(structs, expected: String) : Bool => {
  let e = normalize_ty_ann(expected);
  if (e == ty_bool()) { yield true; }
  if (e == ty_i8()) { yield true; }
  if (e == ty_i16()) { yield true; }
  if (e == ty_i32()) { yield true; }
  if (e == ty_i64()) { yield true; }
  if (e == ty_f32()) { yield true; }
  if (e == ty_f64()) { yield true; }
  if (e == ty_u8()) { yield true; }
  if (e == ty_u16()) { yield true; }
  if (e == ty_u32()) { yield true; }
  if (e == ty_u64()) { yield true; }
  if (e == ty_char()) { yield true; }
  if (e == ty_string()) { yield true; }
  if (e == ty_void()) { yield true; }
  if (has_struct_def(structs, e)) { yield true; }
  false
}

fn type_compatible(structs, expected: String, actual: String) : Bool => {
  if (expected == "") { yield true; }

  // Phase 4: only enforce for primitives and known structs.
  // This avoids false negatives on union aliases (e.g. `TypeRef`), generics,
  // and other not-yet-modeled types.
  if (!should_enforce_expected_type(structs, expected)) { yield true; }

  if (type_is_unknown(actual)) { yield true; }

  // Integer/char literals are context-typed in the language.
  // Model that by allowing `IntLit` to flow into int-like expected types.
  if (normalize_ty_ann(actual) == ty_int_lit() && type_is_int_like(expected)) {
    yield true;
  }

  // Float literals are also context-typed.
  if (normalize_ty_ann(actual) == ty_float_lit() && type_is_float_like(expected)) {
    yield true;
  }

  normalize_ty_ann(expected) == normalize_ty_ann(actual)
}

fn require_type_compatible(src: String, pos: I32, ctx: String, structs, expected: String, actual: String) : Void => {
  if (!type_compatible(structs, expected, actual)) {
    panic_at(src, pos, ctx + ": expected " + normalize_ty_ann(expected) + ", got " + normalize_ty_ann(actual));
  }
}

fn path_dotted(parts) : String => {
  let mut out = "";
  let mut i = 0;
  while (i < vec_len(parts)) {
    if (i > 0) { out = out + "."; }
    out = out + vec_get(parts, i);
    i = i + 1;
  }
  out
}

fn struct_name_of_expr(src: String, nameExpr) : String => {
  if (nameExpr.tag == "EIdent") { yield nameExpr.name; }
  if (nameExpr.tag == "EPath") { yield path_dotted(nameExpr.parts); }
  panic_at(src, span_start(nameExpr.span), "struct literal name must be ident or path")
}

fn find_struct_def(structs, name: String) : StructDef => {
  let mut i = 0;
  while (i < vec_len(structs)) {
    let s = vec_get(structs, i);
    if (s.name == name) { yield s; }
    i = i + 1;
  }
  // Return dummy; caller generally uses this only after a check.
  mk_struct_def(name, vec_new(), vec_new())
}

fn has_struct_def(structs, name: String) : Bool => {
  let mut i = 0;
  while (i < vec_len(structs)) {
    if (vec_get(structs, i).name == name) { yield true; }
    i = i + 1;
  }
  false
}

fn struct_field_index(s: StructDef, field: String) : I32 => {
  let mut i = 0;
  while (i < vec_len(s.fields)) {
    if (vec_get(s.fields, i) == field) { yield i; }
    i = i + 1;
  }
  -1
}

fn get_struct_field_type(src: String, pos: I32, structs, structName: String, field: String) : String => {
  if (!has_struct_def(structs, structName)) {
    panic_at(src, pos, "unknown struct: " + structName);
  }
  let s = find_struct_def(structs, structName);
  let idx = struct_field_index(s, field);
  if (idx == -1) {
    panic_at(src, pos, "unknown field " + field + " on struct " + structName);
  }
  if (idx < vec_len(s.fieldTyAnns)) {
    let t = vec_get(s.fieldTyAnns, idx);
    if (t != "") { yield normalize_ty_ann(t); }
  }
  ty_unknown()
}

fn find_fn_sig(fns, name: String) : FnSig => {
  let mut i = 0;
  while (i < vec_len(fns)) {
    let s = vec_get(fns, i);
    if (s.name == name) { yield s; }
    i = i + 1;
  }
  mk_fn_sig(name, vec_new(), vec_new(), vec_new(), "")
}

fn has_fn_sig(fns, name: String) : Bool => {
  let mut i = 0;
  while (i < vec_len(fns)) {
    if (vec_get(fns, i).name == name) { yield true; }
    i = i + 1;
  }
  false
}

fn find_union_def(unions, name: String) : UnionDef => {
  let mut i = 0;
  while (i < vec_len(unions)) {
    let u = vec_get(unions, i);
    if (u.name == name) { yield u; }
    i = i + 1;
  }
  mk_union_def(name, vec_new(), vec_new())
}

fn has_union_def(unions, name: String) : Bool => {
  let mut i = 0;
  while (i < vec_len(unions)) {
    if (vec_get(unions, i).name == name) { yield true; }
    i = i + 1;
  }
  false
}

fn union_has_variant(u: UnionDef, variantName: String) : Bool => {
  let vs = u.variants;
  let mut i = 0;
  while (i < vec_len(vs)) {
    if (vec_get(vs, i).name == variantName) { yield true; }
    i = i + 1;
  }
  false
}

fn find_union_by_variant(unions, variantName: String) : UnionDef => {
  let mut i = 0;
  while (i < vec_len(unions)) {
    let u = vec_get(unions, i);
    if (union_has_variant(u, variantName)) { yield u; }
    i = i + 1;
  }
  mk_union_def("", vec_new(), vec_new())
}

fn union_variant_index(u: UnionDef, variantName: String) : I32 => {
  let vs = u.variants;
  let mut i = 0;
  while (i < vec_len(vs)) {
    if (vec_get(vs, i).name == variantName) { yield i; }
    i = i + 1;
  }
  -1
}

fn union_variant_has_payload(u: UnionDef, variantName: String) : Bool => {
  let idx = union_variant_index(u, variantName);
  if (idx == -1) { yield false; }
  vec_get(u.variants, idx).hasPayload
}

fn union_variant_payload_ty_anns(u: UnionDef, variantName: String) => {
  let idx = union_variant_index(u, variantName);
  if (idx == -1) { yield vec_new(); }
  vec_get(u.variants, idx).payloadTyAnns
}

fn scopes_contains(scopes, depth: I32, name: String) : Bool => {
  let mut si = 0;
  while (si < depth) {
    let scope = vec_get(scopes, si);
    let mut ni = 0;
    while (ni < vec_len(scope)) {
      let b = vec_get(scope, ni);
      if (b.name == name) { yield true; }
      ni = ni + 1;
    }
    si = si + 1;
  }
  false
}

fn scopes_enter(scopes, depth: I32) : I32 => {
  let s = vec_new();
  if (depth < vec_len(scopes)) { vec_set(scopes, depth, s); }
  else { vec_push(scopes, s); }
  depth + 1
}

fn declare_name(src: String, pos: I32, scopes, depth: I32, name: String, isMut: Bool, tyTag: String) : Void => {
  if (scopes_contains(scopes, depth, name)) {
    panic_at(src, pos, "shadowing not allowed: " + name);
  }
  let cur = vec_get(scopes, depth - 1);
  vec_push(cur, mk_binding(name, isMut, tyTag));
}

fn scope_contains(scope, name: String) : Bool => {
  let mut i = 0;
  while (i < vec_len(scope)) {
    let b = vec_get(scope, i);
    if (b.name == name) { yield true; }
    i = i + 1;
  }
  false
}

fn declare_local_name(src: String, pos: I32, scopes, depth: I32, name: String, isMut: Bool, tyTag: String) : Void => {
  // Declare in the current scope only (no outer-scope shadowing check).
  let cur = vec_get(scopes, depth - 1);
  if (scope_contains(cur, name)) {
    panic_at(src, pos, "duplicate name: " + name);
  }
  vec_push(cur, mk_binding(name, isMut, tyTag));
}

fn lookup_binding(src: String, pos: I32, scopes, depth: I32, name: String) : Binding => {
  let mut si = 0;
  while (si < depth) {
    let scope = vec_get(scopes, si);
    let mut bi = 0;
    while (bi < vec_len(scope)) {
      let b = vec_get(scope, bi);
      if (b.name == name) { yield b; }
      bi = bi + 1;
    }
    si = si + 1;
  }
  panic_at(src, pos, "unknown name: " + name);
  mk_binding(name, false, ty_unknown())
}

fn update_binding_ty(src: String, pos: I32, scopes, depth: I32, name: String, newTyTag: String) : Void => {
  let mut si = 0;
  while (si < depth) {
    let scope = vec_get(scopes, si);
    let mut bi = 0;
    while (bi < vec_len(scope)) {
      let b = vec_get(scope, bi);
      if (b.name == name) {
        vec_set(scope, bi, mk_binding(b.name, b.isMut, newTyTag));
        yield;
      }
      bi = bi + 1;
    }
    si = si + 1;
  }
  panic_at(src, pos, "unknown name: " + name);
}

fn infer_lookup_ty(scopes, depth: I32, name: String) : String => {
  // Best-effort lookup for type inference.
  // Do NOT panic here: inference may run at an outer depth (e.g. inferring an
  // `if` expression) while inspecting nested block tails, where block-local
  // bindings are not visible at the caller's depth.
  let mut si = 0;
  while (si < depth) {
    let scope = vec_get(scopes, si);
    let mut bi = 0;
    while (bi < vec_len(scope)) {
      let b = vec_get(scope, bi);
      if (b.name == name) { yield b.tyTag; }
      bi = bi + 1;
    }
    si = si + 1;
  }
  ty_unknown()
}

fn require_name(src: String, pos: I32, scopes, depth: I32, name: String) : Void => {
  // The current bootstrap subset still parses `true`/`false` as identifiers.
  // Treat them as built-in literals so the analyzer doesn't reject valid code.
  if (name == "true") { yield; }
  if (name == "false") { yield; }

  // The bootstrap parser doesn't have dedicated tokens/stmts for these yet,
  // but they are valid JS statements and are currently emitted via EIdent.
  if (name == "continue") { yield; }
  if (name == "break") { yield; }

  // Normal lookup (panics on missing).
  lookup_binding(src, pos, scopes, depth, name);
}

fn infer_expr_type(src: String, structs, fns, scopes, depth: I32, e) : String => {
  if (e.tag == "EBool") { yield ty_bool(); }
  if (e.tag == "EInt") { yield ty_int_lit(); }
  if (e.tag == "EFloat") {
    // If the float literal has a suffix (F32 or F64), use that; otherwise FloatLit (context-typed).
    if (e.suffix == "F32") { yield ty_f32(); }
    if (e.suffix == "F64") { yield ty_f64(); }
    yield ty_float_lit();
  }
  if (e.tag == "EString") { yield ty_string(); }
  if (e.tag == "EIdent") {
    // The bootstrap subset still sometimes parses these as identifiers.
    if (e.name == "true") { yield ty_bool(); }
    if (e.name == "false") { yield ty_bool(); }
    yield infer_lookup_ty(scopes, depth, e.name);
  }

  if (e.tag == "ELambda") {
    yield ty_fn_type(e.typeParams, e.paramTyAnns, e.retTyAnn);
  }

  if (e.tag == "EStructLit") {
    yield struct_name_of_expr(src, e.nameExpr);
  }

  if (e.tag == "EUnary") {
    // Only obvious: !Bool => Bool
    if (e.op.tag == "OpNot") {
      let t = infer_expr_type(src, structs, fns, scopes, depth, e.expr);
      if (t == ty_bool()) { yield ty_bool(); }
      yield ty_unknown();
    }
    if (e.op.tag == "OpNeg") {
      let t = infer_expr_type(src, structs, fns, scopes, depth, e.expr);
      if (t == ty_i32()) { yield ty_i32(); }
      if (t == ty_int_lit()) { yield ty_i32(); }
      if (t == ty_f32()) { yield ty_f32(); }
      if (t == ty_f64()) { yield ty_f64(); }
      if (t == ty_float_lit()) { yield ty_f64(); }
      yield ty_unknown();
    }
  }

  if (e.tag == "EBinary") {
    if (e.op.tag == "OpAnd") { yield ty_bool(); }
    if (e.op.tag == "OpOr") { yield ty_bool(); }
    if (e.op.tag == "OpEq") { yield ty_bool(); }
    if (e.op.tag == "OpNe") { yield ty_bool(); }
    if (e.op.tag == "OpLt") { yield ty_bool(); }
    if (e.op.tag == "OpLe") { yield ty_bool(); }
    if (e.op.tag == "OpGt") { yield ty_bool(); }
    if (e.op.tag == "OpGe") { yield ty_bool(); }
    if (e.op.tag == "OpAdd") {
      // In the bootstrap subset, `+` is used both for integer addition and
      // string concatenation (e.g. while emitting JS source strings).
      let lt = infer_expr_type(src, structs, fns, scopes, depth, e.left);
      let rt = infer_expr_type(src, structs, fns, scopes, depth, e.right);
      if (lt == ty_string() || rt == ty_string()) { yield ty_string(); }

      if (type_is_float_like(lt) && type_is_float_like(rt)) {
        let nlt = normalize_ty_ann(lt);
        let nrt = normalize_ty_ann(rt);
        if (type_is_concrete_float(nlt) && nlt == nrt) { yield nlt; }
        if (type_is_concrete_float(nlt) && nrt == ty_float_lit()) { yield nlt; }
        if (type_is_concrete_float(nrt) && nlt == ty_float_lit()) { yield nrt; }
        yield ty_f64();
      }

      if (type_is_int_like(lt) && type_is_int_like(rt)) {
        // Char arithmetic yields I32.
        if (normalize_ty_ann(lt) == ty_char() || normalize_ty_ann(rt) == ty_char()) { yield ty_i32(); }
        // Preserve a concrete int width when both sides are that same width.
        let nlt = normalize_ty_ann(lt);
        let nrt = normalize_ty_ann(rt);
        if (type_is_concrete_int(nlt) && nlt == nrt) { yield nlt; }
        // Otherwise treat as I32 for now.
        yield ty_i32();
      }
      yield ty_unknown();
    }
    if (e.op.tag == "OpSub" || e.op.tag == "OpMul" || e.op.tag == "OpDiv") {
      let lt = infer_expr_type(src, structs, fns, scopes, depth, e.left);
      let rt = infer_expr_type(src, structs, fns, scopes, depth, e.right);

      if (type_is_float_like(lt) && type_is_float_like(rt)) {
        let nlt = normalize_ty_ann(lt);
        let nrt = normalize_ty_ann(rt);
        if (type_is_concrete_float(nlt) && nlt == nrt) { yield nlt; }
        if (type_is_concrete_float(nlt) && nrt == ty_float_lit()) { yield nlt; }
        if (type_is_concrete_float(nrt) && nlt == ty_float_lit()) { yield nrt; }
        yield ty_f64();
      }

      if (type_is_int_like(lt) && type_is_int_like(rt)) {
        // Char arithmetic yields I32.
        if (normalize_ty_ann(lt) == ty_char() || normalize_ty_ann(rt) == ty_char()) { yield ty_i32(); }
        // Preserve a concrete int width when both sides are that same width.
        let nlt = normalize_ty_ann(lt);
        let nrt = normalize_ty_ann(rt);
        if (type_is_concrete_int(nlt) && nlt == nrt) { yield nlt; }
        yield ty_i32();
      }
      yield ty_unknown();
    }
  }

  if (e.tag == "EField") {
    let bt = infer_expr_type(src, structs, fns, scopes, depth, e.base);
    if (!type_is_unknown(bt) && has_struct_def(structs, bt)) {
      yield get_struct_field_type(src, span_start(e.span), structs, bt, e.field);
    }
    yield ty_unknown();
  }

  if (e.tag == "ECall") {
    // `class fn Name(...) => { ... }` returns an object of locals/params.
    // Model this as a synthetic struct `__This__Name` so field access and
    // method-field calls can be type-checked.
    if (e.callee.tag == "EIdent") {
      let thisName = this_struct_name(e.callee.name);
      if (has_struct_def(structs, thisName)) { yield thisName; }
    }

    if (e.callee.tag == "EIdent" && has_fn_sig(fns, e.callee.name)) {
      let sig = find_fn_sig(fns, e.callee.name);
      if (sig.retTyAnn != "") {
        if (vec_len(sig.typeParams) > 0) {
          // Apply generic substitution (from explicit type args or inferred from args).
          let subst = vec_new();

          if (vec_len(e.typeArgs) > 0) {
            if (!(vec_len(e.typeArgs) == vec_len(sig.typeParams))) {
              panic_at(src, span_start(e.span), "wrong number of type args in call to " + e.callee.name);
            }
            let mut ti = 0;
            while (ti < vec_len(sig.typeParams)) {
              subst_bind(subst, vec_get(sig.typeParams, ti), normalize_ty_ann(vec_get(e.typeArgs, ti)));
              ti = ti + 1;
            }
          } else {
            // Infer only the simple/common case used by Phase 4 tests: param type is exactly a type var.
            let mut ai = 0;
            while (ai < vec_len(e.args) && ai < vec_len(sig.paramTyAnns)) {
              let expected = vec_get(sig.paramTyAnns, ai);
              let actual = infer_expr_type(src, structs, fns, scopes, depth, vec_get(e.args, ai));
              if (expected != "" && ty_is_type_var(sig.typeParams, normalize_ty_ann(expected))) {
                subst_bind(subst, normalize_ty_ann(expected), normalize_ty_ann(actual));
              }
              ai = ai + 1;
            }
          }

          yield ty_apply_subst(sig.typeParams, subst, sig.retTyAnn);
        }
        yield normalize_ty_ann(sig.retTyAnn);
      }
    }
    if (e.callee.tag == "ELambda") {
      if (e.callee.retTyAnn != "") {
        if (vec_len(e.callee.typeParams) > 0) {
          // Apply generic substitution using explicit type args (preferred) or simple inference.
          let subst = vec_new();
          if (vec_len(e.typeArgs) > 0) {
            if (!(vec_len(e.typeArgs) == vec_len(e.callee.typeParams))) {
              panic_at(src, span_start(e.span), "wrong number of type args in lambda call");
            }
            let mut ti = 0;
            while (ti < vec_len(e.callee.typeParams)) {
              subst_bind(subst, vec_get(e.callee.typeParams, ti), normalize_ty_ann(vec_get(e.typeArgs, ti)));
              ti = ti + 1;
            }
          } else {
            // Infer only when expected param type is exactly a type var.
            let mut ai = 0;
            while (ai < vec_len(e.args) && ai < vec_len(e.callee.paramTyAnns)) {
              let expected = vec_get(e.callee.paramTyAnns, ai);
              let actual = infer_expr_type(src, structs, fns, scopes, depth, vec_get(e.args, ai));
              if (expected != "" && ty_is_type_var(e.callee.typeParams, normalize_ty_ann(expected))) {
                subst_bind(subst, normalize_ty_ann(expected), normalize_ty_ann(actual));
              }
              ai = ai + 1;
            }
          }
          yield ty_apply_subst(e.callee.typeParams, subst, e.callee.retTyAnn);
        }
        yield normalize_ty_ann(e.callee.retTyAnn);
      }
    }

    // Calling through a function-typed value (e.g. `let f = (x:I32):I32=>...; f(1)`)
    // is allowed; infer the return type from the compact `Fn(...)->Ret` tag.
    let ct = infer_expr_type(src, structs, fns, scopes, depth, e.callee);
    if (ty_is_fn_type(ct)) {
      let ret0 = normalize_ty_ann(ty_fn_ret(ct));
      let tps = ty_fn_type_params(ct);
      if (vec_len(tps) > 0) {
        let subst = vec_new();
        if (vec_len(e.typeArgs) > 0) {
          if (!(vec_len(e.typeArgs) == vec_len(tps))) {
            panic_at(src, span_start(e.span), "wrong number of type args in call");
          }
          let mut ti = 0;
          while (ti < vec_len(tps)) {
            subst_bind(subst, vec_get(tps, ti), normalize_ty_ann(vec_get(e.typeArgs, ti)));
            ti = ti + 1;
          }
        } else {
          // Inference: bind T from actual arg types when expected is exactly a type var.
          let paramTys = ty_fn_param_tys(ct);
          let mut ai = 0;
          while (ai < vec_len(e.args) && ai < vec_len(paramTys)) {
            let expected = vec_get(paramTys, ai);
            let actual = infer_expr_type(src, structs, fns, scopes, depth, vec_get(e.args, ai));
            if (expected != "" && ty_is_type_var(tps, normalize_ty_ann(expected))) {
              subst_bind(subst, normalize_ty_ann(expected), normalize_ty_ann(actual));
            }
            ai = ai + 1;
          }
        }
        yield ty_apply_subst(tps, subst, ret0);
      }
      yield ret0;
    }
    yield ty_unknown();
  }

  if (e.tag == "EIf") {
    let t1 = infer_expr_type(src, structs, fns, scopes, depth, e.thenExpr);
    let t2 = infer_expr_type(src, structs, fns, scopes, depth, e.elseExpr);
    if (!type_is_unknown(t1) && normalize_ty_ann(t1) == normalize_ty_ann(t2)) {
      yield normalize_ty_ann(t1);
    }
    yield ty_unknown();
  }

  if (e.tag == "EBlock") {
    yield infer_expr_type(src, structs, fns, scopes, depth, e.tail);
  }

  // Everything else: unknown for now.
  ty_unknown()
}

fn check_cond_is_bool(src: String, structs, fns, scopes, depth: I32, cond) : Void => {
  let t = infer_expr_type(src, structs, fns, scopes, depth, cond);
  if (t == ty_i32() || t == ty_u32() || t == ty_char() || t == ty_int_lit()) { panic_at(src, span_start(cond.span), "condition must be Bool (got I32)"); }
  if (t == ty_f32() || t == ty_f64() || t == ty_float_lit()) { panic_at(src, span_start(cond.span), "condition must be Bool (got F64)"); }
  if (t == ty_string()) { panic_at(src, span_start(cond.span), "condition must be Bool (got String)"); }
}

fn check_binary_operand_types(src: String, structs, fns, scopes, depth: I32, e) : Void => {
  // Minimal operand validation to catch obviously-wrong code while keeping
  // the bootstrap analyzer incremental.
  if (e.tag != "EBinary") { yield; }

  let lt = infer_expr_type(src, structs, fns, scopes, depth, e.left);
  let rt = infer_expr_type(src, structs, fns, scopes, depth, e.right);

  // If either side is Unknown, do not enforce (avoid false positives).
  if (type_is_unknown(lt) || type_is_unknown(rt)) { yield; }

  // Arithmetic operators: require int-like operands, except `+` allows String.
  if (e.op.tag == "OpAdd") {
    if (lt == ty_string() || rt == ty_string()) { yield; }
    if (!((type_is_int_like(lt) && type_is_int_like(rt)) || (type_is_float_like(lt) && type_is_float_like(rt)))) {
      panic_at(src, span_start(e.span), "invalid operands to '+': expected numbers or strings");
    }
    yield;
  }

  if (e.op.tag == "OpSub" || e.op.tag == "OpMul" || e.op.tag == "OpDiv") {
    if (!((type_is_int_like(lt) && type_is_int_like(rt)) || (type_is_float_like(lt) && type_is_float_like(rt)))) {
      panic_at(src, span_start(e.span), "invalid operands to arithmetic operator");
    }
    yield;
  }

  // Comparison operators: require both operands to be numeric (int or float), not strings.
  if (e.op.tag == "OpLt" || e.op.tag == "OpLe" || e.op.tag == "OpGt" || e.op.tag == "OpGe") {
    if (!((type_is_int_like(lt) && type_is_int_like(rt)) || (type_is_float_like(lt) && type_is_float_like(rt)))) {
      panic_at(src, span_start(e.span), "invalid operands to comparison operator: expected numbers");
    }
    yield;
  }
}

fn check_struct_lit_types(src: String, structs, fns, scopes, depth: I32, e) : Void => {
  let structName = struct_name_of_expr(src, e.nameExpr);
  if (!has_struct_def(structs, structName)) {
    panic_at(src, span_start(e.span), "unknown struct: " + structName);
  }
  let sd = find_struct_def(structs, structName);
  if (!(vec_len(sd.fields) == vec_len(e.values))) {
    panic_at(src, span_start(e.span), "wrong number of values in struct literal for " + structName);
  }

  // If we have field type annotations, validate positional values against them.
  let mut i = 0;
  while (i < vec_len(e.values) && i < vec_len(sd.fieldTyAnns)) {
    let expected = vec_get(sd.fieldTyAnns, i);
    if (expected != "") {
      let actual = infer_expr_type(src, structs, fns, scopes, depth, vec_get(e.values, i));
      require_type_compatible(src, span_start(e.span), "struct " + structName + " field " + vec_get(sd.fields, i), structs, expected, actual);
    }
    i = i + 1;
  }
}

fn check_call_types(src: String, structs, fns, scopes, depth: I32, e) : Void => {
  if (e.callee.tag == "ELambda") {
    if (!(vec_len(e.args) == vec_len(e.callee.params))) {
      panic_at(src, span_start(e.span), "wrong number of args in lambda call");
    }

    let subst = vec_new();
    if (vec_len(e.callee.typeParams) > 0) {
      if (vec_len(e.typeArgs) > 0) {
        if (!(vec_len(e.typeArgs) == vec_len(e.callee.typeParams))) {
          panic_at(src, span_start(e.span), "wrong number of type args in lambda call");
        }
        let mut ti = 0;
        while (ti < vec_len(e.callee.typeParams)) {
          subst_bind(subst, vec_get(e.callee.typeParams, ti), normalize_ty_ann(vec_get(e.typeArgs, ti)));
          ti = ti + 1;
        }
      } else {
        // Inference: bind T from actual arg types when expected is exactly a type var.
        let mut ai = 0;
        while (ai < vec_len(e.args) && ai < vec_len(e.callee.paramTyAnns)) {
          let expected = vec_get(e.callee.paramTyAnns, ai);
          if (expected != "" && ty_is_type_var(e.callee.typeParams, normalize_ty_ann(expected))) {
            let actual = infer_expr_type(src, structs, fns, scopes, depth, vec_get(e.args, ai));
            subst_bind(subst, normalize_ty_ann(expected), normalize_ty_ann(actual));
          }
          ai = ai + 1;
        }
      }
    } else {
      if (vec_len(e.typeArgs) > 0) {
        panic_at(src, span_start(e.span), "cannot supply type args to non-generic lambda");
      }
    }

    let mut i = 0;
    while (i < vec_len(e.args) && i < vec_len(e.callee.paramTyAnns)) {
      let expected = vec_get(e.callee.paramTyAnns, i);
      if (expected != "") {
        let expected1 = if (vec_len(e.callee.typeParams) > 0) ty_apply_subst(e.callee.typeParams, subst, expected) else normalize_ty_ann(expected);
        let actual = infer_expr_type(src, structs, fns, scopes, depth, vec_get(e.args, i));
        require_type_compatible(src, span_start(e.span), "lambda arg " + ("" + (i + 1)), structs, expected1, actual);
      }
      i = i + 1;
    }
    yield;
  }

  // Calling through a function-typed value (incl. method-field values).
  let ct = infer_expr_type(src, structs, fns, scopes, depth, e.callee);
  if (ty_is_fn_type(ct)) {
    let paramTys = ty_fn_param_tys(ct);
    if (!(vec_len(e.args) == vec_len(paramTys))) {
      panic_at(src, span_start(e.span), "wrong number of args in call");
    }

    let tps = ty_fn_type_params(ct);
    let subst = vec_new();
    if (vec_len(tps) > 0) {
      if (vec_len(e.typeArgs) > 0) {
        if (!(vec_len(e.typeArgs) == vec_len(tps))) {
          panic_at(src, span_start(e.span), "wrong number of type args in call");
        }
        let mut ti = 0;
        while (ti < vec_len(tps)) {
          subst_bind(subst, vec_get(tps, ti), normalize_ty_ann(vec_get(e.typeArgs, ti)));
          ti = ti + 1;
        }
      } else {
        // Inference: bind T from actual arg types when expected is exactly a type var.
        let mut ai = 0;
        while (ai < vec_len(e.args) && ai < vec_len(paramTys)) {
          let expected = vec_get(paramTys, ai);
          if (expected != "" && ty_is_type_var(tps, normalize_ty_ann(expected))) {
            let actual = infer_expr_type(src, structs, fns, scopes, depth, vec_get(e.args, ai));
            subst_bind(subst, normalize_ty_ann(expected), normalize_ty_ann(actual));
          }
          ai = ai + 1;
        }
      }
    } else {
      if (vec_len(e.typeArgs) > 0) {
        panic_at(src, span_start(e.span), "cannot supply type args to non-generic function");
      }
    }

    let mut i = 0;
    while (i < vec_len(e.args) && i < vec_len(paramTys)) {
      let expected0 = vec_get(paramTys, i);
      if (!(type_is_unknown(expected0))) {
        let expected = if (vec_len(tps) > 0) ty_apply_subst(tps, subst, expected0) else normalize_ty_ann(expected0);
        let actual = infer_expr_type(src, structs, fns, scopes, depth, vec_get(e.args, i));
        require_type_compatible(src, span_start(e.span), "arg " + ("" + (i + 1)), structs, expected, actual);
      }
      i = i + 1;
    }
    yield;
  }

  if (e.callee.tag != "EIdent") { yield; }
  let name = e.callee.name;
  if (!has_fn_sig(fns, name)) { yield; }
  let sig = find_fn_sig(fns, name);

  if (!(vec_len(e.args) == vec_len(sig.params))) {
    panic_at(src, span_start(e.span), "wrong number of args in call to " + name);
  }

  // Type-check args when signature annotations are present.
  // For generic functions, substitute type vars using explicit type args or inference.
  let subst = vec_new();
  if (vec_len(sig.typeParams) > 0) {
    if (vec_len(e.typeArgs) > 0) {
      if (!(vec_len(e.typeArgs) == vec_len(sig.typeParams))) {
        panic_at(src, span_start(e.span), "wrong number of type args in call to " + name);
      }
      let mut ti = 0;
      while (ti < vec_len(sig.typeParams)) {
        subst_bind(subst, vec_get(sig.typeParams, ti), normalize_ty_ann(vec_get(e.typeArgs, ti)));
        ti = ti + 1;
      }
    } else {
      // Inference: bind T from actual arg types when expected is exactly a type var.
      let mut ai = 0;
      while (ai < vec_len(e.args) && ai < vec_len(sig.paramTyAnns)) {
        let expected = vec_get(sig.paramTyAnns, ai);
        if (expected != "" && ty_is_type_var(sig.typeParams, normalize_ty_ann(expected))) {
          let actual = infer_expr_type(src, structs, fns, scopes, depth, vec_get(e.args, ai));
          subst_bind(subst, normalize_ty_ann(expected), normalize_ty_ann(actual));
        }
        ai = ai + 1;
      }
    }
  } else {
    if (vec_len(e.typeArgs) > 0) {
      panic_at(src, span_start(e.span), "cannot supply type args to non-generic function: " + name);
    }
  }

  let mut i = 0;
  while (i < vec_len(e.args) && i < vec_len(sig.paramTyAnns)) {
    let expected0 = vec_get(sig.paramTyAnns, i);
    if (expected0 != "") {
      let expected = if (vec_len(sig.typeParams) > 0) ty_apply_subst(sig.typeParams, subst, expected0) else normalize_ty_ann(expected0);
      let actual = infer_expr_type(src, structs, fns, scopes, depth, vec_get(e.args, i));
      require_type_compatible(src, span_start(e.span), "arg " + ("" + (i + 1)) + " to " + name, structs, expected, actual);
    }
    i = i + 1;
  }
}

class fn ParsedTagEq(ok: Bool, name: String, variant: String) => {}

fn parse_tag_eq(cond) : ParsedTagEq => {
  // Recognize: <ident>.tag == "Variant" (either side).
  if (cond.tag != "EBinary") { yield ParsedTagEq(false, "", ""); }
  if (cond.op.tag != "OpEq") { yield ParsedTagEq(false, "", ""); }

  // Left: o.tag
  if (cond.left.tag == "EField" && cond.left.field == "tag" && cond.left.base.tag == "EIdent" && cond.right.tag == "EString") {
    yield ParsedTagEq(true, cond.left.base.name, cond.right.value);
  }
  // Right: o.tag
  if (cond.right.tag == "EField" && cond.right.field == "tag" && cond.right.base.tag == "EIdent" && cond.left.tag == "EString") {
    yield ParsedTagEq(true, cond.right.base.name, cond.left.value);
  }
  ParsedTagEq(false, "", "")
}

fn analyze_expr(src: String, structs, unions, fns, scopes, depth: I32, narrowed, e) : Void => {
  if (e.tag == "EIdent") {
    require_name(src, span_start(e.span), scopes, depth, e.name);
    yield;
  }

  if (e.tag == "ELambda") {
    // Lambdas introduce a new scope with typed parameters.
    let newDepth = scopes_enter(scopes, depth);
    let mut pi = 0;
    while (pi < vec_len(e.params)) {
      let mut pTy = ty_unknown();
      if (pi < vec_len(e.paramTyAnns)) {
        let ann = vec_get(e.paramTyAnns, pi);
        if (ann != "") { pTy = normalize_ty_ann(ann); }
      }
      declare_local_name(src, span_start(e.span), scopes, newDepth, vec_get(e.params, pi), false, pTy);
      pi = pi + 1;
    }

    analyze_expr(src, structs, unions, fns, scopes, newDepth, narrowed, e.body);

    // Enforce declared return type against body expression.
    if (e.retTyAnn != "") {
      let expected = normalize_ty_ann(e.retTyAnn);
      let bodyTy = infer_expr_type(src, structs, fns, scopes, newDepth, e.body);
      require_type_compatible(src, span_start(e.span), "lambda return", structs, expected, bodyTy);
    }
    yield;
  }

  if (e.tag == "EStructLit") {
    // nameExpr is a struct name marker (ident/path), not a runtime value.
    let mut vi = 0;
    while (vi < vec_len(e.values)) {
      analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, vec_get(e.values, vi));
      vi = vi + 1;
    }
    check_struct_lit_types(src, structs, fns, scopes, depth, e);
    yield;
  }

  if (e.tag == "EUnary") {
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, e.expr);
    yield;
  }

  if (e.tag == "EBinary") {
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, e.left);
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, e.right);
    check_binary_operand_types(src, structs, fns, scopes, depth, e);
    yield;
  }

  if (e.tag == "ECall") {
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, e.callee);
    let mut ai = 0;
    while (ai < vec_len(e.args)) {
      analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, vec_get(e.args, ai));
      ai = ai + 1;
    }
    check_call_types(src, structs, fns, scopes, depth, e);
    yield;
  }

  if (e.tag == "EIf") {
    check_cond_is_bool(src, structs, fns, scopes, depth, e.cond);
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, e.cond);

    // Narrowing for unions: if (o.tag == "Some") { ... }
    let tagEq = parse_tag_eq(e.cond);
    if (tagEq.ok) {
      let narrowedThen = narrow_clone(narrowed);
      vec_push(narrowedThen, mk_narrowed_tag(tagEq.name, tagEq.variant));
      analyze_expr(src, structs, unions, fns, scopes, depth, narrowedThen, e.thenExpr);
      analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, e.elseExpr);
      yield;
    }

    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, e.thenExpr);
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, e.elseExpr);
    yield;
  }

  if (e.tag == "EBlock") {
    let newDepth = scopes_enter(scopes, depth);
    analyze_stmts(src, structs, unions, fns, scopes, newDepth, narrowed, e.body);
    analyze_expr(src, structs, unions, fns, scopes, newDepth, narrowed, e.tail);
    yield;
  }

  if (e.tag == "EVecLit") {
    let mut ii = 0;
    while (ii < vec_len(e.items)) {
      analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, vec_get(e.items, ii));
      ii = ii + 1;
    }
    yield;
  }

  if (e.tag == "ETupleLit") {
    let mut ii = 0;
    while (ii < vec_len(e.items)) {
      analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, vec_get(e.items, ii));
      ii = ii + 1;
    }
    yield;
  }

  if (e.tag == "EIndex") {
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, e.base);
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, e.index);

    // Array safety: enforce bounds + initialized prefix when index is a literal.
    if (e.base.tag == "EIdent") {
      let bt = infer_lookup_ty(scopes, depth, e.base.name);
      let arr = ty_parse_array(normalize_ty_ann(bt));
      if (arr.ok) {
        let idx = infer_int_const(e.index);
        if (idx >= 0) {
          if (idx >= arr.len) {
            panic_at(src, span_start(e.span), "array index out of bounds: " + ("" + idx));
          }
          if (!(idx < arr.init)) {
            panic_at(src, span_start(e.span), "array index uninitialized: " + ("" + idx));
          }
        }
      }
    }
    yield;
  }

  if (e.tag == "ETupleIndex") {
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, e.base);
    yield;
  }

  if (e.tag == "EField") {
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, e.base);

    // Union payload access (`.value`) must be gated by narrowing.
    if (e.field == "value" && e.base.tag == "EIdent") {
      let bt = infer_lookup_ty(scopes, depth, e.base.name);
      let app = ty_parse_app(normalize_ty_ann(bt));
      if (app.ok) {
        let unionName = stringSlice(app.callee, ty_skip_ws(app.callee, 0), stringLen(app.callee));
        if (has_union_def(unions, unionName)) {
          let u = find_union_def(unions, unionName);
          let v = narrow_lookup(narrowed, e.base.name);
          if (v == "") {
            panic_at(src, span_start(e.span), "union payload access requires narrowing (" + unionName + ".value)");
          }
          if (!union_variant_has_payload(u, v)) {
            panic_at(src, span_start(e.span), "union variant has no payload: " + v);
          }
        }
      }
    }

    // If base is a known struct type, validate field exists.
    let bt = infer_expr_type(src, structs, fns, scopes, depth, e.base);
    if (!type_is_unknown(bt)) {
      // Only validate for known structs (avoid false positives for unknown).
      if (has_struct_def(structs, bt)) {
        let _ft = get_struct_field_type(src, span_start(e.span), structs, bt, e.field);
      }
    }
    yield;
  }

  if (e.tag == "EMatch") {
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, e.scrut);
    let mut mi = 0;
    while (mi < vec_len(e.arms)) {
      let arm = vec_get(e.arms, mi);
      analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, arm.expr);
      mi = mi + 1;
    }
    yield;
  }

  // Literals, paths, undefined: nothing to do.
}

fn analyze_stmt(src: String, structs, unions, fns, scopes, depth: I32, narrowed, s) : Void => {
  if (s.tag == "SLet") {
    // Predeclare lambda lets so recursion/mutual recursion works.
    if (s.init.tag == "ELambda") {
      let initTy0 = infer_expr_type(src, structs, fns, scopes, depth, s.init);
      let bindTy = if (s.tyAnn != "") normalize_ty_ann(s.tyAnn) else initTy0;
      let cur = vec_get(scopes, depth - 1);
      if (!scope_contains(cur, s.name)) {
        declare_name(src, span_start(s.span), scopes, depth, s.name, s.isMut, bindTy);
      }

      analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, s.init);
      if (s.tyAnn != "") {
        require_type_compatible(src, span_start(s.span), "let " + s.name, structs, s.tyAnn, initTy0);
      }
      yield;
    }

    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, s.init);
    let initTy = infer_expr_type(src, structs, fns, scopes, depth, s.init);

    // Approach 1: generic functions are allowed, but an unspecialized generic
    // cannot be treated as a first-class value (no C function pointer exists).
    // Calls like `id(123)` / `obj.id(123)` are still allowed via generic inference.
    if (s.init.tag == "EIdent" && has_fn_sig(fns, s.init.name)) {
      let sig = find_fn_sig(fns, s.init.name);
      if (vec_len(sig.typeParams) > 0) {
        panic_at(src, span_start(s.init.span), "generic function requires type args when used as a value: " + s.init.name);
      }
    }
    if (ty_is_fn_type(initTy)) {
      let tps = ty_fn_type_params(initTy);
      if (vec_len(tps) > 0) {
        panic_at(src, span_start(s.init.span), "generic function value must be specialized before use");
      }
    }

    if (s.tyAnn != "") {
      require_type_compatible(src, span_start(s.span), "let " + s.name, structs, s.tyAnn, initTy);
      declare_name(src, span_start(s.span), scopes, depth, s.name, s.isMut, normalize_ty_ann(s.tyAnn));
      yield;
    }
    declare_name(src, span_start(s.span), scopes, depth, s.name, s.isMut, initTy);
    yield;
  }

  if (s.tag == "SAssign") {
    let b = lookup_binding(src, span_start(s.span), scopes, depth, s.name);
    if (!b.isMut) {
      panic_at(src, span_start(s.span), "cannot assign to immutable binding: " + s.name);
    }
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, s.value);
    yield;
  }

  if (s.tag == "SExpr") {
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, s.expr);
    yield;
  }

  if (s.tag == "SYield") {
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, s.expr);
    yield;
  }

  if (s.tag == "SWhile") {
    check_cond_is_bool(src, structs, fns, scopes, depth, s.cond);
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, s.cond);
    let newDepth = scopes_enter(scopes, depth);
    analyze_stmts(src, structs, unions, fns, scopes, newDepth, narrowed, s.body);
    yield;
  }

  if (s.tag == "SIf") {
    check_cond_is_bool(src, structs, fns, scopes, depth, s.cond);
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, s.cond);

    // Narrowing for unions in statement if: if (o.tag == "Some") { ... } else { ... }
    let tagEq = parse_tag_eq(s.cond);
    if (tagEq.ok) {
      let narrowedThen = narrow_clone(narrowed);
      vec_push(narrowedThen, mk_narrowed_tag(tagEq.name, tagEq.variant));

      let thenDepth = scopes_enter(scopes, depth);
      analyze_stmts(src, structs, unions, fns, scopes, thenDepth, narrowedThen, s.thenBody);

      if (s.hasElse) {
        let elseDepth = scopes_enter(scopes, depth);
        analyze_stmts(src, structs, unions, fns, scopes, elseDepth, narrowed, s.elseBody);
      }
      yield;
    }

    let thenDepth = scopes_enter(scopes, depth);
    analyze_stmts(src, structs, unions, fns, scopes, thenDepth, narrowed, s.thenBody);

    if (s.hasElse) {
      let elseDepth = scopes_enter(scopes, depth);
      analyze_stmts(src, structs, unions, fns, scopes, elseDepth, narrowed, s.elseBody);
    }

    yield;
  }

  if (s.tag == "SIndexAssign") {
    if (s.base.tag == "EIdent") {
      let b = lookup_binding(src, span_start(s.span), scopes, depth, s.base.name);
      if (!b.isMut) {
        panic_at(src, span_start(s.span), "cannot assign through immutable binding: " + s.base.name);
      }
    }

    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, s.base);
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, s.index);
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, s.value);

    // Array initialization tracking / bounds checks on literal index.
    if (s.base.tag == "EIdent") {
      let bt = infer_lookup_ty(scopes, depth, s.base.name);
      let arr = ty_parse_array(normalize_ty_ann(bt));
      if (arr.ok) {
        let idx = infer_int_const(s.index);
        if (idx >= 0) {
          if (idx >= arr.len) {
            panic_at(src, span_start(s.span), "array index out of bounds: " + ("" + idx));
          }
          if (idx > arr.init) {
            panic_at(src, span_start(s.span), "cannot skip array initialization at index " + ("" + idx));
          }

          // Enforce element type when known.
          let elemExpected = normalize_ty_ann(arr.elem);
          let actual = infer_expr_type(src, structs, fns, scopes, depth, s.value);
          require_type_compatible(src, span_start(s.span), "array element", structs, elemExpected, actual);

          if (idx == arr.init) {
            update_binding_ty(src, span_start(s.span), scopes, depth, s.base.name, "[" + elemExpected + ";" + ("" + (arr.init + 1)) + ";" + ("" + arr.len) + "]");
          }
        }
      }
    }
    yield;
  }

  if (s.tag == "SFieldAssign") {
    if (s.base.tag == "EIdent") {
      let b = lookup_binding(src, span_start(s.span), scopes, depth, s.base.name);
      if (!b.isMut) {
        panic_at(src, span_start(s.span), "cannot assign through immutable binding: " + s.base.name);
      }
    }
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, s.base);
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, s.value);
    yield;
  }
}

fn analyze_stmts(src: String, structs, unions, fns, scopes, depth: I32, narrowed, stmts) : Void => {
  // Predeclare all `let name = <lambda>` in this block so local functions can
  // be recursive and mutually recursive.
  let cur = vec_get(scopes, depth - 1);
  let mut pi = 0;
  while (pi < vec_len(stmts)) {
    let st = vec_get(stmts, pi);
    if (st.tag == "SLet" && st.init.tag == "ELambda") {
      if (!scope_contains(cur, st.name)) {
        let initTy0 = infer_expr_type(src, structs, fns, scopes, depth, st.init);
        let bindTy = if (st.tyAnn != "") normalize_ty_ann(st.tyAnn) else initTy0;
        declare_name(src, span_start(st.span), scopes, depth, st.name, st.isMut, bindTy);
      }
    }
    pi = pi + 1;
  }

  let mut i = 0;
  while (i < vec_len(stmts)) {
    analyze_stmt(src, structs, unions, fns, scopes, depth, narrowed, vec_get(stmts, i));
    i = i + 1;
  }
}

fn analyze_fn_decl(src: String, structs, unions, fns, outerScopes, outerDepth: I32, d) : Void => {
  let depth = scopes_enter(outerScopes, outerDepth);

  let mut pi = 0;
  while (pi < vec_len(d.params)) {
    let mut pTy = ty_unknown();
    if (pi < vec_len(d.paramTyAnns)) {
      let ann = vec_get(d.paramTyAnns, pi);
      if (ann != "") { pTy = normalize_ty_ann(ann); }
    }
    declare_local_name(src, span_start(d.span), outerScopes, depth, vec_get(d.params, pi), false, pTy);
    pi = pi + 1;
  }

  let narrowed = vec_new();
  analyze_stmts(src, structs, unions, fns, outerScopes, depth, narrowed, d.body);
  analyze_expr(src, structs, unions, fns, outerScopes, depth, narrowed, d.tail);

  // Enforce declared return type (if present) against tail and explicit yields.
  if (d.retTyAnn != "") {
    let expected = normalize_ty_ann(d.retTyAnn);

    // tail
    let tailTy = infer_expr_type(src, structs, fns, outerScopes, depth, d.tail);
    require_type_compatible(src, span_start(d.span), "function " + d.name + " return", structs, expected, tailTy);

    // yields
    let mut si = 0;
    while (si < vec_len(d.body)) {
      let st = vec_get(d.body, si);
      if (st.tag == "SYield") {
        let yTy = if (st.expr.tag == "EUndefined") ty_void() else infer_expr_type(src, structs, fns, outerScopes, depth, st.expr);
        require_type_compatible(src, span_start(st.span), "function " + d.name + " yield", structs, expected, yTy);
      }
      si = si + 1;
    }
  }
}

fn analyze_module(src: String, d) : Void => {
  // Modules create a separate namespace; do not treat module members as nested
  // declarations of the outer scope.
  let scopes = vec_new();
  vec_push(scopes, vec_new());
  let depth: I32 = 1;

  // NOTE: module-local typing env not implemented yet; treat as separate namespace.
  let structs = vec_new();
  let unions = vec_new();
  let fns = vec_new();
  analyze_decls(src, structs, unions, fns, scopes, depth, d.decls);
}

fn predeclare_decl(src: String, structs, unions, fns, scopes, depth: I32, d) : Void => {
  if (d.tag == "DExternFrom") {
    let mut ni = 0;
    while (ni < vec_len(d.names)) {
      declare_name(src, span_start(d.span), scopes, depth, vec_get(d.names, ni), false, ty_unknown());
      ni = ni + 1;
    }
    yield;
  }

  if (d.tag == "DImport") {
    let mut ni = 0;
    while (ni < vec_len(d.names)) {
      declare_name(src, span_start(d.span), scopes, depth, vec_get(d.names, ni), false, ty_unknown());
      ni = ni + 1;
    }
    yield;
  }

  if (d.tag == "DTypeUnion") {
    // Union variants are value constructors.
    let mut vi = 0;
    let infos = vec_new();
    while (vi < vec_len(d.variants)) {
      let v = vec_get(d.variants, vi);
      declare_name(src, span_start(v.span), scopes, depth, v.name, false, ty_unknown());
      vec_push(infos, mk_union_variant_info(v.name, v.hasPayload, v.payloadTyAnns));
      vi = vi + 1;
    }
    vec_push(unions, mk_union_def(d.name, d.typeParams, infos));
    yield;
  }

  if (d.tag == "DFn") {
    declare_name(src, span_start(d.span), scopes, depth, d.name, false, ty_unknown());

    // Register signature for later call/return checking.
    let mut paramTyAnns = d.paramTyAnns;
    if (vec_len(paramTyAnns) == 0) {
      // Legacy AST nodes don't carry param annotations; still record arity.
      paramTyAnns = vec_new();
      let mut i = 0;
      while (i < vec_len(d.params)) { vec_push(paramTyAnns, ""); i = i + 1; }
    }
    vec_push(fns, mk_fn_sig(d.name, d.typeParams, d.params, paramTyAnns, d.retTyAnn));
    yield;
  }

  if (d.tag == "DClassFn") {
    declare_name(src, span_start(d.span), scopes, depth, d.name, false, ty_unknown());

    // Synthesize a struct that represents the returned object shape.
    let thisName = this_struct_name(d.name);
    if (!has_struct_def(structs, thisName)) {
      let fields = vec_new();
      let fieldTyAnns = vec_new();

      // Params are fields.
      let mut pi = 0;
      while (pi < vec_len(d.params)) {
        vec_push(fields, vec_get(d.params, pi));
        let mut t = "";
        if (pi < vec_len(d.paramTyAnns)) { t = vec_get(d.paramTyAnns, pi); }
        vec_push(fieldTyAnns, if (t == "") "" else normalize_ty_ann(t));
        pi = pi + 1;
      }

      // Lets in the body become fields. Record only obvious types:
      // - explicit annotation
      // - lambda signature (for methods)
      let mut si = 0;
      while (si < vec_len(d.body)) {
        let st = vec_get(d.body, si);
        if (st.tag == "SLet") {
          vec_push(fields, st.name);
          if (st.tyAnn != "") {
            vec_push(fieldTyAnns, normalize_ty_ann(st.tyAnn));
          } else {
            if (st.init.tag == "ELambda") {
              vec_push(fieldTyAnns, ty_fn_type(st.init.typeParams, st.init.paramTyAnns, st.init.retTyAnn));
            } else {
              vec_push(fieldTyAnns, "");
            }
          }
        }
        si = si + 1;
      }

      vec_push(structs, mk_struct_def(thisName, fields, fieldTyAnns));
    }

    let mut paramTyAnns = d.paramTyAnns;
    if (vec_len(paramTyAnns) == 0) {
      paramTyAnns = vec_new();
      let mut i = 0;
      while (i < vec_len(d.params)) { vec_push(paramTyAnns, ""); i = i + 1; }
    }
    vec_push(fns, mk_fn_sig(d.name, d.typeParams, d.params, paramTyAnns, d.retTyAnn));
    yield;
  }

  if (d.tag == "DStruct") {
    vec_push(structs, mk_struct_def(d.name, d.fields, d.fieldTyAnns));
    yield;
  }

  if (d.tag == "DModule") {
    declare_name(src, span_start(d.span), scopes, depth, d.name, false, ty_unknown());
    yield;
  }
}

fn analyze_decl_body(src: String, structs, unions, fns, scopes, depth: I32, d) : Void => {
  if (d.tag == "DLet") {
    let narrowed = vec_new();
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, d.init);
    let initTy = infer_expr_type(src, structs, fns, scopes, depth, d.init);

    // Same rule for top-level/module lets.
    if (d.init.tag == "EIdent" && has_fn_sig(fns, d.init.name)) {
      let sig = find_fn_sig(fns, d.init.name);
      if (vec_len(sig.typeParams) > 0) {
        panic_at(src, span_start(d.init.span), "generic function requires type args when used as a value: " + d.init.name);
      }
    }
    if (ty_is_fn_type(initTy)) {
      let tps = ty_fn_type_params(initTy);
      if (vec_len(tps) > 0) {
        panic_at(src, span_start(d.init.span), "generic function value must be specialized before use");
      }
    }

    if (d.tyAnn != "") {
      require_type_compatible(src, span_start(d.span), "let " + d.name, structs, d.tyAnn, initTy);
      declare_name(src, span_start(d.span), scopes, depth, d.name, d.isMut, normalize_ty_ann(d.tyAnn));
      yield;
    }
    declare_name(src, span_start(d.span), scopes, depth, d.name, d.isMut, initTy);
    yield;
  }

  if (d.tag == "DFn") {
    analyze_fn_decl(src, structs, unions, fns, scopes, depth, d);
    yield;
  }

  if (d.tag == "DClassFn") {
    analyze_fn_decl(src, structs, unions, fns, scopes, depth, d);
    yield;
  }

  if (d.tag == "DModule") {
    analyze_module(src, d);
    yield;
  }
}

fn analyze_decls(src: String, structs, unions, fns, scopes, depth: I32, decls) : Void => {
  // Pass 1: predeclare names so later decl bodies can reference earlier/later decls.
  let mut i = 0;
  while (i < vec_len(decls)) {
    predeclare_decl(src, structs, unions, fns, scopes, depth, vec_get(decls, i));
    i = i + 1;
  }

  // Pass 2: analyze bodies in order (lets are sequential).
  i = 0;
  while (i < vec_len(decls)) {
    analyze_decl_body(src, structs, unions, fns, scopes, depth, vec_get(decls, i));
    i = i + 1;
  }
}

fn analyze_program(src: String, decls) : Void => {
  let scopes = vec_new();
  vec_push(scopes, vec_new());
  let depth: I32 = 1;
  let structs = vec_new();
  let unions = vec_new();
  let fns = vec_new();
  analyze_decls(src, structs, unions, fns, scopes, depth, decls);
}
