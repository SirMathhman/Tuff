// Phase 4 (initial): Analyzer pass.
//
// For now, this module focuses on enforcing the language's no-shadowing rule
// (a name may not be redeclared in an enclosing scope).

extern from rt::stdlib use { stringLen, stringCharCodeAt, stringSlice };
extern from rt::vec use { vec_new, vec_len, vec_push, vec_get, vec_set };

from util::diagnostics use { error_at, warn_at };
from ast use { span_start };

from analyzer::deprecation use { deprecation_reason_before };

from analyzer::typestrings use {
  type_is_ws,
  ty_is_digit,
  ty_skip_ws,
  ty_starts_with,
  ty_unknown,
  ty_int_lit,
  ty_float_lit,
  ty_bool,
  ty_i32,
  ty_i8,
  ty_i16,
  ty_i64,
  ty_f32,
  ty_f64,
  ty_u32,
  ty_u8,
  ty_u16,
  ty_u64,
  ty_char,
  ty_string,
  ty_void,
  ty_never,
  ty_fn_type,
  ty_is_fn_type,
  ty_fn_type_params,
  ty_fn_ret,
  ty_fn_param_tys,
  normalize_ty_ann,
  vec_contains_str,
  ty_is_type_var,
  ty_parse_app,
  ty_parse_array,
  ty_is_slice,
  ty_slice_inner,
  type_is_unknown,
  type_is_int_like,
  type_is_concrete_int,
  type_is_float_like,
  type_is_concrete_float
};

from analyzer::fluff use {
  fluff_set_options,
  fluff_set_complexity_options,
  fluff_set_file_size_options,
  fluff_check_file_size,
  fluff_warn_unused_locals_in_scope,
  fluff_warn_unused_params_in_scope,
  fluff_check_fn_complexity,
  fluff_check_lambda_complexity
};

from analyzer::defs use {
  mk_union_variant_info,
  mk_struct_def,
  mk_fn_sig_def,
  mk_union_def,
  mk_binding,
  mk_subst,
  mk_narrowed_tag
};

from analyzer::narrowing use { narrow_lookup, narrow_clone };
from analyzer::consts use { infer_int_const };
from analyzer::subst use { subst_lookup, subst_bind, ty_apply_subst };

from analyzer::infer_basic use { infer_expr_type };
from analyzer::infer_narrowing use {
  infer_expr_type_with_narrowing,
  parse_tag_narrowing,
  validate_union_variant_for_binding
};
from analyzer::analyze_expr_stmt use { analyze_expr, analyze_stmt, analyze_stmts };
from analyzer::analyze_decls use { analyze_fn_decl, analyze_class_fn_decl };

from analyzer::env use {
  this_struct_name,
  path_dotted,
  struct_name_of_expr,
  find_struct_def,
  has_struct_def,
  get_struct_field_type,
  find_fn_sig,
  has_fn_sig,
  find_union_def,
  has_union_def,
  union_has_variant,
  find_union_by_variant,
  union_variant_has_payload,
  union_variant_payload_ty_anns
};

from analyzer::scope use {
  scopes_contains,
  scopes_enter,
  declare_name,
  declare_name_deprecated,
  scope_contains,
  declare_local_name,
  declare_local_name_deprecated,
  lookup_binding,
  update_binding_ty,
  mark_binding_read,
  mark_binding_written,
  infer_lookup_ty,
  require_name
};

from analyzer::typecheck use { require_type_compatible, require_all_param_types };
from analyzer::checks use {
  check_cond_is_bool,
  check_binary_operand_types,
  check_struct_lit_types,
  check_call_types
};


// ------------------------------------------------------------
// Phase 4a/4b: minimal type environment
//
// Data structures and constructors live in analyzer::defs.
// ------------------------------------------------------------

// Fluff (linting) is intentionally opt-in by default to keep compiler/test
// output readable.
out fn set_fluff_options(unusedLocalsSeverity: I32, unusedParamsSeverity: I32) : Void =>
  fluff_set_options(unusedLocalsSeverity, unusedParamsSeverity)

out fn set_fluff_complexity_options(complexitySeverity: I32, threshold: I32) : Void =>
  fluff_set_complexity_options(complexitySeverity, threshold)

out fn set_fluff_file_size_options(severity: I32, threshold: I32) : Void =>
  fluff_set_file_size_options(severity, threshold)

out fn check_file_size(src: String) : Void =>
  fluff_check_file_size(src)

out fn mk_fn_sig(name: String, deprecatedReason: String, typeParams: Vec<String>, params: Vec<String>, paramTyAnns: Vec<String>, retTyAnn: String) =>
  mk_fn_sig_def(name, deprecatedReason, typeParams, params, paramTyAnns, retTyAnn)

fn analyze_module(src: String, d: DModule) : Void => {
  // Modules create a separate namespace; do not treat module members as nested
  // declarations of the outer scope.
  let scopes = vec_new();
  vec_push(scopes, vec_new());
  let depth: I32 = 1;

  // NOTE: module-local typing env not implemented yet; treat as separate namespace.
  let structs = vec_new();
  let unions = vec_new();
  let fns = vec_new();
  analyze_decls(src, structs, unions, fns, scopes, depth, d.decls);
}

fn predeclare_decl(src: String, structs: Vec<StructDef>, unions: Vec<UnionDef>, fns: Vec<FnSig>, scopes: Vec<Vec<Binding>>, depth: I32, d: Decl) : Void => {
  if (d.tag == "DExternFrom") {
    let mut ni = 0;
    while (ni < vec_len(d.names)) {
      declare_name(src, span_start(d.span), scopes, depth, vec_get(d.names, ni), false, ty_unknown());
      ni = ni + 1;
    }
    yield;
  }

  if (d.tag == "DExternType") {
    // Types are compile-time only for now.
    // Future: register in a type environment for validating type annotations.
    yield;
  }

  if (d.tag == "DImport") {
    let mut ni = 0;
    while (ni < vec_len(d.names)) {
      let name = vec_get(d.names, ni);
      // If the imported binding is a function with a known signature, propagate
      // its deprecation marker and warn at import time.
      if (has_fn_sig(fns, name)) {
        let sig = find_fn_sig(fns, name);
        if (sig.deprecatedReason != "") {
          warn_at(src, span_start(d.span), "importing deprecated symbol " + name + " - " + sig.deprecatedReason);
          declare_name_deprecated(src, span_start(d.span), scopes, depth, name, false, ty_unknown(), sig.deprecatedReason);
          ni = ni + 1;
          continue;
        }
      }
      declare_name(src, span_start(d.span), scopes, depth, name, false, ty_unknown());
      ni = ni + 1;
    }
    yield;
  }

  if (d.tag == "DTypeUnion") {
    let depReason = deprecation_reason_before(src, span_start(d.span));
    // Union variants are value constructors.
    let mut vi = 0;
    let infos = vec_new();
    while (vi < vec_len(d.variants)) {
      let v = vec_get(d.variants, vi);
      if (depReason != "") {
        declare_name_deprecated(src, span_start(v.span), scopes, depth, v.name, false, ty_unknown(), depReason);
      } else {
        declare_name(src, span_start(v.span), scopes, depth, v.name, false, ty_unknown());
      }
      vec_push(infos, mk_union_variant_info(v.name, v.hasPayload, v.payloadTyAnns));
      vi = vi + 1;
    }
    vec_push(unions, mk_union_def(d.name, d.typeParams, infos));
    yield;
  }

  if (d.tag == "DFn") {
    let depReason = deprecation_reason_before(src, span_start(d.span));
    if (depReason != "") {
      declare_name_deprecated(src, span_start(d.span), scopes, depth, d.name, false, ty_unknown(), depReason);
    } else {
      declare_name(src, span_start(d.span), scopes, depth, d.name, false, ty_unknown());
    }

    // Register signature for later call/return checking.
    let mut paramTyAnns = d.paramTyAnns;
    if (vec_len(paramTyAnns) == 0) {
      // Legacy AST nodes don't carry param annotations; still record arity.
      paramTyAnns = vec_new();
      let mut i = 0;
      while (i < vec_len(d.params)) { vec_push(paramTyAnns, ""); i = i + 1; }
    }

    require_all_param_types(src, span_start(d.span), "function " + d.name, d.params, paramTyAnns);
    vec_push(fns, mk_fn_sig(d.name, depReason, d.typeParams, d.params, paramTyAnns, d.retTyAnn));
    yield;
  }

  if (d.tag == "DClassFn") {
    let depReason = deprecation_reason_before(src, span_start(d.span));
    if (depReason != "") {
      declare_name_deprecated(src, span_start(d.span), scopes, depth, d.name, false, ty_unknown(), depReason);
    } else {
      declare_name(src, span_start(d.span), scopes, depth, d.name, false, ty_unknown());
    }

    // Synthesize a struct that represents the returned object shape.
    let thisName = this_struct_name(d.name);
    if (!has_struct_def(structs, thisName)) {
      let fields = vec_new();
      let fieldTyAnns = vec_new();

      // Params are fields.
      let mut pi = 0;
      while (pi < vec_len(d.params)) {
        vec_push(fields, vec_get(d.params, pi));
        let mut t = "";
        if (pi < vec_len(d.paramTyAnns)) { t = vec_get(d.paramTyAnns, pi); }
        vec_push(fieldTyAnns, if (t == "") "" else normalize_ty_ann(t));
        pi = pi + 1;
      }

      // Lets in the body become fields. Record only obvious types:
      // - explicit annotation
      // - lambda signature (for methods)
      let mut si = 0;
      while (si < vec_len(d.body)) {
        let st = vec_get(d.body, si);
        if (st.tag == "SLet") {
          vec_push(fields, st.name);
          if (st.tyAnn != "") {
            vec_push(fieldTyAnns, normalize_ty_ann(st.tyAnn));
          } else {
            if (st.init.tag == "ELambda") {
              vec_push(fieldTyAnns, ty_fn_type(st.init.typeParams, st.init.paramTyAnns, st.init.retTyAnn));
            } else {
              vec_push(fieldTyAnns, "");
            }
          }
        }
        si = si + 1;
      }

      vec_push(structs, mk_struct_def(thisName, fields, fieldTyAnns));
    }

    let mut paramTyAnns = d.paramTyAnns;
    if (vec_len(paramTyAnns) == 0) {
      paramTyAnns = vec_new();
      let mut i = 0;
      while (i < vec_len(d.params)) { vec_push(paramTyAnns, ""); i = i + 1; }
    }

    require_all_param_types(src, span_start(d.span), "class fn " + d.name, d.params, paramTyAnns);
    vec_push(fns, mk_fn_sig(d.name, depReason, d.typeParams, d.params, paramTyAnns, d.retTyAnn));
    yield;
  }

  if (d.tag == "DStruct") {
    vec_push(structs, mk_struct_def(d.name, d.fields, d.fieldTyAnns));
    yield;
  }

  if (d.tag == "DModule") {
    let depReason = deprecation_reason_before(src, span_start(d.span));
    if (depReason != "") {
      declare_name_deprecated(src, span_start(d.span), scopes, depth, d.name, false, ty_unknown(), depReason);
    } else {
      declare_name(src, span_start(d.span), scopes, depth, d.name, false, ty_unknown());
    }
    yield;
  }
}

fn analyze_decl_body(src: String, structs: Vec<StructDef>, unions: Vec<UnionDef>, fns: Vec<FnSig>, scopes: Vec<Vec<Binding>>, depth: I32, d: Decl) : Void => {
  if (d.tag == "DLet") {
    let narrowed = vec_new();
    analyze_expr(src, structs, unions, fns, scopes, depth, narrowed, d.init);
    let initTy = infer_expr_type(src, structs, fns, scopes, depth, d.init);

    // Same rule for top-level/module lets.
    if (d.init.tag == "EIdent" && has_fn_sig(fns, d.init.name)) {
      let sig = find_fn_sig(fns, d.init.name);
      if (vec_len(sig.typeParams) > 0) {
        error_at(src, span_start(d.init.span), "generic function requires type args when used as a value: " + d.init.name);
      }
    }
    if (ty_is_fn_type(initTy)) {
      let tps = ty_fn_type_params(initTy);
      if (vec_len(tps) > 0) {
        error_at(src, span_start(d.init.span), "generic function value must be specialized before use");
      }
    }

    let depReason = deprecation_reason_before(src, span_start(d.span));
    if (d.tyAnn != "") {
      require_type_compatible(src, span_start(d.span), "let " + d.name, structs, d.tyAnn, initTy);
      if (depReason != "") {
        declare_name_deprecated(src, span_start(d.span), scopes, depth, d.name, d.isMut, normalize_ty_ann(d.tyAnn), depReason);
      } else {
        declare_name(src, span_start(d.span), scopes, depth, d.name, d.isMut, normalize_ty_ann(d.tyAnn));
      }
      yield;
    }
    if (depReason != "") {
      declare_name_deprecated(src, span_start(d.span), scopes, depth, d.name, d.isMut, initTy, depReason);
    } else {
      declare_name(src, span_start(d.span), scopes, depth, d.name, d.isMut, initTy);
    }
    yield;
  }

  if (d.tag == "DFn") {
    analyze_fn_decl(src, structs, unions, fns, scopes, depth, d);
    yield;
  }

  if (d.tag == "DClassFn") {
    analyze_class_fn_decl(src, structs, unions, fns, scopes, depth, d);
    yield;
  }

  if (d.tag == "DModule") {
    analyze_module(src, d);
    yield;
  }
}

fn analyze_decls(src: String, structs: Vec<StructDef>, unions: Vec<UnionDef>, fns: Vec<FnSig>, scopes: Vec<Vec<Binding>>, depth: I32, decls: Vec<Decl>) : Void => {
  // Pass 1: predeclare names so later decl bodies can reference earlier/later decls.
  let mut i = 0;
  while (i < vec_len(decls)) {
    predeclare_decl(src, structs, unions, fns, scopes, depth, vec_get(decls, i));
    i = i + 1;
  }

  // Pass 2: analyze bodies in order (lets are sequential).
  i = 0;
  while (i < vec_len(decls)) {
    analyze_decl_body(src, structs, unions, fns, scopes, depth, vec_get(decls, i));
    i = i + 1;
  }
}

out fn analyze_program(src: String, decls: Vec<Decl>) : Void => {
  let scopes = vec_new();
  vec_push(scopes, vec_new());
  let depth: I32 = 1;
  let structs = vec_new();
  let unions = vec_new();
  let fns = vec_new();
  analyze_decls(src, structs, unions, fns, scopes, depth, decls);
}

out fn analyze_program_with_fns(src: String, decls: Vec<Decl>, importedFns: Vec<FnSig>) : Void => {
  // Like analyze_program, but pre-seeds the function environment with
  // signatures imported from other modules. This enables cross-file call
  // validation (arity + type checks) during analysis.
  let scopes = vec_new();
  vec_push(scopes, vec_new());
  let depth: I32 = 1;
  let structs = vec_new();
  let unions = vec_new();
  let fns = vec_new();

  // Seed imported function signatures first so local decls can reference them
  // and duplicate name checks fire appropriately.
  let mut i = 0;
  while (i < vec_len(importedFns)) {
    vec_push(fns, vec_get(importedFns, i));
    i = i + 1;
  }

  analyze_decls(src, structs, unions, fns, scopes, depth, decls);
}
