extern from rt::vec use { vec_new, vec_len };
type Span = SpanVal<(I32, I32)>;
type BinOp =
  OpAdd
  | OpSub
  | OpMul
  | OpDiv
  | OpEq
  | OpNe
  | OpLt
  | OpLe
  | OpGt
  | OpGe
  | OpAnd
  | OpOr;

type TypeRef =
  TyName
  | TyTuple
  | TyFn
  | TyApp;

struct TyName {
  span: Span,
  name: String
}
struct TyTuple {
  span: Span,
  items: Vec<TypeRef>
}
struct TyFn {
  span: Span,
  params: Vec<TypeRef>,
  result: TypeRef
}
struct TyApp {
  span: Span,
  callee: String,
  args: Vec<TypeRef>
}

type Expr =
  EUndefined
  | EInt
  | EFloat
  | EBool
  | EString
  | EPath
  | EIdent
  | ELambda
  | EStructLit
  | EUnary
  | EBinary
  | ECall
  | EIf
  | EBlock
  | EVecLit
  | ETupleLit
  | EIndex
  | ETupleIndex
  | EField
  | EMatch
  | EIsType;

struct EUndefined {
  span: Span
}
struct EInt {
  span: Span,
  value: I32
}
struct EFloat {
  span: Span,
  text: String,
  suffix: String
}
struct EBool {
  span: Span,
  value: Bool
}
struct EString {
  span: Span,
  value: String
}
struct EIdent {
  span: Span,
  name: String
}
struct ELambda {
  span: Span,
  typeParams: Vec<String>,
  params: Vec<String>,
  paramTyAnns: Vec<String>,
  retTyAnn: String,
  body: Expr
}
struct EStructLit {
  span: Span,
  nameExpr: Expr,
  values: Vec<Expr>
}
struct EPath {
  span: Span,
  parts: Vec<String>
}

type UnOp =
  OpNot
  | OpNeg;

struct EUnary {
  span: Span,
  op: UnOp,
  expr: Expr
}
struct EBinary {
  span: Span,
  op: BinOp,
  left: Expr,
  right: Expr
}
struct ECall {
  span: Span,
  callee: Expr,
  typeArgs: Vec<String>,
  args: Vec<Expr>
}
struct EIf {
  span: Span,
  cond: Expr,
  thenExpr: Expr,
  elseExpr: Expr
}
struct EBlock {
  span: Span,
  body: Vec<Stmt>,
  tail: Expr
}
struct EVecLit {
  span: Span,
  items: Vec<Expr>
}
struct ETupleLit {
  span: Span,
  items: Vec<Expr>
}
struct EIndex {
  span: Span,
  base: Expr,
  index: Expr
}
struct ETupleIndex {
  span: Span,
  base: Expr,
  index: I32
}
struct EField {
  span: Span,
  base: Expr,
  field: String
}

type MatchPat =
  MPWildcard
  | MPInt
  | MPBool
  | MPString
  | MPVariant;

struct MPWildcard {
  span: Span
}

struct MPInt {
  span: Span,
  value: I32
}

struct MPBool {
  span: Span,
  value: Bool
}

struct MPString {
  span: Span,
  value: String
}

// Union variant match pattern (bootstrap subset).
// Example: `match (o) { Some => ...; None => ... }`
struct MPVariant {
  span: Span,
  name: String
}

struct MatchArm {
  span: Span,
  pat: MatchPat,
  expr: Expr
}

struct EMatch {
  span: Span,
  scrut: Expr,
  arms: Vec<MatchArm>
}

struct EIsType {
  span: Span,
  expr: Expr,
  typeToCheck: String
}

type Stmt =
  SLet
  | SAssign
  | SExpr
  | SYield
  | SWhile
  | SIf
  | SIndexAssign
  | SFieldAssign;

struct SLet {
  span: Span,
  isMut: Bool,
  name: String,
  tyAnn: String,
  init: Expr
}

struct SAssign {
  span: Span,
  name: String,
  value: Expr
}

struct SExpr {
  span: Span,
  expr: Expr
}

struct SYield {
  span: Span,
  expr: Expr
}

struct SWhile {
  span: Span,
  cond: Expr,
  body: Vec<Stmt>
}

struct SIf {
  span: Span,
  cond: Expr,
  thenBody: Vec<Stmt>,
  hasElse: Bool,
  elseBody: Vec<Stmt>
}

struct SIndexAssign {
  span: Span,
  base: Expr,
  index: Expr,
  value: Expr
}

struct SFieldAssign {
  span: Span,
  base: Expr,
  fields: Vec<String>,
  value: Expr
}

type Decl =
  DExternFrom
  | DExternType
  | DLet
  | DFn
  | DClassFn
  | DStruct
  | DTypeUnion
  | DModule
  | DImport;

struct DExternFrom {
  span: Span,
  modulePath: String,
  names: Vec<String>
}
struct DExternType {
  span: Span,
  isOut: Bool,
  name: String,
  typeParams: Vec<String>
}

struct DLet {
  span: Span,
  isMut: Bool,
  name: String,
  tyAnn: String,
  init: Expr
}

struct DFn {
  span: Span,
  isOut: Bool,
  isClass: Bool,
  isExtern: Bool,
  name: String,
  typeParams: Vec<String>,
  params: Vec<String>,
  paramTyAnns: Vec<String>,
  retTyAnn: String,
  body: Vec<Stmt>,
  tail: Expr
}
// DClassFn kept for backward compatibility, but isClass on DFn should be preferred
struct DClassFn {
  span: Span,
  isOut: Bool,
  name: String,
  typeParams: Vec<String>,
  params: Vec<String>,
  paramTyAnns: Vec<String>,
  retTyAnn: String,
  body: Vec<Stmt>,
  tail: Expr
}

struct DStruct {
  span: Span,
  name: String,
  // Optional generic params: struct Name<T, U> { ... }
  typeParams: Vec<String>,
  fields: Vec<String>,
  // Optional field type annotations aligned with fields.
  // If absent, entries are empty strings.
  fieldTyAnns: Vec<String>
}

struct DTypeUnion {
  span: Span,
  name: String,
  // Optional generic params: type Name<T, ...> = ...;
  typeParams: Vec<String>,
  variants: Vec<TypeUnionVariant>
}

struct TypeUnionVariant {
  span: Span,
  name: String,
  // True when the union variant carries a payload.
  // In the bootstrap compiler, payloads lower to a single field: `.value`.
  hasPayload: Bool,
  // Optional payload type annotations (parsed from Variant<...>).
  // Phase 4 uses these for type checking and narrowing.
  payloadTyAnns: Vec<String>
}

struct DModule {
  span: Span,
  name: String,
  decls: Vec<Decl>
}

struct DImport {
  span: Span,
  modulePath: String,
  names: Vec<String>
}

// Helpers

out fn span(start: I32, end: I32) : Span => SpanVal((start, end))

out fn span_start(s: Span) : I32 => s.value.0
out fn span_end(s: Span) : I32 => s.value.1
out fn span_len(s: Span) : I32 => span_end(s) - span_start(s)

// Helper functions that return variant names using is operator
// These replace the old .tag field access pattern
out fn expr_kind(e: Expr) : String => {
  if (e is EUndefined) { yield "EUndefined"; }
  if (e is EInt) { yield "EInt"; }
  if (e is EFloat) { yield "EFloat"; }
  if (e is EBool) { yield "EBool"; }
  if (e is EString) { yield "EString"; }
  if (e is EPath) { yield "EPath"; }
  if (e is EIdent) { yield "EIdent"; }
  if (e is ELambda) { yield "ELambda"; }
  if (e is EStructLit) { yield "EStructLit"; }
  if (e is EUnary) { yield "EUnary"; }
  if (e is EBinary) { yield "EBinary"; }
  if (e is ECall) { yield "ECall"; }
  if (e is EIf) { yield "EIf"; }
  if (e is EBlock) { yield "EBlock"; }
  if (e is EVecLit) { yield "EVecLit"; }
  if (e is ETupleLit) { yield "ETupleLit"; }
  if (e is EIndex) { yield "EIndex"; }
  if (e is ETupleIndex) { yield "ETupleIndex"; }
  if (e is EField) { yield "EField"; }
  if (e is EMatch) { yield "EMatch"; }
  if (e is EIsType) { yield "EIsType"; }
  "Unknown"
}

out fn type_span(t: TypeRef) : Span => t.span

out fn expr_span(e: Expr) : Span => e.span

out fn stmt_span(s: Stmt) : Span => s.span

out fn decl_span(d: Decl) : Span => d.span

// Constructors (cross-module safe)
out fn ty_name(span: Span, name: String) : TypeRef => TyName { span, name }
out fn ty_tuple(span: Span, items: Vec<TypeRef>) : TypeRef => TyTuple { span, items }
out fn ty_fn(span: Span, params: Vec<TypeRef>, result: TypeRef) : TypeRef => TyFn { span, params, result }
out fn ty_app(span: Span, callee: String, args: Vec<TypeRef>) : TypeRef => TyApp { span, callee, args }
out fn expr_undefined(span: Span) : Expr => EUndefined { span }
out fn expr_int(span: Span, value: I32) : Expr => EInt { span, value }
out fn expr_float(span: Span, text: String, suffix: String) : Expr => EFloat { span, text, suffix }
out fn expr_bool(span: Span, value: Bool) : Expr => EBool { span, value }
out fn expr_string(span: Span, value: String) : Expr => EString { span, value }
out fn expr_ident(span: Span, name: String) : Expr => EIdent { span, name }
out fn expr_path(span: Span, parts: Vec<String>) : Expr => EPath { span, parts }
out fn expr_lambda(span: Span, typeParams: Vec<String>, params: Vec<String>, paramTyAnns: Vec<String>, retTyAnn: String, body: Expr) : Expr =>
  ELambda { span, typeParams, params, paramTyAnns, retTyAnn, body }
out fn expr_struct_lit(span: Span, nameExpr: Expr, values: Vec<Expr>) : Expr => EStructLit { span, nameExpr, values }
out fn expr_unary(span: Span, op: UnOp, expr: Expr) : Expr => EUnary { span, op, expr }
out fn expr_binary(span: Span, op: BinOp, left: Expr, right: Expr) : Expr => EBinary { span, op, left, right }
out fn expr_call(span: Span, callee: Expr, args: Vec<Expr>) : Expr => ECall { span, callee, vec_new(), args }
out fn expr_call_typed(span: Span, callee: Expr, typeArgs: Vec<String>, args: Vec<Expr>) : Expr => ECall { span, callee, typeArgs, args }
out fn expr_if(span: Span, cond: Expr, thenExpr: Expr, elseExpr: Expr) : Expr => EIf { span, cond, thenExpr, elseExpr }
out fn expr_block(span: Span, body: Vec<Stmt>, tail: Expr) : Expr => EBlock { span, body, tail }
out fn expr_vec_lit(span: Span, items: Vec<Expr>) : Expr => EVecLit { span, items }
out fn expr_tuple_lit(span: Span, items: Vec<Expr>) : Expr => ETupleLit { span, items }
out fn expr_index(span: Span, base: Expr, index: Expr) : Expr => EIndex { span, base, index }
out fn expr_tuple_index(span: Span, base: Expr, index: I32) : Expr => ETupleIndex { span, base, index }
out fn expr_field(span: Span, base: Expr, field: String) : Expr => EField { span, base, field }
out fn expr_is_type(span: Span, expr: Expr, typeToCheck: String) : Expr => EIsType { span, expr, typeToCheck }

out fn pat_wildcard(span: Span) : MatchPat => MPWildcard { span }
out fn pat_int(span: Span, value: I32) : MatchPat => MPInt { span, value }
out fn pat_bool(span: Span, value: Bool) : MatchPat => MPBool { span, value }
out fn pat_string(span: Span, value: String) : MatchPat => MPString { span, value }
out fn pat_variant(span: Span, name: String) : MatchPat => MPVariant { span, name }
out fn mk_match_arm(span: Span, pat: MatchPat, expr: Expr) : MatchArm => MatchArm { span, pat, expr }
out fn expr_match(span: Span, scrut: Expr, arms: Vec<MatchArm>) : Expr => EMatch { span, scrut, arms }

out fn stmt_let(span: Span, isMut: Bool, name: String, init: Expr) : Stmt => SLet { span, isMut, name, "", init }
out fn stmt_let_typed(span: Span, isMut: Bool, name: String, tyAnn: String, init: Expr) : Stmt => SLet { span, isMut, name, tyAnn, init }
out fn stmt_assign(span: Span, name: String, value: Expr) : Stmt => SAssign { span, name, value }
out fn stmt_expr(span: Span, expr: Expr) : Stmt => SExpr { span, expr }
out fn stmt_yield(span: Span, expr: Expr) : Stmt => SYield { span, expr }
out fn stmt_while(span: Span, cond: Expr, body: Vec<Stmt>) : Stmt => SWhile { span, cond, body }
out fn stmt_if(span: Span, cond: Expr, thenBody: Vec<Stmt>, hasElse: Bool, elseBody: Vec<Stmt>) : Stmt => SIf { span, cond, thenBody, hasElse, elseBody }
out fn stmt_index_assign(span: Span, base: Expr, index: Expr, value: Expr) : Stmt => SIndexAssign { span, base, index, value }
out fn stmt_field_assign(span: Span, base: Expr, fields: Vec<String>, value: Expr) : Stmt => SFieldAssign { span, base, fields, value }

out fn decl_extern_from(span: Span, modulePath: String, names: Vec<String>) : Decl => DExternFrom { span, modulePath, names }
out fn decl_extern_type(span: Span, isOut: Bool, name: String, typeParams: Vec<String>) : Decl => DExternType { span, isOut, name, typeParams }
out fn decl_import(span: Span, modulePath: String, names: Vec<String>) : Decl => DImport { span, modulePath, names }
out fn decl_struct(span: Span, name: String, fields: Vec<String>) : Decl => DStruct { span, name, vec_new(), fields, vec_new() }
out fn decl_struct_typed(span: Span, name: String, typeParams: Vec<String>, fields: Vec<String>, fieldTyAnns: Vec<String>) : Decl =>
  DStruct { span, name, typeParams, fields, fieldTyAnns }
out fn type_union_variant(span: Span, name: String, hasPayload: Bool) : TypeUnionVariant => TypeUnionVariant { span, name, hasPayload, vec_new() }
out fn type_union_variant_typed(span: Span, name: String, payloadTyAnns: Vec<String>) : TypeUnionVariant =>
  TypeUnionVariant { span, name, vec_len(payloadTyAnns) > 0, payloadTyAnns }
out fn decl_type_union(span: Span, name: String, typeParams: Vec<String>, variants: Vec<TypeUnionVariant>) : Decl =>
  DTypeUnion { span, name, typeParams, variants }

// Legacy constructors for backward compatibility (isClass=false, isExtern=false)
out fn decl_fn(span: Span, isOut: Bool, name: String, params: Vec<String>, body: Vec<Stmt>, tail: Expr) : Decl =>
  DFn { span, isOut, false, false, name, vec_new(), params, vec_new(), "", body, tail }
out fn decl_fn_typed(span: Span, isOut: Bool, name: String, typeParams: Vec<String>, params: Vec<String>, paramTyAnns: Vec<String>, retTyAnn: String, body: Vec<Stmt>, tail: Expr) : Decl =>
  DFn { span, isOut, false, false, name, typeParams, params, paramTyAnns, retTyAnn, body, tail }

// New unified constructor with all three modifier flags (creates DFn)
out fn decl_fn_full(span: Span, isOut: Bool, isClass: Bool, isExtern: Bool, name: String, typeParams: Vec<String>, params: Vec<String>, paramTyAnns: Vec<String>, retTyAnn: String, body: Vec<Stmt>, tail: Expr) : Decl =>
  DFn { span, isOut, isClass, isExtern, name, typeParams, params, paramTyAnns, retTyAnn, body, tail }

// Legacy: class fn declarations use DClassFn for backward compatibility with existing `d is DClassFn` checks
out fn decl_class_fn(span: Span, isOut: Bool, name: String, params: Vec<String>, body: Vec<Stmt>, tail: Expr) : Decl =>
  DClassFn { span, isOut, name, vec_new(), params, vec_new(), "", body, tail }
out fn decl_class_fn_typed(span: Span, isOut: Bool, name: String, typeParams: Vec<String>, params: Vec<String>, paramTyAnns: Vec<String>, retTyAnn: String, body: Vec<Stmt>, tail: Expr) : Decl =>
  DClassFn { span, isOut, name, typeParams, params, paramTyAnns, retTyAnn, body, tail }

out fn decl_let(span: Span, isMut: Bool, name: String, init: Expr) : Decl => DLet { span, isMut, name, "", init }
out fn decl_let_typed(span: Span, isMut: Bool, name: String, tyAnn: String, init: Expr) : Decl => DLet { span, isMut, name, tyAnn, init }
out fn decl_module(span: Span, name: String, decls: Vec<Decl>) : Decl => DModule { span, name, decls }

// Operator constructors
out fn op_add() : BinOp => OpAdd
out fn op_sub() : BinOp => OpSub
out fn op_mul() : BinOp => OpMul
out fn op_div() : BinOp => OpDiv
out fn op_eq() : BinOp => OpEq
out fn op_ne() : BinOp => OpNe
out fn op_lt() : BinOp => OpLt
out fn op_le() : BinOp => OpLe
out fn op_gt() : BinOp => OpGt
out fn op_ge() : BinOp => OpGe
out fn op_and() : BinOp => OpAnd
out fn op_or() : BinOp => OpOr
out fn op_not() : UnOp => OpNot
out fn op_neg() : UnOp => OpNeg
