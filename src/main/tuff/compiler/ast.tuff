// Canonical (target-agnostic) AST definitions.
//
// Phase 1 goal: introduce shared node definitions + a couple of helpers,
// without changing the current compiler pipeline yet.
//
// NOTE: Keep this file dependency-light.
// The current selfhost compiler keeps struct field-order defs per-file,
// so other modules should NOT construct these structs with literals.
// Instead, use the constructor functions provided below (e.g. `expr_int`).

extern from rt::vec use { vec_new, vec_len };

// A source span as (startOffset, endOffset), half-open: [start, end)
// Stored as a tagged union so it can cross module boundaries reliably.
//
// Invariant (by convention): 0 <= start <= end
// (not enforced here; the analyzer will enforce it later).

type Span = SpanVal<(I32, I32)>;

// Binary operators (syntactic).

type BinOp =
  OpAdd
  | OpSub
  | OpMul
  | OpDiv
  | OpEq
  | OpNe
  | OpLt
  | OpLe
  | OpGt
  | OpGe
  | OpAnd
  | OpOr;

// Type references (syntactic).
// These are *not* resolved types; the analyzer will transform/annotate.

type TypeRef =
  TyName
  | TyTuple
  | TyFn
  | TyApp;

struct TyName {
  tag: String,
  span: Span,
  name: String
}

struct TyTuple {
  tag: String,
  span: Span,
  items: Vec<TypeRef>
}

struct TyFn {
  tag: String,
  span: Span,
  params: Vec<TypeRef>,
  result: TypeRef
}

struct TyApp {
  tag: String,
  span: Span,
  callee: String,
  args: Vec<TypeRef>
}

// Expressions.
// Convention: payload tuple always starts with Span.

type Expr =
  EUndefined
  | EInt
  | EFloat
  | EBool
  | EString
  | EPath
  | EIdent
  | ELambda
  | EStructLit
  | EUnary
  | EBinary
  | ECall
  | EIf
  | EBlock
  | EVecLit
  | ETupleLit
  | EIndex
  | ETupleIndex
  | EField
  | EMatch;

struct EUndefined {
  tag: String,
  span: Span
}

struct EInt {
  tag: String,
  span: Span,
  value: I32
}

// Float literal.
//
// Stored as source text to avoid requiring numeric parsing in the bootstrap
// compiler. Emitters can print this text directly as a JS number literal.
// suffix is "" (untyped), "F32", or "F64".
struct EFloat {
  tag: String,
  span: Span,
  text: String,
  suffix: String
}

struct EBool {
  tag: String,
  span: Span,
  value: Bool
}

struct EString {
  tag: String,
  span: Span,
  value: String
}

struct EIdent {
  tag: String,
  span: Span,
  name: String
}

// Lambda expression.
//
// Syntax (initial):
//   (a: I32, b: I32) : I32 => a + b
//   () : I32 => 10
//
// Note: Type annotations are kept as raw strings (Phase 4 analyzer uses
// string-based normalization/compatibility checks).
struct ELambda {
  tag: String,
  span: Span,
  // Optional generic params for function-valued expressions created via
  // local `fn name<T>(...) => ...;` desugaring.
  // Empty for normal lambda syntax.
  typeParams: Vec<String>,
  params: Vec<String>,
  paramTyAnns: Vec<String>,
  retTyAnn: String,
  body: Expr
}

// Struct literal. The parser keeps this as a dedicated node so the emitter
// doesn't need to recognize pseudo-builtins.
//
// Note: The bootstrap subset uses positional values (not named fields); the
// JS emitter consults `diagnostics::find_struct_fields` for field order.
struct EStructLit {
  tag: String,
  span: Span,
  nameExpr: Expr,
  values: Vec<Expr>
}

// Canonical module/namespace path, e.g. `Math::add`.
// Kept separate from `EField` so emitters can map namespaces appropriately.
struct EPath {
  tag: String,
  span: Span,
  parts: Vec<String>
}

// Unary operators.

type UnOp =
  OpNot
  | OpNeg;

struct EUnary {
  tag: String,
  span: Span,
  op: UnOp,
  expr: Expr
}

struct EBinary {
  tag: String,
  span: Span,
  op: BinOp,
  left: Expr,
  right: Expr
}

struct ECall {
  tag: String,
  span: Span,
  callee: Expr,
  // Generic call sugar: f<T>(...) stores type args here.
  // Empty means no explicit type args.
  typeArgs: Vec<String>,
  args: Vec<Expr>
}

struct EIf {
  tag: String,
  span: Span,
  cond: Expr,
  thenExpr: Expr,
  elseExpr: Expr
}

// Block expression: executes statements, returns tail expression.
struct EBlock {
  tag: String,
  span: Span,
  body: Vec<Stmt>,
  tail: Expr
}

struct EVecLit {
  tag: String,
  span: Span,
  items: Vec<Expr>
}

struct ETupleLit {
  tag: String,
  span: Span,
  items: Vec<Expr>
}

// Vector indexing (lowers to vec_get/vec_set in JS backend).
struct EIndex {
  tag: String,
  span: Span,
  base: Expr,
  index: Expr
}

// Tuple indexing (lowers to JS bracket indexing with a constant).
struct ETupleIndex {
  tag: String,
  span: Span,
  base: Expr,
  index: I32
}

struct EField {
  tag: String,
  span: Span,
  base: Expr,
  field: String
}

// Match expression (restricted patterns for the bootstrap subset).

type MatchPat =
  MPWildcard
  | MPInt
  | MPBool
  | MPString;

struct MPWildcard {
  tag: String,
  span: Span
}

struct MPInt {
  tag: String,
  span: Span,
  value: I32
}

struct MPBool {
  tag: String,
  span: Span,
  value: Bool
}

struct MPString {
  tag: String,
  span: Span,
  value: String
}

struct MatchArm {
  tag: String,
  span: Span,
  pat: MatchPat,
  expr: Expr
}

struct EMatch {
  tag: String,
  span: Span,
  scrut: Expr,
  arms: Vec<MatchArm>
}

// Statements.
// Convention: payload tuple always starts with Span.

type Stmt =
  SLet
  | SAssign
  | SExpr
  | SYield
  | SWhile
  | SIf
  | SIndexAssign
  | SFieldAssign;

struct SLet {
  tag: String,
  span: Span,
  isMut: Bool,
  name: String,
  // Optional type annotation (empty string means none).
  tyAnn: String,
  init: Expr
}

struct SAssign {
  tag: String,
  span: Span,
  name: String,
  value: Expr
}

struct SExpr {
  tag: String,
  span: Span,
  expr: Expr
}

struct SYield {
  tag: String,
  span: Span,
  expr: Expr
}

struct SWhile {
  tag: String,
  span: Span,
  cond: Expr,
  body: Vec<Stmt>
}

struct SIf {
  tag: String,
  span: Span,
  cond: Expr,
  thenBody: Vec<Stmt>,
  hasElse: Bool,
  elseBody: Vec<Stmt>
}

struct SIndexAssign {
  tag: String,
  span: Span,
  base: Expr,
  index: Expr,
  value: Expr
}

struct SFieldAssign {
  tag: String,
  span: Span,
  base: Expr,
  fields: Vec<String>,
  value: Expr
}

// Top-level declarations.
// Convention: payload tuple always starts with Span.

type Decl =
  DExternFrom
  | DLet
  | DFn
  | DClassFn
  | DStruct
  | DTypeUnion
  | DModule
  | DImport;

struct DExternFrom {
  tag: String,
  span: Span,
  modulePath: String,
  names: Vec<String>
}

struct DLet {
  tag: String,
  span: Span,
  isMut: Bool,
  name: String,
  // Optional type annotation (empty string means none).
  tyAnn: String,
  init: Expr
}

struct DFn {
  tag: String,
  span: Span,
  name: String,
  // Optional generic params: fn name<T, U>(...)
  typeParams: Vec<String>,
  params: Vec<String>,
  // Optional per-parameter type annotations aligned with params.
  // If absent/untyped, entries are empty strings.
  paramTyAnns: Vec<String>,
  // Optional return type annotation (empty string means none).
  retTyAnn: String,
  body: Vec<Stmt>,
  tail: Expr
}

// `class fn` lowering uses a function that returns an object of parameters.
struct DClassFn {
  tag: String,
  span: Span,
  name: String,
  // Optional generic params: class fn name<T, U>(...)
  typeParams: Vec<String>,
  params: Vec<String>,
  // Optional per-parameter type annotations aligned with params.
  // If absent/untyped, entries are empty strings.
  paramTyAnns: Vec<String>,
  // Optional return type annotation (empty string means none).
  retTyAnn: String,
  body: Vec<Stmt>,
  tail: Expr
}

struct DStruct {
  tag: String,
  span: Span,
  name: String,
  // Optional generic params: struct Name<T, U> { ... }
  typeParams: Vec<String>,
  fields: Vec<String>,
  // Optional field type annotations aligned with fields.
  // If absent, entries are empty strings.
  fieldTyAnns: Vec<String>
}

struct DTypeUnion {
  tag: String,
  span: Span,
  name: String,
  // Optional generic params: type Name<T, ...> = ...;
  typeParams: Vec<String>,
  variants: Vec<TypeUnionVariant>
}

struct TypeUnionVariant {
  tag: String,
  span: Span,
  name: String,
  // True when the union variant carries a payload.
  // In the bootstrap compiler, payloads lower to a single field: `.value`.
  hasPayload: Bool,
  // Optional payload type annotations (parsed from Variant<...>).
  // Phase 4 uses these for type checking and narrowing.
  payloadTyAnns: Vec<String>
}

struct DModule {
  tag: String,
  span: Span,
  name: String,
  decls: Vec<Decl>
}

struct DImport {
  tag: String,
  span: Span,
  modulePath: String,
  names: Vec<String>
}

// Helpers

fn span(start: I32, end: I32) : Span => SpanVal((start, end))

fn span_start(s: Span) : I32 => s.value.0
fn span_end(s: Span) : I32 => s.value.1
fn span_len(s: Span) : I32 => span_end(s) - span_start(s)

fn type_kind(t: TypeRef) : String => t.tag
fn type_span(t: TypeRef) : Span => t.span

fn expr_kind(e: Expr) : String => e.tag
fn expr_span(e: Expr) : Span => e.span

fn stmt_kind(s: Stmt) : String => s.tag
fn stmt_span(s: Stmt) : Span => s.span

fn decl_kind(d: Decl) : String => d.tag
fn decl_span(d: Decl) : Span => d.span

// Constructors (cross-module safe)

fn ty_name(span: Span, name: String) : TypeRef => TyName { "TyName", span, name }
fn ty_tuple(span: Span, items: Vec<TypeRef>) : TypeRef => TyTuple { "TyTuple", span, items }
fn ty_fn(span: Span, params: Vec<TypeRef>, result: TypeRef) : TypeRef => TyFn { "TyFn", span, params, result }
fn ty_app(span: Span, callee: String, args: Vec<TypeRef>) : TypeRef => TyApp { "TyApp", span, callee, args }

fn expr_undefined(span: Span) : Expr => EUndefined { "EUndefined", span }

fn expr_int(span: Span, value: I32) : Expr => EInt { "EInt", span, value }
fn expr_float(span: Span, text: String, suffix: String) : Expr => EFloat { "EFloat", span, text, suffix }
fn expr_bool(span: Span, value: Bool) : Expr => EBool { "EBool", span, value }
fn expr_string(span: Span, value: String) : Expr => EString { "EString", span, value }
fn expr_ident(span: Span, name: String) : Expr => EIdent { "EIdent", span, name }
fn expr_path(span: Span, parts: Vec<String>) : Expr => EPath { "EPath", span, parts }

fn expr_lambda(span: Span, typeParams: Vec<String>, params: Vec<String>, paramTyAnns: Vec<String>, retTyAnn: String, body: Expr) : Expr =>
  ELambda { "ELambda", span, typeParams, params, paramTyAnns, retTyAnn, body }

fn expr_struct_lit(span: Span, nameExpr: Expr, values: Vec<Expr>) : Expr => EStructLit { "EStructLit", span, nameExpr, values }

fn expr_unary(span: Span, op: UnOp, expr: Expr) : Expr => EUnary { "EUnary", span, op, expr }
fn expr_binary(span: Span, op: BinOp, left: Expr, right: Expr) : Expr => EBinary { "EBinary", span, op, left, right }
fn expr_call(span: Span, callee: Expr, args: Vec<Expr>) : Expr => ECall { "ECall", span, callee, vec_new(), args }
fn expr_call_typed(span: Span, callee: Expr, typeArgs: Vec<String>, args: Vec<Expr>) : Expr => ECall { "ECall", span, callee, typeArgs, args }
fn expr_if(span: Span, cond: Expr, thenExpr: Expr, elseExpr: Expr) : Expr => EIf { "EIf", span, cond, thenExpr, elseExpr }

fn expr_block(span: Span, body: Vec<Stmt>, tail: Expr) : Expr => EBlock { "EBlock", span, body, tail }
fn expr_vec_lit(span: Span, items: Vec<Expr>) : Expr => EVecLit { "EVecLit", span, items }
fn expr_tuple_lit(span: Span, items: Vec<Expr>) : Expr => ETupleLit { "ETupleLit", span, items }
fn expr_index(span: Span, base: Expr, index: Expr) : Expr => EIndex { "EIndex", span, base, index }
fn expr_tuple_index(span: Span, base: Expr, index: I32) : Expr => ETupleIndex { "ETupleIndex", span, base, index }
fn expr_field(span: Span, base: Expr, field: String) : Expr => EField { "EField", span, base, field }

fn pat_wildcard(span: Span) : MatchPat => MPWildcard { "MPWildcard", span }
fn pat_int(span: Span, value: I32) : MatchPat => MPInt { "MPInt", span, value }
fn pat_bool(span: Span, value: Bool) : MatchPat => MPBool { "MPBool", span, value }
fn pat_string(span: Span, value: String) : MatchPat => MPString { "MPString", span, value }
fn mk_match_arm(span: Span, pat: MatchPat, expr: Expr) : MatchArm => MatchArm { "MatchArm", span, pat, expr }
fn expr_match(span: Span, scrut: Expr, arms: Vec<MatchArm>) : Expr => EMatch { "EMatch", span, scrut, arms }

// Stmt constructors
fn stmt_let(span: Span, isMut: Bool, name: String, init: Expr) : Stmt => SLet { "SLet", span, isMut, name, "", init }
fn stmt_let_typed(span: Span, isMut: Bool, name: String, tyAnn: String, init: Expr) : Stmt => SLet { "SLet", span, isMut, name, tyAnn, init }
fn stmt_assign(span: Span, name: String, value: Expr) : Stmt => SAssign { "SAssign", span, name, value }
fn stmt_expr(span: Span, expr: Expr) : Stmt => SExpr { "SExpr", span, expr }
fn stmt_yield(span: Span, expr: Expr) : Stmt => SYield { "SYield", span, expr }
fn stmt_while(span: Span, cond: Expr, body: Vec<Stmt>) : Stmt => SWhile { "SWhile", span, cond, body }
fn stmt_if(span: Span, cond: Expr, thenBody: Vec<Stmt>, hasElse: Bool, elseBody: Vec<Stmt>) : Stmt => SIf { "SIf", span, cond, thenBody, hasElse, elseBody }
fn stmt_index_assign(span: Span, base: Expr, index: Expr, value: Expr) : Stmt => SIndexAssign { "SIndexAssign", span, base, index, value }
fn stmt_field_assign(span: Span, base: Expr, fields: Vec<String>, value: Expr) : Stmt => SFieldAssign { "SFieldAssign", span, base, fields, value }

// Decl constructors
fn decl_extern_from(span: Span, modulePath: String, names: Vec<String>) : Decl => DExternFrom { "DExternFrom", span, modulePath, names }
fn decl_import(span: Span, modulePath: String, names: Vec<String>) : Decl => DImport { "DImport", span, modulePath, names }
fn decl_struct(span: Span, name: String, fields: Vec<String>) : Decl => DStruct { "DStruct", span, name, vec_new(), fields, vec_new() }
fn decl_struct_typed(span: Span, name: String, typeParams: Vec<String>, fields: Vec<String>, fieldTyAnns: Vec<String>) : Decl =>
  DStruct { "DStruct", span, name, typeParams, fields, fieldTyAnns }
fn type_union_variant(span: Span, name: String, hasPayload: Bool) : TypeUnionVariant => TypeUnionVariant { "TypeUnionVariant", span, name, hasPayload, vec_new() }
fn type_union_variant_typed(span: Span, name: String, payloadTyAnns: Vec<String>) : TypeUnionVariant =>
  TypeUnionVariant { "TypeUnionVariant", span, name, vec_len(payloadTyAnns) > 0, payloadTyAnns }
fn decl_type_union(span: Span, name: String, typeParams: Vec<String>, variants: Vec<TypeUnionVariant>) : Decl =>
  DTypeUnion { "DTypeUnion", span, name, typeParams, variants }
fn decl_fn(span: Span, name: String, params: Vec<String>, body: Vec<Stmt>, tail: Expr) : Decl =>
  DFn { "DFn", span, name, vec_new(), params, vec_new(), "", body, tail }
fn decl_fn_typed(span: Span, name: String, typeParams: Vec<String>, params: Vec<String>, paramTyAnns: Vec<String>, retTyAnn: String, body: Vec<Stmt>, tail: Expr) : Decl =>
  DFn { "DFn", span, name, typeParams, params, paramTyAnns, retTyAnn, body, tail }
fn decl_class_fn(span: Span, name: String, params: Vec<String>, body: Vec<Stmt>, tail: Expr) : Decl =>
  DClassFn { "DClassFn", span, name, vec_new(), params, vec_new(), "", body, tail }
fn decl_class_fn_typed(span: Span, name: String, typeParams: Vec<String>, params: Vec<String>, paramTyAnns: Vec<String>, retTyAnn: String, body: Vec<Stmt>, tail: Expr) : Decl =>
  DClassFn { "DClassFn", span, name, typeParams, params, paramTyAnns, retTyAnn, body, tail }
fn decl_let(span: Span, isMut: Bool, name: String, init: Expr) : Decl => DLet { "DLet", span, isMut, name, "", init }
fn decl_let_typed(span: Span, isMut: Bool, name: String, tyAnn: String, init: Expr) : Decl => DLet { "DLet", span, isMut, name, tyAnn, init }
fn decl_module(span: Span, name: String, decls: Vec<Decl>) : Decl => DModule { "DModule", span, name, decls }
