// Fluff: the Tuff linter.
//
// Fluff runs parse+analyze across the module graph and reports warnings/errors.
// Configuration is loaded from build.json (auto-discovered upward).

extern from rt::stdlib use { println, stringLen, stringCharCodeAt, stringSlice, readTextFile };
extern from rt::vec use { vec_new, vec_len, vec_push, vec_get };

from tuffc_lib use { fluff_project_with_reader, fluff_files_with_reader };
from analyzer use { set_fluff_options, set_fluff_debug_options, set_fluff_debug_scopes, set_fluff_complexity_options, set_fluff_file_size_options, set_fluff_max_params_options, set_fluff_single_char_identifiers_options, set_fluff_missing_docs_options, set_fluff_clone_detection_options, set_fluff_clone_parameterized_options };
from build_config use { load_fluff_config };
from util::diagnostics use { set_diagnostics_format, has_project_errors, reset_project_errors, get_project_error_count, get_project_warning_count };

// Re-export for external callers (e.g., tuff_lint.ts).
out fn project_error_count() : I32 => get_project_error_count()
out fn project_warning_count() : I32 => get_project_warning_count()

fn print_usage() : Void => {
  println("usage: fluff [options] <in.tuff>");
  println("options:");
  println("  --format <human|json>          Diagnostics output format");
  println("  --debug                       Print all debug output (very noisy)");
  println("  --debug=<all|clone>            Print scoped debug output");
  println("config:");
  println("  build.json (auto-discovered upward from <in.tuff>)");
}

fn starts_with(s: String, prefix: String) : Bool => {
  if (stringLen(s) < stringLen(prefix)) { yield false; }
  stringSlice(s, 0, stringLen(prefix)) == prefix
}

fn main(argv: Vec<String>) => {
  let mut format = "human";
  let mut inPaths = vec_new();
  let mut debugScopes = "";

  let mut i = 0;
  while (i < vec_len(argv)) {
    let a = vec_get(argv, i);

    if (a == "--format") {
      if (i + 1 >= vec_len(argv)) {
        print_usage();
        yield 1;
      }
      format = vec_get(argv, i + 1);
      i = i + 2;
      continue;
    }

    if (a == "--debug") {
      debugScopes = "all";
      i = i + 1;
      continue;
    }

    if (starts_with(a, "--debug=")) {
      debugScopes = stringSlice(a, 8, stringLen(a));
      i = i + 1;
      continue;
    }

    if (stringLen(a) > 0 && stringCharCodeAt(a, 0) == 45) {
      println("unknown option: " + a);
      print_usage();
      yield 1;
    }

    vec_push(inPaths, a);
    i = i + 1;
    continue;
  }

  if (vec_len(inPaths) == 0) {
    print_usage();
    yield 1;
  }

  set_diagnostics_format(format);
  reset_project_errors();

  let cfg = load_fluff_config(vec_get(inPaths, 0));
  set_fluff_options(cfg.unusedLocals, cfg.unusedParams);
  if (debugScopes == "") {
    set_fluff_debug_options(false);
  } else {
    set_fluff_debug_scopes(debugScopes);
  }
  set_fluff_complexity_options(cfg.complexity, cfg.complexityThreshold);
  set_fluff_file_size_options(cfg.maxFileLines, cfg.maxFileLinesThreshold);
  set_fluff_max_params_options(cfg.maxParams, cfg.maxParamsThreshold);
  set_fluff_single_char_identifiers_options(cfg.singleCharIdentifiers);
  set_fluff_missing_docs_options(cfg.missingDocs);
  set_fluff_clone_detection_options(cfg.cloneDetection, cfg.cloneMinTokens, cfg.cloneMinOccurrences);
  set_fluff_clone_parameterized_options(cfg.cloneParameterized);

  if (vec_len(inPaths) == 1) {
    fluff_project_with_reader(vec_get(inPaths, 0), readTextFile);
  } else {
    fluff_files_with_reader(inPaths, readTextFile);
  }
  if (has_project_errors()) { yield 1; }
  0
}
