// LSP support: go-to-definition.
// Extracted from tuffc_lib.tuff to keep the facade small.

extern from rt::vec use { vec_new, vec_push, vec_len, vec_get };
extern from rt::stdlib use { stringLen, stringCharCodeAt };

from util::diagnostics use {
  set_current_file,
  reset_errors,
  reset_warnings,
  reset_struct_defs
};

from compile::lsp_util use {
  lsp_resolve_module_path_impl,
  lsp_ident_at_impl,
  lsp_module_path_at_impl
};

from ast use {
  span_start,
  span_end
};

from compile::lsp_check use { lsp_parse_file_impl };

// ------------------------------------------------------------
// LSP: Go-to-definition support
// ------------------------------------------------------------

// Definition entry for the simple symbol table
struct LspDef {
  tag: String,
  name: String,
  defStart: I32,
  defEnd: I32,
  kind: String,
  defFile: String
}

// Symbol reference with resolved definition
struct LspRefInternal {
  tag: String,
  refStart: I32,
  refEnd: I32,
  defStart: I32,
  defEnd: I32,
  defFile: String
}

// Result of a go-to-definition lookup.
class fn DefLocation(found: Bool, defStart: I32, defEnd: I32, defFile: String) => {}

fn lsp_def(name: String, defStart: I32, defEnd: I32, kind: String) : LspDef =>
  LspDef { "LspDef", name, defStart, defEnd, kind, "" }

fn lsp_def_ext(name: String, defStart: I32, defEnd: I32, kind: String, defFile: String) : LspDef =>
  LspDef { "LspDef", name, defStart, defEnd, kind, defFile }

fn lsp_ref_ext(refStart: I32, refEnd: I32, defStart: I32, defEnd: I32, defFile: String) : LspRefInternal =>
  LspRefInternal { "LspRef", refStart, refEnd, defStart, defEnd, defFile }

// Simple scoped symbol table
fn lsp_lookup(defs: Vec<LspDef>, name: String) : LspDef => {
  // Search from end (most recent) to handle scoping
  let mut i = vec_len(defs) - 1;
  while (i >= 0) {
    let d = vec_get(defs, i);
    if (d.name == name) { yield d; }
    i = i - 1;
  }
  lsp_def("", -1, -1, "")
}

fn lsp_lookup_type(defs: Vec<LspDef>, name: String) : LspDef => {
  let mut i = vec_len(defs) - 1;
  while (i >= 0) {
    let d = vec_get(defs, i);
    if (d.name == name && (d.kind == "struct" || d.kind == "type")) { yield d; }
    i = i - 1;
  }
  lsp_def("", -1, -1, "")
}

fn lsp_lookup_field(defs: Vec<LspDef>, structName: String, fieldName: String) : LspDef => {
  let fullName = structName + "." + fieldName;
  let mut i = 0;
  while (i < vec_len(defs)) {
    let d = vec_get(defs, i);
    if (d.name == fullName && d.kind == "field") { yield d; }
    i = i + 1;
  }
  lsp_def("", -1, -1, "")
}

// Check if offset is in range [start, end)
fn lsp_in_range(offset: I32, start: I32, end: I32) : Bool => offset >= start && offset < end

// Collect declarations from decls into defs
fn lsp_collect_decls(decls: Vec<Decl>, defs: Vec<LspDef>, filePath: String) : Void => {
  let mut i = 0;
  while (i < vec_len(decls)) {
    lsp_collect_decl(vec_get(decls, i), defs, filePath);
    i = i + 1;
  }
}

fn lsp_collect_decl(d: Decl, defs: Vec<LspDef>, filePath: String) : Void => {
  if (d is DExternFrom) {
    let mut ni = 0;
    while (ni < vec_len(d.names)) {
      vec_push(defs, lsp_def(vec_get(d.names, ni), span_start(d.span), span_end(d.span), "extern"));
      ni = ni + 1;
    }
  }
  if (d is DImport) {
    // Resolve the module path to a file path for cross-file navigation
    let targetFile = lsp_resolve_module_path_impl(d.modulePath, filePath);
    let mut ni = 0;
    while (ni < vec_len(d.names)) {
      // For imported names, store the target file and position 0 (we don't parse the target file yet)
      vec_push(defs, lsp_def_ext(vec_get(d.names, ni), 0, 0, "import", targetFile));
      ni = ni + 1;
    }
  }
  if (d is DLet) {
    vec_push(defs, lsp_def(d.name, span_start(d.span), span_end(d.span), "var"));
  }
  if (d is DFn) {
    vec_push(defs, lsp_def(d.name, span_start(d.span), span_end(d.span), "fn"));
  }
  if (d is DClassFn) {
    vec_push(defs, lsp_def(d.name, span_start(d.span), span_end(d.span), "fn"));
  }
  if (d is DStruct) {
    vec_push(defs, lsp_def(d.name, span_start(d.span), span_end(d.span), "struct"));
    // Register fields.
    // NOTE: In the canonical AST, `DStruct.fields` is a `Vec<String>` (names only).
    // We don't currently have per-field spans, so map fields to the struct span.
    let mut fi = 0;
    while (fi < vec_len(d.fields)) {
      let fieldName = vec_get(d.fields, fi);
      vec_push(defs, lsp_def(d.name + "." + fieldName, span_start(d.span), span_end(d.span), "field"));
      fi = fi + 1;
    }
  }
  if (d is DTypeUnion) {
    vec_push(defs, lsp_def(d.name, span_start(d.span), span_end(d.span), "type"));
    let mut vi = 0;
    while (vi < vec_len(d.variants)) {
      let v = vec_get(d.variants, vi);
      vec_push(defs, lsp_def(v.name, span_start(v.span), span_end(v.span), "variant"));
      vi = vi + 1;
    }
  }
  if (d is DModule) {
    vec_push(defs, lsp_def(d.name, span_start(d.span), span_end(d.span), "module"));
    lsp_collect_decls(d.decls, defs, filePath);
  }
}

// Resolve references in expressions. Returns inferred type name for field access.
fn lsp_resolve_expr(e: Expr, defs: Vec<LspDef>, refs: Vec<LspRefInternal>) : String => {
  if (e is EIdent) {
    let d = lsp_lookup(defs, e.name);
    if (d.defStart >= 0 || stringLen(d.defFile) > 0) {
      vec_push(refs, lsp_ref_ext(span_start(e.span), span_end(e.span), d.defStart, d.defEnd, d.defFile));
    }
    yield "";
  }

  if (e is EStructLit) {
    // Struct name is a type reference.
    // Canonical AST stores it as `nameExpr`.
    let mut structName = "";
    let mut nameSpan = e.span;
    if (e.nameExpr is EIdent) {
      structName = e.nameExpr.name;
      nameSpan = e.nameExpr.span;
    }
    if (e.nameExpr is EPath) {
      // Use the last path segment as the type name.
      if (vec_len(e.nameExpr.parts) > 0) {
        structName = vec_get(e.nameExpr.parts, vec_len(e.nameExpr.parts) - 1);
        nameSpan = e.nameExpr.span;
      }
    }

    if (stringLen(structName) > 0) {
      let tyDef = lsp_lookup_type(defs, structName);
      if (tyDef.defStart >= 0 || stringLen(tyDef.defFile) > 0) {
        vec_push(refs, lsp_ref_ext(span_start(nameSpan), span_end(nameSpan), tyDef.defStart, tyDef.defEnd, tyDef.defFile));
      }
    }
    let mut vi = 0;
    while (vi < vec_len(e.values)) {
      lsp_resolve_expr(vec_get(e.values, vi), defs, refs);
      vi = vi + 1;
    }
    yield structName;
  }

  if (e is EField) {
    let baseTy = lsp_resolve_expr(e.base, defs, refs);
    if (stringLen(baseTy) > 0) {
      let fieldDef = lsp_lookup_field(defs, baseTy, e.field);
      if (fieldDef.defStart >= 0) {
        // Field reference starts after the dot
        let fieldStart = span_end(e.base.span) + 1;
        vec_push(refs, lsp_ref_ext(fieldStart, span_end(e.span), fieldDef.defStart, fieldDef.defEnd, fieldDef.defFile));
      }
    }
    yield "";
  }

  if (e is ECall) {
    lsp_resolve_expr(e.callee, defs, refs);
    let mut ai = 0;
    while (ai < vec_len(e.args)) {
      lsp_resolve_expr(vec_get(e.args, ai), defs, refs);
      ai = ai + 1;
    }
  }

  if (e is EBinary) {
    lsp_resolve_expr(e.left, defs, refs);
    lsp_resolve_expr(e.right, defs, refs);
  }

  if (e is EUnary) {
    lsp_resolve_expr(e.expr, defs, refs);
  }

  if (e is EIf) {
    lsp_resolve_expr(e.cond, defs, refs);
    lsp_resolve_expr(e.thenExpr, defs, refs);
    lsp_resolve_expr(e.elseExpr, defs, refs);
  }

  if (e is EBlock) {
    lsp_resolve_stmts(e.body, defs, refs);
    lsp_resolve_expr(e.tail, defs, refs);
  }

  if (e is ELambda) {
    let mut pi = 0;
    while (pi < vec_len(e.params)) {
      vec_push(defs, lsp_def(vec_get(e.params, pi), span_start(e.span), span_end(e.span), "param"));
      pi = pi + 1;
    }
    lsp_resolve_expr(e.body, defs, refs);
  }

  if (e is EMatch) {
    lsp_resolve_expr(e.scrut, defs, refs);
    let mut mi = 0;
    while (mi < vec_len(e.arms)) {
      let arm = vec_get(e.arms, mi);
      let mut bi = 0;
      while (bi < vec_len(arm.bindings)) {
        vec_push(defs, lsp_def(vec_get(arm.bindings, bi), span_start(arm.span), span_end(arm.span), "binding"));
        bi = bi + 1;
      }
      lsp_resolve_expr(arm.expr, defs, refs);
      mi = mi + 1;
    }
  }

  if (e is EIndex) {
    lsp_resolve_expr(e.base, defs, refs);
    lsp_resolve_expr(e.index, defs, refs);
  }

  if (e is ETupleIndex) {
    lsp_resolve_expr(e.base, defs, refs);
  }

  if (e is EVecLit) {
    let mut ii = 0;
    while (ii < vec_len(e.items)) {
      lsp_resolve_expr(vec_get(e.items, ii), defs, refs);
      ii = ii + 1;
    }
  }

  if (e is ETupleLit) {
    let mut ii = 0;
    while (ii < vec_len(e.items)) {
      lsp_resolve_expr(vec_get(e.items, ii), defs, refs);
      ii = ii + 1;
    }
  }

  ""
}

fn lsp_resolve_stmt(s: Stmt, defs: Vec<LspDef>, refs: Vec<LspRefInternal>) : Void => {
  if (s is SLet) {
    lsp_resolve_expr(s.init, defs, refs);
    vec_push(defs, lsp_def(s.name, span_start(s.span), span_end(s.span), "var"));
  }

  if (s is SAssign) {
    let d = lsp_lookup(defs, s.name);
    if (d.defStart >= 0) {
      vec_push(refs, lsp_ref_ext(span_start(s.span), span_start(s.span) + stringLen(s.name), d.defStart, d.defEnd, d.defFile));
    }
    lsp_resolve_expr(s.value, defs, refs);
  }

  if (s is SExpr) {
    lsp_resolve_expr(s.expr, defs, refs);
  }

  if (s is SYield) {
    lsp_resolve_expr(s.expr, defs, refs);
  }

  if (s is SWhile) {
    lsp_resolve_expr(s.cond, defs, refs);
    lsp_resolve_stmts(s.body, defs, refs);
  }

  if (s is SIf) {
    lsp_resolve_expr(s.cond, defs, refs);
    lsp_resolve_stmts(s.thenBody, defs, refs);
    if (s.hasElse) {
      lsp_resolve_stmts(s.elseBody, defs, refs);
    }
  }

  if (s is SIndexAssign) {
    lsp_resolve_expr(s.base, defs, refs);
    lsp_resolve_expr(s.index, defs, refs);
    lsp_resolve_expr(s.value, defs, refs);
  }

  if (s is SFieldAssign) {
    lsp_resolve_expr(s.base, defs, refs);
    lsp_resolve_expr(s.value, defs, refs);
  }
}

fn lsp_resolve_stmts(stmts: Vec<Stmt>, defs: Vec<LspDef>, refs: Vec<LspRefInternal>) : Void => {
  let mut i = 0;
  while (i < vec_len(stmts)) {
    lsp_resolve_stmt(vec_get(stmts, i), defs, refs);
    i = i + 1;
  }
}

fn lsp_resolve_decl(d: Decl, defs: Vec<LspDef>, refs: Vec<LspRefInternal>) : Void => {
  if (d is DLet) {
    lsp_resolve_expr(d.init, defs, refs);
  }

  if (d is DFn) {
    let mut pi = 0;
    while (pi < vec_len(d.params)) {
      vec_push(defs, lsp_def(vec_get(d.params, pi), span_start(d.span), span_end(d.span), "param"));
      pi = pi + 1;
    }
    lsp_resolve_stmts(d.body, defs, refs);
    lsp_resolve_expr(d.tail, defs, refs);
  }

  if (d is DClassFn) {
    let mut pi = 0;
    while (pi < vec_len(d.params)) {
      vec_push(defs, lsp_def(vec_get(d.params, pi), span_start(d.span), span_end(d.span), "param"));
      pi = pi + 1;
    }
    lsp_resolve_stmts(d.body, defs, refs);
    lsp_resolve_expr(d.tail, defs, refs);
  }

  if (d is DModule) {
    lsp_resolve_decls(d.decls, defs, refs);
  }
}

fn lsp_resolve_decls(decls: Vec<Decl>, defs: Vec<LspDef>, refs: Vec<LspRefInternal>) : Void => {
  let mut i = 0;
  while (i < vec_len(decls)) {
    lsp_resolve_decl(vec_get(decls, i), defs, refs);
    i = i + 1;
  }
}

fn lsp_find_ref_at(refs: Vec<LspRefInternal>, offset: I32) : LspRefInternal => {
  let mut i = 0;
  while (i < vec_len(refs)) {
    let r = vec_get(refs, i);
    if (lsp_in_range(offset, r.refStart, r.refEnd)) { yield r; }
    i = i + 1;
  }
  lsp_ref_ext(-1, -1, -1, -1, "")
}

// Fallback: extract identifier under (or just left of) the cursor.

// Main LSP go-to-definition API.
out fn lsp_find_definition_impl(src: String, offset: I32, filePath: String) : DefLocation => {
  reset_struct_defs();
  reset_errors();
  reset_warnings();
  set_current_file(filePath);

  let decls = lsp_parse_file_impl(src);

  let defs = vec_new();
  let refs = vec_new();

  // Pass 1: collect all declarations
  lsp_collect_decls(decls, defs, filePath);

  // Pass 2: resolve references
  lsp_resolve_decls(decls, defs, refs);

  // Find reference at offset
  let r = lsp_find_ref_at(refs, offset);
  if (r.refStart < 0) {
    // Fallback for non-expression positions.
    let modulePath = lsp_module_path_at_impl(src, offset);
    if (stringLen(modulePath) > 0) {
      let targetFile = lsp_resolve_module_path_impl(modulePath, filePath);
      yield DefLocation(true, 0, 0, targetFile);
    }

    let ident = lsp_ident_at_impl(src, offset);
    if (stringLen(ident) > 0) {
      let d = lsp_lookup(defs, ident);
      if (d.defStart >= 0 || stringLen(d.defFile) > 0) {
        yield DefLocation(true, d.defStart, d.defEnd, d.defFile);
      }
    }

    yield DefLocation(false, 0, 0, "");
  }

  DefLocation(true, r.defStart, r.defEnd, r.defFile)
}
