extern from rt::stdlib use { pathDirname, pathJoin, stringLen, stringSlice, stringCharCodeAt };
extern from rt::vec use { vec_new, vec_len, vec_push, vec_get };

from util::diagnostics use { set_current_file, panic_at };
from util::lexing use { is_ident_part, skip_ws, starts_with_at };

from parsing::primitives use { parse_keyword, parse_ident, parse_module_path, module_path_to_relpath, parse_optional_semicolon };
from parsing::decls_legacy use { parse_extern_decl };
from parsing::decls use { parse_imports_ast };

from ast use { span_start };

from compile::string_lists use { str_list_contains, str_list_remove };
from compile::export_scan use { module_index, fnsig_lookup_by_name };
from compile::export_scan_cache use { cached_scan_top_level_fn_exports };
from compile::paths use { compiler_root_from_path };

fn kw_at(src: String, i: I32, kw: String) : Bool => {
  // Keyword match that rejects identifier continuations.
  if (!starts_with_at(src, i, kw)) { yield false; }
  let end = i + stringLen(kw);
  if (end < stringLen(src) && is_ident_part(stringCharCodeAt(src, end))) { yield false; }
  true
}

fn is_extern_decl_start(src: String, i: I32) : Bool => {
  // Accept:
  //   extern from ...
  //   extern type ...
  //   out extern type ...
  // NOT extern fn (handled by fn parser)
  let j = skip_ws(src, i);
  if (kw_at(src, j, "extern")) {
    let k = skip_ws(src, j + 6);
    if (kw_at(src, k, "fn")) { yield false; }
    if (kw_at(src, k, "out")) { yield false; }
    if (kw_at(src, k, "class")) { yield false; }
    if (kw_at(src, k, "extern")) { yield false; }
    yield true;
  }
  if (kw_at(src, j, "out")) {
    let k = skip_ws(src, j + 3);
    if (kw_at(src, k, "extern")) {
      let m = skip_ws(src, k + 6);
      if (kw_at(src, m, "fn")) { yield false; }
      if (kw_at(src, m, "class")) { yield false; }
      if (kw_at(src, m, "extern")) { yield false; }
      yield true;
    }
  }
  false
}

// Shared helper: walk the module graph (DFS) to
//   1) detect circular dependencies (hard error)
//   2) collect per-module export info (top-level out fns)
//   3) compute a safe compilation order (deps before importers)
//
// Callers inject the source reader function.
out fn collect_module_graph_info(
  entryPath: String,
  workspaceRoot: String,
  isCompilerBuild: Bool,
  readSource: (String) => String
) => {
  let mut stack = vec_new();
  vec_push(stack, entryPath);

  let mut visited = vec_new();
  let mut visiting = vec_new();
  let mut order = vec_new();
  let mut modulePaths = vec_new();
  let mut moduleOutFns = vec_new();
  let mut modulePrivateTopLevelFnNames = vec_new();

  while (vec_len(stack) > 0) {
    let item = vec_get(stack, vec_len(stack) - 1);

    // pop
    let mut newStack = vec_new();
    let mut qi = 0;
    while (qi + 1 < vec_len(stack)) {
      vec_push(newStack, vec_get(stack, qi));
      qi = qi + 1;
    }
    stack = newStack;

    if (starts_with_at(item, 0, "POST:")) {
      let path = stringSlice(item, 5, stringLen(item));
      visiting = str_list_remove(visiting, path);
      vec_push(order, path);
      continue;
    }

    let path = item;
    if (str_list_contains(visited, path)) { continue; }
    vec_push(visited, path);
    vec_push(visiting, path);

    // push post marker, then dependencies (LIFO)
    vec_push(stack, "POST:" + path);

    set_current_file(path);
    let src = readSource(path);

    // export table for this module
    let ex = cached_scan_top_level_fn_exports(path, src);
    vec_push(modulePaths, path);
    if (isCompilerBuild) {
      // Preserve legacy behavior for compiling the compiler itself: allow
      // cross-module imports without requiring `out` on every helper.
      vec_push(moduleOutFns, ex.2);
      vec_push(modulePrivateTopLevelFnNames, vec_new());
    } else {
      vec_push(moduleOutFns, ex.0);
      vec_push(modulePrivateTopLevelFnNames, ex.1);
    }

    // discover imports for graph walk
    let mut scan = 0;
    // skip externs
    while (true) {
      if (is_extern_decl_start(src, scan)) {
        let ex2 = parse_extern_decl(src, scan);
        scan = ex2.v1;
        continue;
      }
      break;
    }

    while (true) {
      let j = skip_ws(src, scan);
      if (starts_with_at(src, j, "import")) {
        panic_at(src, j, "`import` is not supported. Use `from <module> use { ... };` instead.");
      }
      if (!starts_with_at(src, j, "from")) { break; }
      scan = parse_keyword(src, scan, "from");
      let mod = parse_module_path(src, scan);
      scan = mod.nextPos;
      scan = parse_keyword(src, scan, "use");
      scan = parse_keyword(src, scan, "{");
      // consume name list
      while (true) {
        scan = skip_ws(src, scan);
        if (!(scan < stringLen(src))) { panic_at(src, scan, "expected '}'"); }
        if (stringCharCodeAt(src, scan) == 125) { scan = scan + 1; break; }
        let id = parse_ident(src, scan);
        scan = id.nextPos;
        scan = skip_ws(src, scan);
        if (scan < stringLen(src) && stringCharCodeAt(src, scan) == 44) { scan = scan + 1; continue; }
        scan = skip_ws(src, scan);
        if (scan < stringLen(src) && stringCharCodeAt(src, scan) == 125) { scan = scan + 1; break; }
        panic_at(src, scan, "expected ',' or '}' in import list");
      }
      scan = parse_optional_semicolon(src, scan);

      // resolve dependency file
      let compilerSrcPrefix = "src::main::tuff::compiler::";
      let mut rel = module_path_to_relpath(mod.text);
      let mut baseDir = pathDirname(path);
      if (starts_with_at(mod.text, 0, compilerSrcPrefix)) {
        // Treat these as compiler-root imports to match internal compiler layout.
        let compilerRootDir = pathJoin(workspaceRoot, "src/main/tuff/compiler");
        baseDir = compilerRootDir;
        let rest = stringSlice(mod.text, stringLen(compilerSrcPrefix), stringLen(mod.text));
        rel = module_path_to_relpath(rest);
      } else {
        if (starts_with_at(mod.text, 0, "src::") || starts_with_at(mod.text, 0, "std::")) {
          baseDir = workspaceRoot;
        } else {
          let cr = compiler_root_from_path(path);
          if (stringLen(cr) > 0) { baseDir = cr; }
        }
      }
      let depPath = pathJoin(baseDir, rel + ".tuff");

      if (!str_list_contains(visiting, depPath)) {
        // Allow module cycles. Skip back-edges; `visited` prevents infinite
        // traversal.
        vec_push(stack, depPath);
      }
    }
  }

  (order, modulePaths, moduleOutFns, modulePrivateTopLevelFnNames)
}

fn collect_imported_fn_sigs(
  src: String,
  path: String,
  workspaceRoot: String,
  isCompilerBuild: Bool,
  seedImportedFns: Bool,
  modulePaths: Vec<String>,
  moduleOutFns: Vec<Vec<FnSig>>,
  modulePrivateTopLevelFnNames: Vec<Vec<String>>
) : Vec<FnSig> => {
  let importedFns = vec_new();

  if (!isCompilerBuild) {
    let mut scan = 0;
    while (true) {
      if (is_extern_decl_start(src, scan)) {
        let ex2 = parse_extern_decl(src, scan);
        scan = ex2.v1;
        continue;
      }
      break;
    }

    let impsAst = parse_imports_ast(src, scan);
    let mut ii = 0;
    while (ii < vec_len(impsAst.decls)) {
      let imp = vec_get(impsAst.decls, ii);
      if (imp is DImport) {
        let rel = module_path_to_relpath(imp.modulePath);
        let mut baseDir = pathDirname(path);
        let compilerSrcPrefix = "src::main::tuff::compiler::";
        let mut rel2 = rel;
        if (starts_with_at(imp.modulePath, 0, compilerSrcPrefix)) {
          let compilerRootDir = pathJoin(workspaceRoot, "src/main/tuff/compiler");
          baseDir = compilerRootDir;
          let rest = stringSlice(imp.modulePath, stringLen(compilerSrcPrefix), stringLen(imp.modulePath));
          rel2 = module_path_to_relpath(rest);
        } else {
          if (starts_with_at(imp.modulePath, 0, "src::") || starts_with_at(imp.modulePath, 0, "std::")) {
            baseDir = workspaceRoot;
          } else {
            let cr = compiler_root_from_path(path);
            if (stringLen(cr) > 0) { baseDir = cr; }
          }
        }
        let depPath = pathJoin(baseDir, rel2 + ".tuff");

        let depIdx = module_index(modulePaths, depPath);
        if (depIdx != -1) {
          let outFns = vec_get(moduleOutFns, depIdx);
          let privateNames = vec_get(modulePrivateTopLevelFnNames, depIdx);
          let mut ni = 0;
          while (ni < vec_len(imp.names)) {
            let name = vec_get(imp.names, ni);

            let sig = fnsig_lookup_by_name(outFns, name);
            if (!(sig.name == "")) {
              if (seedImportedFns) {
                vec_push(importedFns, sig);
              }
            } else {
              if (str_list_contains(privateNames, name)) {
                panic_at(src, span_start(imp.span), "imported function '" + name + "' is not exported (missing `out fn`)");
              }
            }

            ni = ni + 1;
          }
        }
      }
      ii = ii + 1;
    }
  }

  importedFns
}

out fn project_imported_fn_sigs(
  src: String,
  path: String,
  workspaceRoot: String,
  isCompilerBuild: Bool,
  modulePaths: Vec<String>,
  moduleOutFns: Vec<Vec<FnSig>>,
  modulePrivateTopLevelFnNames: Vec<Vec<String>>
) : Vec<FnSig> => {
  // Build imported function signatures and validate `out` visibility.
  // Keep behavior consistent with compile_project/fluff_project.

  let seedImportedFns = !(stringLen(compiler_root_from_path(path)) > 0);
  collect_imported_fn_sigs(src, path, workspaceRoot, isCompilerBuild, seedImportedFns, modulePaths, moduleOutFns, modulePrivateTopLevelFnNames)
}

out fn project_out_paths(path: String, entryPath: String, outDir: String, outPath: String, workspaceRoot: String) => {
  // Compute a stable source-relative path for output layout.
  let crHere = compiler_root_from_path(path);
  let relRoot = if (stringLen(crHere) > 0) crHere else workspaceRoot;

  let mut prefixLen = stringLen(relRoot);
  let mut relStart = prefixLen;
  if (relStart < stringLen(path)) {
    let ch = stringCharCodeAt(path, relStart);
    if (ch == 47 || ch == 92) { relStart = relStart + 1; }
  }
  let relSrcPath = stringSlice(path, relStart, stringLen(path));
  let relNoExt = stringSlice(relSrcPath, 0, stringLen(relSrcPath) - 5);

  let outRelPath = if (path == entryPath) {
    let mut pfx = stringLen(outDir);
    let mut s = pfx;
    if (s < stringLen(outPath)) {
      let ch2 = stringCharCodeAt(outPath, s);
      if (ch2 == 47 || ch2 == 92) { s = s + 1; }
    }
    stringSlice(outPath, s, stringLen(outPath))
  } else {
    relNoExt + ".mjs"
  };

  let outFile = if (path == entryPath) outPath else pathJoin(outDir, relNoExt + ".mjs");

  (outRelPath, outFile)
}

out fn project_compile_one_module_with(
  compile_one: (String, Bool, Bool, String, Vec<FnSig>) => String,
  src: String,
  path: String,
  entryPath: String,
  outDir: String,
  outPath: String,
  workspaceRoot: String,
  isCompilerBuild: Bool,
  modulePaths: Vec<String>,
  moduleOutFns: Vec<Vec<FnSig>>,
  modulePrivateTopLevelFnNames: Vec<Vec<String>>
) => {
  let importedFns = project_imported_fn_sigs(src, path, workspaceRoot, isCompilerBuild, modulePaths, moduleOutFns, modulePrivateTopLevelFnNames);
  let paths = project_out_paths(path, entryPath, outDir, outPath, workspaceRoot);
  let outRelPath = paths.0;
  let outFile = paths.1;

  // For project compilation, exports are controlled via `out` (plus `main`).
  // For compiler bootstrapping, keep legacy `exportAll` to avoid churn.
  let js = compile_one(src, path == entryPath, isCompilerBuild, outRelPath, importedFns);
  (outRelPath, outFile, js)
}

out fn project_lint_one_module_with(
  lint_one: (String, Bool, Bool, Vec<FnSig>) => Void,
  src: String,
  path: String,
  entryPath: String,
  workspaceRoot: String,
  isCompilerBuild: Bool,
  modulePaths: Vec<String>,
  moduleOutFns: Vec<Vec<FnSig>>,
  modulePrivateTopLevelFnNames: Vec<Vec<String>>
) : Void => {
  // Fluff uses slightly different seeding rules:
  let seedImportedFns = !isCompilerBuild && !(stringLen(compiler_root_from_path(path)) > 0);
  let importedFns = collect_imported_fn_sigs(src, path, workspaceRoot, isCompilerBuild, seedImportedFns, modulePaths, moduleOutFns, modulePrivateTopLevelFnNames);

  lint_one(src, path == entryPath, isCompilerBuild, importedFns);
}
