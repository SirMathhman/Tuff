// LSP support: parse + analyze a single file and collect diagnostics.
// Extracted from tuffc_lib.tuff to keep the facade small.

extern from rt::vec use { vec_new, vec_push, vec_len, vec_get };
extern from rt::stdlib use { stringLen, stringCharCodeAt };

from util::diagnostics use {
  set_current_file,
  reset_errors,
  reset_warnings,
  reset_struct_defs,
  get_error_infos
};

from util::lexing use {
  is_ident_part,
  skip_ws,
  starts_with_at
};

from parsing::primitives use {
  parse_keyword,
  parse_ident,
  parse_optional_semicolon
};

from parsing::types use { parse_type_expr };

from parsing::expr_stmt use { parse_mut_opt, parse_expr_ast };

from parsing::decls use {
  parse_imports_ast,
  parse_extern_decl_ast,
  parse_module_decl_ast,
  parse_fn_decl_ast2,
  parse_class_fn_decl_ast2,
  parse_struct_decl_ast,
  parse_type_union_decl_ast,
  is_fn_decl_start
};

from ast use {
  span,
  decl_let,
  decl_let_typed
};

from analyzer use { analyze_program };

fn kw_at(src: String, i: I32, kw: String) : Bool => {
  // Keyword match that rejects identifier continuations.
  if (!starts_with_at(src, i, kw)) { yield false; }
  let end = i + stringLen(kw);
  if (end < stringLen(src) && is_ident_part(stringCharCodeAt(src, end))) { yield false; }
  true
}

fn is_extern_decl_start(src: String, i: I32) : Bool => {
  // Accept:
  //   extern from ...
  //   extern type ...
  //   out extern type ...
  let j = skip_ws(src, i);
  if (kw_at(src, j, "extern")) { yield true; }
  if (kw_at(src, j, "out")) {
    let k = skip_ws(src, j + 3);
    if (kw_at(src, k, "extern")) { yield true; }
  }
  false
}

// Parse file into canonical AST decls. Exported for go-to-definition.
out fn lsp_parse_file_impl(src: String) : Vec<Decl> => {
  let decls = vec_new();
  let mut i = 0;

  // zero or more extern declarations
  while (true) {
    if (is_extern_decl_start(src, i)) {
      let ex = parse_extern_decl_ast(src, i);
      vec_push(decls, ex.decl);
      i = ex.nextPos;
      continue;
    }
    break;
  }

  // zero or more imports
  let imps = parse_imports_ast(src, i);
  let mut ii = 0;
  while (ii < vec_len(imps.decls)) {
    vec_push(decls, vec_get(imps.decls, ii));
    ii = ii + 1;
  }
  i = imps.nextPos;

  // Parse all declarations in any order: module, type, struct, let, fn, class fn, out fn
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "module")) {
      let m = parse_module_decl_ast(src, i);
      vec_push(decls, m.decl);
      i = m.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "type")) {
      let td = parse_type_union_decl_ast(src, i, false);
      vec_push(decls, td.decl);
      i = td.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "struct")) {
      let sd = parse_struct_decl_ast(src, i);
      vec_push(decls, sd.decl);
      i = sd.nextPos;
      continue;
    }
    if (starts_with_at(src, j, "let")) {
      let start = skip_ws(src, i);
      i = parse_keyword(src, i, "let");
      let mutOpt = parse_mut_opt(src, i);
      i = mutOpt.nextPos;
      let name = parse_ident(src, i);
      i = name.nextPos;

      let mut tyAnn = "";
      let t0 = skip_ws(src, i);
      if (t0 < stringLen(src) && stringCharCodeAt(src, t0) == 58) {
        let _ty = parse_type_expr(src, t0 + 1);
        tyAnn = _ty.v0;
        i = _ty.v1;
      }

      i = parse_keyword(src, i, "=");
      let expr = parse_expr_ast(src, i);
      i = expr.nextPos;
      i = parse_optional_semicolon(src, i);
      if (tyAnn == "") {
        vec_push(decls, decl_let(span(start, i), mutOpt.ok, name.text, expr.expr));
      } else {
        vec_push(decls, decl_let_typed(span(start, i), mutOpt.ok, name.text, tyAnn, expr.expr));
      }
      continue;
    }
    if (starts_with_at(src, j, "fn")) {
      let f = parse_fn_decl_ast2(src, i, false);
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    // Handle all modifier combinations: out, class, extern in any order before fn
    if (is_fn_decl_start(src, j)) {
      let f = parse_fn_decl_ast2(src, i, false);
      vec_push(decls, f.decl);
      i = f.nextPos;
      continue;
    }
    break;
  }

  decls
}

// LSP API: parse+analyze a single file and collect diagnostics without panicking.
out fn lsp_check_file_impl(src: String, filePath: String) : Bool => {
  // Reset per-file state.
  reset_struct_defs();
  reset_errors();
  reset_warnings();
  set_current_file(filePath);

  let decls = lsp_parse_file_impl(src);

  // Run analyzer (won't panic, just collects errors)
  analyze_program(src, decls);

  // Return true if no errors
  vec_len(get_error_infos()) == 0
}
