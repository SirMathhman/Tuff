// std::iter â€” minimal iterator utilities
//
// Phase 5-6 scaffold: start with a simple integer range iterator.
//
// NOTE: The current selfhost compiler lowers `class fn` by yielding an object
// containing *only parameters* (not locals). To expose methods/state, we pass
// closures as parameters.

// Generic iterator protocol (bootstrap subset): any value with a `for_each(f)`
// field is considered an iterator.
//
// We also expose combinators as fields so callers can chain:
//   range(0, 6).iter().filter(...).map(...).fold(...)
class fn Iter(
  for_each: ((Unknown) => I32) => I32,
  map: (Unknown) => Iter,
  filter: (Unknown) => Iter,
  fold: (Unknown, Unknown) => Unknown
) => {}

class fn Range(
  start: I32,
  end: I32,
  has_next: () => Bool,
  next: () => I32,
  for_each: ((I32) => I32) => I32,
  iter: () => Iter
) => {}

fn iter_new(for_each: ((Unknown) => I32) => I32) : Iter => {
  let map_fn = (f: Unknown) : Iter => {
    iter_new((g: Unknown) => {
      for_each((x: Unknown) => {
        g(f(x));
        0
      });
      0
    })
  };

  let filter_fn = (pred: Unknown) : Iter => {
    iter_new((g: Unknown) => {
      for_each((x: Unknown) => {
        if (pred(x)) {
          g(x);
        }
        0
      });
      0
    })
  };

  let fold_fn = (init: Unknown, f: Unknown) : Unknown => {
    let mut acc = init;
    for_each((x: Unknown) => {
      acc = f(acc, x);
      0
    });
    acc
  };

  Iter(for_each, map_fn, filter_fn, fold_fn)
}

out fn range(start: I32, end: I32) => {
  let mut cur: I32 = start;

  let has_next = () : Bool => cur < end;

  let next = () : I32 => {
    let v: I32 = cur;
    cur = cur + 1;
    v
  };

  let for_each = (f: (I32) => I32) : I32 => {
    while (has_next()) {
      f(next());
    }
    0
  };

  let iter = () : Iter => iter_new(for_each);

  Range(start, end, has_next, next, for_each, iter)
}

// Compatibility helpers (non-chaining style).
fn map(iter: Unknown, f: Unknown) => iter_new((g: Unknown) => {
  iter.for_each((x: Unknown) => {
    g(f(x));
    0
  });
})

fn filter(iter: Unknown, pred: Unknown) => iter_new((g: Unknown) => {
  iter.for_each((x: Unknown) => {
    if (pred(x)) { g(x); }
    0
  });
})

fn fold(iter: Unknown, init: Unknown, f: Unknown) => iter_new(iter.for_each).fold(init, f)
