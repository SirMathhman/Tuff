// Minimal unit test helpers, written in Tuff.
//
// Design goals:
// - no exceptions/try-catch required (so tests can continue after failures)
// - no first-class function plumbing required (caller supplies a Bool)
// - does not call `exit()` so it can be used from other runners (JS tests, REPL)

extern from rt::stdlib use { println };

let mut __passed = 0;
let mut __failed = 0;
let mut __suite = "";

out fn reset() => {
  __passed = 0;
  __failed = 0;
  __suite = "";
}

out fn get_passed() : I32 => __passed
out fn get_failed() : I32 => __failed

out fn suite(name: String) => {
  __suite = name;
  println("# suite: " + name);
}

// NOTE: Avoid a trailing semicolon here; the selfhost compiler can otherwise
// truncate emission for std modules.
fn __full_name(name: String) : String => if (__suite == "") name else (__suite + " :: " + name)

out fn expect(name: String, cond: Bool) : Bool => if (cond) true else {
  println("  assertion failed: " + __full_name(name));
  false
}

out fn expect_eq<T>(name: String, got: T, expected: T) : Bool => if (got == expected) true else {
  println("  assertion failed: " + __full_name(name));
  println("    expected: " + expected);
  println("    got: " + got);
  false
}

out fn expect_ne<T>(name: String, got: T, not_expected: T) : Bool => if (!(got == not_expected)) true else {
  println("  assertion failed: " + __full_name(name));
  println("    expected: (not) " + not_expected);
  println("    got: " + got);
  false
}

out fn expect_true(name: String, cond: Bool) : Bool => if (cond) true else {
  println("  assertion failed: " + __full_name(name));
  println("    expected: true");
  println("    got: false");
  false
}

out fn expect_false(name: String, cond: Bool) : Bool => if (!cond) true else {
  println("  assertion failed: " + __full_name(name));
  println("    expected: false");
  println("    got: true");
  false
}

out fn expect_lt(name: String, got: I32, threshold: I32) : Bool => if (got < threshold) true else {
  println("  assertion failed: " + __full_name(name));
  println("    expected: < " + ("" + threshold));
  println("    got: " + ("" + got));
  false
}

out fn expect_le(name: String, got: I32, threshold: I32) : Bool => if (got < threshold || got == threshold) true else {
  println("  assertion failed: " + __full_name(name));
  println("    expected: <= " + ("" + threshold));
  println("    got: " + ("" + got));
  false
}

out fn expect_gt(name: String, got: I32, threshold: I32) : Bool => if (got > threshold) true else {
  println("  assertion failed: " + __full_name(name));
  println("    expected: > " + ("" + threshold));
  println("    got: " + ("" + got));
  false
}

out fn expect_ge(name: String, got: I32, threshold: I32) : Bool => if (got > threshold || got == threshold) true else {
  println("  assertion failed: " + __full_name(name));
  println("    expected: >= " + ("" + threshold));
  println("    got: " + ("" + got));
  false
}

out fn it(name: String, ok: Bool) => {
  let full = __full_name(name);
  if (ok) {
    __passed = __passed + 1;
    println("ok  - " + full);
  } else {
    __failed = __failed + 1;
    println("not ok - " + full);
  }
}

out fn summary() => {
  println("passed: " + __passed);
  println("failed: " + __failed);
}

out fn status() => if (__failed == 0) 0 else 1
