// Minimal unit test helpers, written in Tuff.
//
// Design goals:
// - no exceptions/try-catch required (so tests can continue after failures)
// - no first-class function plumbing required (caller supplies a Bool)
// - does not call `exit()` so it can be used from other runners (JS tests, REPL)

extern from rt::stdlib use { println };

let mut __passed = 0;
let mut __failed = 0;
let mut __suite = "";

out fn reset() => {
  __passed = 0;
  __failed = 0;
  __suite = "";
}

out fn get_passed() => __passed
out fn get_failed() => __failed

out fn suite(name) => {
  __suite = name;
  println("# suite: " + name);
}

// NOTE: Avoid a trailing semicolon here; the selfhost compiler can otherwise
// truncate emission for std modules.
fn __full_name(name) => if (__suite == "") name else (__suite + " :: " + name)

out fn expect(name, cond) => if (cond) true else {
  println("  assertion failed: " + __full_name(name));
  false
}

out fn expect_eq(name, got, expected) => if (got == expected) true else {
  println("  assertion failed: " + __full_name(name));
  println("    expected: " + expected);
  println("    got: " + got);
  false
}

out fn expect_ne(name, got, not_expected) => if (!(got == not_expected)) true else {
  println("  assertion failed: " + __full_name(name));
  println("    expected: (not) " + not_expected);
  println("    got: " + got);
  false
}

out fn expect_true(name, cond) => if (cond) true else {
  println("  assertion failed: " + __full_name(name));
  println("    expected: true");
  println("    got: false");
  false
}

out fn expect_false(name, cond) => if (!cond) true else {
  println("  assertion failed: " + __full_name(name));
  println("    expected: false");
  println("    got: true");
  false
}

out fn expect_lt(name, got, threshold) => if (got < threshold) true else {
  println("  assertion failed: " + __full_name(name));
  println("    expected: < " + ("" + threshold));
  println("    got: " + ("" + got));
  false
}

out fn expect_le(name, got, threshold) => if (got < threshold || got == threshold) true else {
  println("  assertion failed: " + __full_name(name));
  println("    expected: <= " + ("" + threshold));
  println("    got: " + ("" + got));
  false
}

out fn expect_gt(name, got, threshold) => if (got > threshold) true else {
  println("  assertion failed: " + __full_name(name));
  println("    expected: > " + ("" + threshold));
  println("    got: " + ("" + got));
  false
}

out fn expect_ge(name, got, threshold) => if (got > threshold || got == threshold) true else {
  println("  assertion failed: " + __full_name(name));
  println("    expected: >= " + ("" + threshold));
  println("    got: " + ("" + got));
  false
}

out fn it(name, ok) => {
  let full = __full_name(name);
  if (ok) {
    __passed = __passed + 1;
    println("ok  - " + full);
  } else {
    __failed = __failed + 1;
    println("not ok - " + full);
  }
}

out fn summary() => {
  println("passed: " + __passed);
  println("failed: " + __failed);
}

out fn status() => if (__failed == 0) 0 else 1
