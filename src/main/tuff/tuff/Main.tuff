from java::util::function use { Function };
from java::util::Map use { Entry };
from java::util::stream use { Collectors, Stream };
from java::io use { IOException };
from java::nio::file use { Files, Path, Paths };
from java::util use { ArrayList, Arrays, Collections, HashMap, List, Map, Optional };
from java::util::regex use { Pattern };
class fn Main() => {
	type Result<T, X> = Err<T, X> | Ok<T, X>;
	type TuffDeclarationOrPlaceholder = Placeholder | TuffDeclaration;
	
	type TuffExpression extends TuffLValue = WrappedExpression;
	type TuffLValue = Placeholder | TuffDeclaration | TuffExpression;
	type Folder = EscapedFolder | ExprEndFolder | StatementFolder | ValueFolder;
	class fn Err<T, X>(error : X) => {
	}
	class fn Ok<T, X>(value : T) => {
	}
	class fn TuffDeclaration(modifiers : List<String>, name : String, type : String) => {
	}
	class fn Placeholder(input : String) => {
	}
	class fn Tuple<Left, Right>(left : Left, right : Right) => {
	}
	class fn State(input : String, index : I32, buffer : StringBuilder, depth : I32, segments : ArrayList<String>) => {
		fn pop() : Optional<Tuple<State, U16>> => {
			if (this.index < this.input.length()) {
				let c = this.input.charAt(this.index);
				let state = State(this.input, this.index + 1, this.buffer, this.depth, this.segments);
				return Optional.of(Tuple<State, U16>(state, c));
			}
			return Optional.empty();
		}
		fn peek() : U16 => {
			return this.input.charAt(this.index);
		}
		fn append(c : U16) : State => {
			this.buffer.append(c);
			return this;
		}
		fn advance() : State => {
			this.segments.add(this.buffer.toString());
			return State(this.input, this.index, StringBuilder(), this.depth, this.segments);
		}
		fn exit() : State => {
			return State(this.input, this.index, this.buffer, this.depth - 1, this.segments);
		}
		fn enter() : State => {
			return State(this.input, this.index, this.buffer, this.depth + 1, this.segments);
		}
		fn isLevel() : boolean => {
			return this.depth == 0;
		}
		fn isShallow() : boolean => {
			return this.depth == 1;
		}
		fn stream() : Stream<String> => {
			return this.segments.stream();
		}
		fn popAndAppendToOption() : Optional<State> => {
			return this.pop().map((tuple : Tuple<State, U16>) => tuple.left.append(tuple.right));
		}
		fn popAndAppendToTuple() : Optional<Tuple<State, U16>> => {
			return this.pop().map((tuple : Tuple<State, U16>) => {
				let appended = tuple.left.append(tuple.right);
				return Tuple<State, U16>(appended, tuple.right);
			});
		}
	}
	class fn WrappedExpression(value : String) => {
	}
	class fn EscapedFolder(folder : Folder) => {
		fn foldSingleEscapeChar(tuple : Tuple<State, U16>) : State => {
			if (tuple.right == '\\') {
				return tuple.left.popAndAppendToOption().orElse(tuple.left);
			}
			else {
				return tuple.left;
			}
		}
		fn apply(state : State, next : U16) : State => {
			if (next == '\'') {
				let appended = state.append(next);
				return appended.popAndAppendToTuple().map(EscapedFolder::foldSingleEscapeChar).flatMap(State::popAndAppendToOption).orElse(appended);
			}
			return this.folder.apply(state, next);
		}
	}
	class fn StatementFolder() => {
		fn apply(state : State, character : U16) : State => {
			let appended = state.append(character);
			if (character == ';' && appended.isLevel()) {
				return appended.advance();
			}
			if (character == '}' && appended.isShallow()) {
				let appended1 = appended;
				let peeked = appended.peek();
				if (peeked == ';') {
					appended1 = appended.popAndAppendToOption().orElse(appended);
				}
				else {
					appended1 = appended1.advance();
				}
				return appended1.exit();
			}
			if (character == '{' || character == '(') {
				return appended.enter();
			}
			if (character == '}' || character == ')') {
				return appended.exit();
			}
			return appended;
		}
	}
	class fn ValueFolder() => {
		fn apply(state : State, character : U16) : State => {
			if (character == ',' && state.isLevel()) {
				return state.advance();
			}
			let appended = state.append(character);
			if (character == ' - ') {
				if (appended.peek() == '>') {
					let state1 = appended.popAndAppendToOption();
					if (state1.isPresent()) {
						return state1.get();
					}
				}
			}
			if (character == ' < ' || character == '(') {
				return appended.enter();
			}
			if (character == '>' || character == ')') {
				return appended.exit();
			}
			return appended;
		}
	}
	class fn ExprEndFolder() => {
		fn apply(state : State, c : U16) : State => {
			let appended = state.append(c);
			if (c == '(') {
				return appended.enter();
			}
			if (c == ')') {
				if (appended.isLevel()) {
					return appended.advance().exit();
				}
				return appended.exit();
			}
			return appended;
		}
	}
	let imports : Map<List<String>, List<String>> = HashMap<List<String>, List<String>>();
	fn main(args : *[String]) : Void => {
		Main().run().ifPresent(Throwable::printStackTrace);
	}
	fn run() : Optional<IOException> => {
		let source = Paths.get(".", "src", "main", "java", "tuff", "Main.java");
		let target = Paths.get(".", "src", "main", "tuff", "tuff", "Main.tuff");
		return match (this.readString(source)) {
			Err<String, IOException>(error) => Optional.of(error);
			Ok<String, IOException>(value) => {
				let output = this.compile(value);
				this.writeString(target, output)
			}
		};
	}
	expect fn writeString(target : Path, output : String) : Optional<IOException>;
	expect fn readString(source : Path) : Result<String, IOException>;
	fn compile(input : String) : String => {
		let compiled = this.compileStatements(input, this::compileRootSegment);
		let useStatements = this.imports.entrySet().stream().map((entry : Entry<List<String>, List<String>>) => {
			let usedNamespace = String.join("::", entry.getKey());
			let usedChildren = String.join(", ", entry.getValue());
			return "from " + usedNamespace + " use { " + usedChildren + " };" + System.lineSeparator();
		}).collect(Collectors.joining());
		return useStatements + compiled;
	}
	fn compileStatements(input : String, mapper : Function<String, String>) : String => {
		return this.divideStatements(input).map(mapper).collect(Collectors.joining());
	}
	fn divideStatements(input : String) : Stream<String> => {
		return this.divide(input, EscapedFolder(StatementFolder()));
	}
	fn divide(input : String, folder : Folder) : Stream<String> => {
		let segments = ArrayList<String>();
		let buffer = StringBuilder();
		let depth = 0;
		let i = 0;
		return this.getStringStream(State(input, i, buffer, depth, segments), folder);
	}
	fn getStringStream(state : State, folder : Folder) : Stream<String> => {
		let current = state;
		while (true) {
			let maybePopped = current.pop();
			if (maybePopped.isEmpty()) {
				break;
			}
			let popped = maybePopped.get();
			current = folder.apply(popped.left, popped.right);
		}
		return current.advance().stream();
	}
	fn compileRootSegment(input : String) : String => {
		let stripped = input.strip();
		if (stripped.startsWith("package ")) {
			return "";
		}
		if (stripped.startsWith("import ") && stripped.endsWith(";")) {
			let slice = stripped.substring("import ".length(), stripped.length() - 1);
			let copy = Arrays.asList(slice.split(Pattern.quote(".")));
			let namespace = copy.subList(0, copy.size() - 1);
			if (!this.imports.containsKey(namespace)) {
				this.imports.put(namespace, ArrayList<String>());
			}
			this.imports.get(namespace).add(copy.getLast());
			return "";
		}
		return this.compileRootSegmentValue(stripped) + System.lineSeparator();
	}
	fn compileRootSegmentValue(input : String) : String => {
		return this.compileStructure("class", input, 0).orElseGet(() => this.wrap(input));
	}
	class fn fn " + name + "(" + String.join(", ", parameters) + ") =>() => {
		Optional.empty() : /**/Optional.of(generated);
				}
			}
		}

		return/**/;
	}
	fn compileParameters(input : String) : List<String> => {
		return this.divideValues(input).map(String::strip).filter((slice : String) => !slice.isEmpty()).map(this::compileDefinitionOrPlaceholder).toList();
	}
	fn createIndent(indent : I32) : String => {
		return System.lineSeparator() + "\t".repeat(indent);
	}
	fn wrap(input : String) : String => {
		return "/**/" + input + "/**/";
	}
	fn compileStructureSegment(input : String, indent : I32) : String => {
		let stripped = input.strip();
		if (stripped.isEmpty()) {
			return "";
		}
		return this.createIndent(indent) + this.compileStructureSegmentValue(stripped, indent);
	}
	fn compileStructureSegmentValue(input : String, indent : I32) : String => {
		if (input.endsWith(";")) {
			let slice = input.substring(0, input.length() - 1);
			return this.compileClassStatement(slice, indent) + ";
			/**/";/**/
		}
		let i1 = input.indexOf("interface ");
		if (/**/i1 >= 0/**/) {
			let modifiers = Arrays.stream(input.substring(0, i1).split(Pattern.quote(" "))).map(String::strip).filter((slice : String) => !slice.isEmpty()).toList();
			let afterKeyword = input.substring(i1 + "interface ".length());
			if (modifiers.contains("sealed")) {
				let i = afterKeyword.indexOf("permits ");
				if (/**/i >= 0/**/) {
					let name = afterKeyword.substring(0, i).strip();
					let typeParameters : List<String> = ArrayList<String>();
					if (name.endsWith(">")) {
						let slice = name.substring(0, name.length() - 1);
						let i2 = slice.indexOf("<");
						if (/**/i2 >= 0/**/) {
							name = slice.substring(0, i2);
							typeParameters = Arrays.stream(slice.substring(i2 + 1).split(Pattern.quote(", "))).map(String::strip).filter((segment : String) => !segment.isEmpty()).toList();
						}
					}
					let stripped = afterKeyword.substring(i + "permits ".length()).strip();
					/**/final String joinedTypeParameters;/**/
					if (typeParameters.isEmpty()) {
						joinedTypeParameters = "";
					}
					else {
						joinedTypeParameters = "<" + String.join(", ", typeParameters) + ">";
					}
					/**/final var i2 = stripped.indexOf("{");
					if (i2 >= 0) {
						final var variants = Arrays
								.stream(stripped.substring(0, i2).split(Pattern.quote(",")))
								.map(String::strip)
								.filter((String slice) -> !slice.isEmpty())
								.map((String slice) -> slice + joinedTypeParameters)
								.collect(Collectors.joining(" | "));

						return "type " + name + joinedTypeParameters + " = " + variants + ";";
					}
				}/**/
				}
			}
			let maybeClass = this.compileStructure("class", input, indent);
			if (maybeClass.isPresent()) {
				return maybeClass.get();
			}
			let maybeRecord = this.compileStructure("record", input, indent);
			if (maybeRecord.isPresent()) {
				return maybeRecord.get();
			}
			/**/final var i = input.indexOf("(");
		if (i >= 0) {
			final var substring = input.substring(0, i);
			final var withParameters = input.substring(i + 1);
			final var i2 = withParameters.indexOf(")");
			if (i2 >= 0) {
				final var parameterString = withParameters.substring(0, i2);
				final var withBraces = withParameters.substring(i2 + 1).strip();
				final var declarationOrPlaceholder = this.parseDefinitionOrPlaceholderToTuff(substring);
				final var parameters = this.compileParameters(parameterString);

				if (declarationOrPlaceholder instanceof TuffDeclaration(var modifiers, var name, var type)) {
					if (withBraces.startsWith("{") && withBraces.endsWith("}")) {
						final var content = withBraces.substring(1, withBraces.length() - 1);
						final var joinedParameters = String.join(", ", parameters);

						final String outputContent;
						if (modifiers.contains("expect")) {
							outputContent = ";";
						} else {
							final var compiledContent = this.compileMethodStatements(content, indent);
							outputContent = " => {" + compiledContent + this.createIndent(indent) + "}";
						}

						return this.joinModifiers(modifiers) + "fn " + name + "(" + joinedParameters + ") : " + type +
									 outputContent;
					}
				}
			}
		}/**/
			if (input.contains("@interface")) {
				return "";
			}
			return this.wrap(input);
		}
		/**/private String compileMethodSegment(String input, int indent) {
		final var stripped = input.strip();
		if (stripped.isEmpty()) {
			return "";
		}

		return this.createIndent(indent) + this.compileMethodSegmentValue(stripped, indent);
	}/**/
		/**/private String compileMethodSegmentValue(String input, int indent) {
		final var stripped = input.strip();
		if (stripped.startsWith("yield ") && stripped.endsWith(";")) {
			final var substring = stripped.substring("yield ".length(), stripped.length() - 1);
			return this.compileExpressionOrPlaceholder(substring, indent);
		}

		final var maybeIf = this.compileConditional(indent, stripped, "if");
		if (maybeIf.isPresent()) {
			return maybeIf.get();
		}

		final var maybeWhile = this.compileConditional(indent, stripped, "while");
		if (maybeWhile.isPresent()) {
			return maybeWhile.get();
		}

		if (stripped.endsWith(";")) {
			final var slice = stripped.substring(0, stripped.length() - 1);
			final var maybeInitialization = this.compileMethodStatementValue(slice, indent);
			if (maybeInitialization.isPresent()) {
				return maybeInitialization.get() + ";";
			}
		}

		if (stripped.startsWith("else")) {
			final var slice = stripped.substring(4).strip();
			if (slice.startsWith("{") && slice.endsWith("}")) {
				final var substring = slice.substring(1, slice.length() - 1);
				return "else {" + this.compileMethodStatements(substring, indent) + this.createIndent(indent) + "}";
			}
		}

		return this.wrap(stripped);
	}/**/
		/**/private Optional<String> compileConditional(int indent, String input, String type) {
		if (input.startsWith(type)) {
			final var substring = input.substring(type.length()).strip();
			if (substring.startsWith("(")) {
				final var substring1 = substring.substring(1);
				final var divisions = this.findExprEnd(substring1);

				if (divisions.size() >= 2) {
					final var conditionStringWithSuffix = divisions.getFirst().strip();
					final var withBraces = String.join("", divisions.subList(1, divisions.size())).strip();
					if (conditionStringWithSuffix.endsWith(")")) {
						final var conditionString = conditionStringWithSuffix.substring(0, conditionStringWithSuffix.length() - 1);
						final var condition = this.compileExpressionOrPlaceholder(conditionString, indent);
						if (withBraces.startsWith("{") && withBraces.endsWith("}")) {
							final var content = withBraces.substring(1, withBraces.length() - 1);
							return Optional.of(type + " (" + condition + ") {" + this.compileMethodStatements(content, indent) +
																 this.createIndent(indent) + "}");
						}
					}
				}
			}
		}

		return Optional.empty();
	}/**/
		/**/private List<String> findExprEnd(String input) {
		return this.divide(input, new EscapedFolder(new ExprEndFolder())).toList();
	}/**/
		/**/private Optional<String> compileMethodStatementValue(String input, int indent) {
		if (input.equals("break") || input.equals("continue")) {
			return Optional.of(input);
		}

		if (input.startsWith("return ")) {
			final var substring = input.substring("return ".length());
			return Optional.of("return " + this.compileExpressionOrPlaceholder(substring, indent));
		}

		final var maybeInitialization = this.compileInitialization(input, indent);
		if (maybeInitialization.isPresent()) {
			return maybeInitialization;
		}

		return this.compileInvokable(input, indent);
	}/**/
		/**/private String compileClassStatement(String input, int indent) {
		return this.compileInitialization(input, indent).orElseGet(() -> this.compileDefinitionOrPlaceholder(input));
	}/**/
		/**/private Optional<String> compileInitialization(String input, int indent) {
		final var i = input.indexOf("=");
		if (i >= 0) {
			final var substring = input.substring(0, i);
			final var substring1 = input.substring(i + 1);
			final var string = this
					.parseDefinitionToTuff(substring)
					.<TuffLValue>map((TuffDeclaration value) -> value)
					.or(() -> this.parseExpression(substring, 0).<TuffLValue>map((TuffExpression value) -> value))
					.orElseGet(() -> new Placeholder(substring));

			return Optional.of(
					this.generateAssignable(string) + " = " + this.compileExpressionOrPlaceholder(substring1, indent));
		}

		return Optional.empty();
	}/**/
		/**/private String generateAssignable(TuffLValue value) {
		return switch (value) {
			case Placeholder placeholder -> this.wrap(placeholder.input);
			case TuffDeclaration tuffDeclaration -> "let " + this.generateDefinitionOrPlaceholder(tuffDeclaration);
			case TuffExpression tuffExpression -> this.generateExpression(tuffExpression);
		};
	}/**/
		/**/private String compileExpressionOrPlaceholder(String input, int indent) {
		return this.compileExpression(input, indent).orElseGet(() -> this.wrap(input.strip()));
	}/**/
		/**/private Optional<String> compileExpression(String input, int indent) {
		return this.parseExpression(input, indent).map(this::generateExpression);
	}/**/
		/**/private String generateExpression(TuffExpression expr) {
		return switch (expr) {
			case WrappedExpression(var value) -> value;
		};
	}/**/
		/**/private Optional<TuffExpression> parseExpression(String input, int indent) {
		return this.compileExpression0(input, indent).map(WrappedExpression::new);
	}/**/
		/**/private Optional<String> compileExpression0(String input, int indent) {
		final var i = input.indexOf("->");
		if (i >= 0) {
			final var beforeArrow = input.substring(0, i).strip();
			final var maybeWithBraces = input.substring(i + 2).strip();
			if (beforeArrow.startsWith("(") && beforeArrow.endsWith(")")) {
				final var substring = beforeArrow.substring(1, beforeArrow.length() - 1);
				final var compiled = String.join(", ", compileParameters(substring));
				final String compiled1;
				if (maybeWithBraces.startsWith("{") && maybeWithBraces.endsWith("}")) {
					final var body = maybeWithBraces.substring(1, maybeWithBraces.length() - 1);
					compiled1 = "{" + this.compileMethodStatements(body, indent) + this.createIndent(indent) + "}";
				} else {
					compiled1 = this.compileExpressionOrPlaceholder(maybeWithBraces, indent);
				}

				return Optional.of("(" + compiled + ")" + " => " + compiled1);
			}
		}

		final var stripped = input.strip();
		if (stripped.startsWith("!")) {
			final var substring = stripped.substring(1);
			return Optional.of("!" + this.compileExpressionOrPlaceholder(substring, indent));
		}

		return this
				.compileInvokable(input, indent)
				.or(() -> this.compileString(input))
				.or(() -> this.compileSwitch(input, indent))
				.or(() -> this.compileAccess(input, indent, "."))
				.or(() -> this.compileOperation(indent, input, "<"))
				.or(() -> this.compileOperation(indent, input, "+"))
				.or(() -> this.compileOperation(indent, input, "-"))
				.or(() -> this.compileOperation(indent, input, "=="))
				.or(() -> this.compileOperation(indent, input, "&&"))
				.or(() -> this.compileOperation(indent, input, "||"))
				.or(() -> this.compileAccess(input, indent, "::"))
				.or(() -> this.compileIdentifier(input))
				.or(() -> this.compileNumber(input))
				.or(() -> this.compileChar(input));
	}/**/
		let stripped = /**/input.strip();
		if/**/(/**/stripped.startsWith("'""/**/) && /**/stripped.endsWith("'")) {
			return Optional.of(stripped);
		} else {
			return Optional.empty();
		}
	}

	private Optional/**/ < /**/String> compileAccess(String input, int indent, String separator) {
		return this/**/.compileAccess(input, separator, /**/(String input1/**/) - /**/> this.compileAccessInstance(indent, input1));
	}

	private String compileAccessInstance(int indent, String input) {
		return Main.this.compileType(input).orElseGet(/**/() - /**/> this.compileExpressionOrPlaceholder(input, indent));
	}

	private Optional/**/ < /**/String> compileNumber(String input) {
		final var stripped = input.strip();
		if (this.isNumber(stripped)) {
			return Optional.of(stripped);
		}

		return Optional.empty();
	}

	private boolean isNumber(String input) {
		for (var i = 0; i/**/ < /**/input.length(); i/**/ +  + /**/) {
			final var c = input.charAt(i);
			if (Character.isDigit(c)) {
				continue;
			}
			return false;
		}
		return true;
	}

	private Optional/**/ < /**/String> compileOperation(int indent, String input, String operator) {
		final var i1 = input.indexOf(operator);
		if (i1 >= 0) {
			final var substring = input.substring(0, i1);
			final var substring1 = input.substring(i1/**/ + /**/operator.length());
			return Optional.of(this/**/.compileExpressionOrPlaceholder(substring, indent) + " " + operator + " " + /**/this.compileExpressionOrPlaceholder(substring1, indent));
		} else {
			return Optional.empty();
		}
	}

	private Optional/**/ < /**/String> compileSwitch(String input, int indent) {
		final var stripped = input.strip();
		if (stripped.startsWith("switch")) {
			final var substring = stripped.substring("switch".length()).strip();
			if (substring.startsWith("(")) {
				final var withExpr = substring.substring(1);
				final var divisions = this.findExprEnd(withExpr);

				if (divisions.size() >= 2) {
					final var exprWithSuffix = divisions.getFirst();
					final var withBraces = String.join("", divisions.subList(1, divisions.size())).strip();

					if (exprWithSuffix.endsWith(")")) {
						final var expr = exprWithSuffix/**/.substring(0, /**/exprWithSuffix.length(/**/) - /**/1);
						final var compiledExpr = this.compileExpressionOrPlaceholder(expr, indent);
						if (withBraces/**/.startsWith("{") && /**/withBraces.endsWith("}")) {
							final var content = withBraces.substring(1, withBraces/**/.length() - /**/1);
							final var collect = this
									.divideStatements(content)
									.map(String::strip)
									.filter(/**/(/**/String slice/**/) - /**/> !slice.isEmpty())
									.map(/**/(/**/String input1/**/) - /**/> this.compileCase(input1, indent/**/ + /**/1))
									.map((String slice)/**/ - /**/> this.createIndent(indent/**/ + /**/1)/**/ + /**/slice)
									.collect(Collectors.joining());

							return Optional.of("match ("/**/ + compiledExpr + ") {" + collect + this.createIndent(indent) + "}");
						}
					}
				}
			}
		}

		return Optional.empty();
	}

	private String compileCase(String input, int indent) {
		final var stripped = input.strip();
		if (stripped.startsWith("case ")) {
			final var substring = stripped.substring("case ".length());
			final var i = substring.indexOf(" - /**/>");
			if (i >= 0) {
				final var substring1 = substring.substring(0, i);
				final var substring2 = substring.substring(i/**/ + "->".length(/**/));
				return this.compileDestructuring(substring1/**/) + " => " + /**/this.compileCaseValue(substring2, indent);
			}
		}

		return this.wrap(stripped);
	}

	private String compileDestructuring(String input) {
		// I'm lazy to do this properly.
		return input.replace("var ", "").strip();
	}

	private String compileCaseValue(String input, int indent) {
		final var stripped = input.strip();
		if (stripped.endsWith(";")) {
			final var substring = stripped/**/.substring(0, /**/stripped.length(/**/) - /**/1);
			return this/**/.compileExpressionOrPlaceholder(substring, indent) + ";";
		}

		if (stripped.startsWith("{") && stripped.endsWith("}")) {
			final var substring = stripped.substring(1, stripped.length() - 1);
			final var compiled = this.compileMethodStatements(substring, indent);
			return "{" + compiled + this.createIndent(indent) + /**/"}";
		}

		return this.wrap(stripped);
	}

	private String compileMethodStatements(String input, int indent) {
		return this/**/.compileStatements(input, /**/(String segment/**/) - /**/> this.compileMethodSegment(segment, indent/**/ + /**/1));
	}

	private Optional/**/ < /**/String> compileString(String input) {
		final var stripped = input.strip();
		if/**/(/**/stripped.startsWith("\""/**/) && /**/stripped.endsWith("\"")) {
			return Optional.of(stripped);
		} else {
			return Optional.empty();
		}
	}

	private Optional/**/ < /**/String> compileIdentifier(String input) {
		final var stripped = input.strip();
		if (this.isIdentifier(stripped)) {
			return Optional.of(stripped);
		} else {
			return Optional.empty();
		}
	}

	private Optional/**/ < /**/String> compileAccess(String input, String separator, Function/**/ < /**/String, String> mapper) {
		final var i = input.lastIndexOf(separator);
		if (i >= 0) {
			final var substring = input.substring(0, i);
			final var memberName = input.substring(i/**/ + /**/separator.length()).strip();
			if (this.isIdentifier(memberName)) {
				return Optional.of(mapper/**/.apply(substring) + separator + /**/memberName);
			}
		}

		return Optional.empty();
	}

	private Optional/**/ < /**/String> compileInvokable(String input, int indent) {
		final var stripped = input.strip();
		if (stripped.endsWith(")")) {
			final var withoutEnd = stripped.substring(0, stripped/**/.length() - /**/1);

			var i =/**/ - /**/1;
			var depth = 0;
			for (var i1 = 0; i1/**/ < /**/withoutEnd.length(); i1/**/ +  + /**/) {
				final var c = withoutEnd.charAt(i1);
				if (c/**/ == /**/'(') {
					if (depth/**/ == /**/0) {
						i = i1;
					}
					depth/**/ +  + /**/;
				}
				if (c/**/ == /**/')') {
					depth/**/ -  - /**/;
				}
			}

			if (i >= 0) {
				final var caller = withoutEnd.substring(0, i);
				final var arguments = withoutEnd.substring(i/**/ + /**/1);
				final var joinedArguments = this
						.divideValues(arguments)
						.map(String::strip)
						.filter(/**/(/**/String slice/**/) - /**/> !slice.isEmpty())
						.map(/**/(/**/String input1/**/) - /**/> this.compileExpressionOrPlaceholder(input1, indent))
						.collect(Collectors.joining(", "));

				return Optional.of(this/**/.compileCaller(caller, indent) + "(" + joinedArguments + /**/")");
			}
		}

		return Optional.empty();
	}

	private Stream/**/ < /**/String> divideValues(String input) {
		return this.divide(input, new EscapedFolder(new ValueFolder()));
	}

	private String compileCaller(String input, int indent) {
		final var stripped = input.strip();
		if (stripped.startsWith("new ")) {
			final var substring = stripped.substring("new ".length());
			final var maybeType = this.compileType(substring);
			if (maybeType.isPresent()) {
				return maybeType.get();
			}
		}

		final var maybeExpression = this.compileExpression(input, indent);
		if (maybeExpression.isPresent()) {
			return maybeExpression.get();
		}

		if (stripped.startsWith("new ")) {
			final var substring = stripped.substring("new ".length());
			return this.compileTypeOrPlaceholder(substring);
		}

		return this.wrap(stripped);
	}

	private String compileDefinitionOrPlaceholder(String input) {
		return this.generateDefinitionOrPlaceholder(this.parseDefinitionOrPlaceholderToTuff(input));
	}

	private String generateDefinitionOrPlaceholder(TuffDeclarationOrPlaceholder string) {
		return switch (string) {
			case TuffDeclaration/**/(/**/var modifiers/**/, /**/var name/**/, /**/var type/**/) - /**/> {
				if (type.equals("var")) {
					yield name;
				}

				final var joinedModifiers = this.joinModifiers(modifiers);
				yield joinedModifiers/**/ + name + " : " + /**/type;
			}
			case Placeholder placeholder/**/ - /**/> this.wrap(placeholder.input);
		};
	}

	private String joinModifiers(List/**/ < /**/String> modifiers) {
		return modifiers.stream().map(/**/(/**/String modifier/**/) - /**/> modifier/**/ + /**/" ").collect(Collectors/**/.joining(/**/));
	}

	private TuffDeclarationOrPlaceholder parseDefinitionOrPlaceholderToTuff(String input) {
		return this
				.parseDefinitionToTuff(input/**/). < /**/TuffDeclarationOrPlaceholder>map/**/(/**/(TuffDeclaration value/**/) - /**/> value)
				.orElseGet(/**/() - /**/> new Placeholder(input));
	}

	private Optional/**/ < /**/TuffDeclaration> parseDefinitionToTuff(String input) {
		final var stripped = input.strip();
		final var i = stripped.lastIndexOf(" ");
		if (i >= 0) {
			final var beforeName = stripped.substring(0, i);
			final var name = stripped.substring(i/**/ + /**/1);
			final var i1 = this.findTypeSeparator(beforeName);
			if (i1/**/ < /**/0) {
				final var compiled = this.compileTypeOrPlaceholder(beforeName);
				return Optional.of(new TuffDeclaration(new ArrayList/**/ < /**/String>(), name, compiled));
			}

			final var beforeType = beforeName.substring(0, i1);
			final var i2 = beforeType.lastIndexOf("\n");
			List/**/ < /**/String> annotations = new ArrayList/**/ < /**/String>();
			if (i2 >= 0) {
				final var substring = beforeType.substring(0, i2);
				annotations = Arrays/**/.stream(substring.split(Pattern.quote(" "))).map(String::strip).filter(/**/(String slice/**/) - /**/> !slice.isEmpty())
						.map(/**/(/**/String slice/**/) - /**/> slice.substring(1))
						.toList();
			}

			final var type = beforeName.substring(i1/**/ + /**/1);
			final var compiled = this.compileTypeOrPlaceholder(type);
			final List/**/ < /**/String> modifiers;
			if (annotations.contains("Actual")) {
				modifiers = List.of("expect");
			} else {
				modifiers = Collections.emptyList();
			}

			return Optional.of(new TuffDeclaration(modifiers, name, compiled));

		}

		return Optional.empty();
	}

	private String compileTypeOrPlaceholder(String input) {
		return this/**/.compileType(input).orElseGet(/**/(/**/) - /**/> this.wrap(input));
	}

	private Optional/**/ < /**/String> compileType(String input) {
		final var stripped = input.strip();
		final var maybePrimitiveType = this.compilePrimitiveType(stripped);
		if (maybePrimitiveType.isPresent()) {
			return maybePrimitiveType;
		}

		final var i = stripped.indexOf("/**/ < ");
		if (i >= 0) {
			final var base = stripped.substring(0, i);
			final var substring1 = stripped.substring(i + 1).strip();
			if (substring1.endsWith(">")) {
				final var args = substring1.substring(0, substring1.length() - 1);
				final var joinedTypeArguments =
						this.divideValues(args).map(this::compileTypeOrPlaceholder).collect(Collectors.joining(", "));

				return Optional.of(base + " < " + joinedTypeArguments + ">");
			}
		}

		if (this.isIdentifier(stripped)) {
			return Optional.of(stripped);
		}

		if (stripped.endsWith("[]")) {
			final var substring = stripped.substring(0, stripped.length() - 2);
			return Optional.of("*[" + substring + /**/"]");
		}

		return Optional.empty();
	}

	private Optional/**/ < /**/String> compilePrimitiveType(String stripped) {
		switch (stripped) {
			case "char", "Character"/**/ - /**/> {
				return Optional.of("U16");
			}
			case "int"/**/ - /**/> {
				return Optional.of("I32");
			}
			case "void"/**/ - /**/> {
				return Optional.of("Void");
			}
		}

		return Optional.empty();
	}

	private boolean isIdentifier(String input) {
		final var stripped = input.strip();
		for (var i = 0; i/**/ < /**/stripped.length(); i/**/ +  + /**/) {
			final var c = stripped.charAt(i);
			if (Character/**/.isLetter(c) || /**/(i != 0/**/ && /**/Character.isDigit(c))) {continue;}
			return false;
		}
		return true;
	}

	private int findTypeSeparator(String beforeName) {
		var i1 =/**/ - /**/1;
		var depth = 0;
		for (var i2 = 0; i2/**/ < /**/beforeName.length(); i2/**/ +  + /**/) {
			final var c = beforeName.charAt(i2);
			if (c/**/ == ' ' && depth == /**/0) {
				i1 = i2;
			}
			if (c/**/ == ' < /**/') {
				depth/**/ +  + /**/;
			}
			if (c/**/ == /**/'>') {
				depth/**/ -  - /**/;
			}
		}
		return i1/**/;
	}
}
