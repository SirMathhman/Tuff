from java::util::function use { Function };
from java::util::Map use { Entry };
from java::util::stream use { Collectors, IntStream, Stream };
from java::io use { IOException };
from java::nio::file use { Files, Path, Paths };
from java::util use { ArrayList, Arrays, HashMap, List, Map, Optional };
from java::util::regex use { Pattern };
class fn Main() => {
	type Result<T, X> = Err<T, X> | Ok<T, X>;
	type TuffDeclarationOrPlaceholder = Placeholder | TuffDeclaration;
	
	type TuffExpression extends TuffLValue = WrappedExpression;
	type TuffLValue = Placeholder | TuffDeclaration | TuffExpression;
	type Folder = EscapedFolder | ExprEndFolder | OperationFolder | StatementFolder | ValueFolder;
	class fn Err<T, X>(error : X) => {
	}
	class fn Ok<T, X>(value : T) => {
	}
	class fn TuffDeclaration(modifiers : List<String>, name : String, type : String, isMutable : boolean) => {
		fn toggleMutable() : TuffDeclarationOrPlaceholder => {
			return TuffDeclaration(this.modifiers, this.name, this.type, !this.isMutable);
		}
	}
	class fn Placeholder(input : String) => {
	}
	class fn Tuple2<A, B>(a : A, b : B) => {
	}
	class fn Tuple3<A, B, C>(a : A, b : B, c : C) => {
	}
	class fn State(input : String, index : I32, buffer : StringBuilder, depth : I32, segments : ArrayList<String>) => {
		fn pop() : Optional<Tuple2<State, U16>> => {
			if (this.index < this.input.length()) {
				let c = this.input.charAt(this.index);
				let state = State(this.input, this.index + 1, this.buffer, this.depth, this.segments);
				return Optional.of(Tuple2<State, U16>(state, c));
			}
			return Optional.empty();
		}
		fn append(c : U16) : State => {
			return State(this.input, this.index, this.buffer.append(c), this.depth, this.segments);
		}
		fn advance() : State => {
			this.segments.add(this.buffer.toString());
			return State(this.input, this.index, StringBuilder(), this.depth, this.segments);
		}
		fn exit() : State => {
			return State(this.input, this.index, this.buffer, this.depth - 1, this.segments);
		}
		fn enter() : State => {
			return State(this.input, this.index, this.buffer, this.depth + 1, this.segments);
		}
		fn isLevel() : boolean => {
			return this.depth == 0;
		}
		fn isShallow() : boolean => {
			return this.depth == 1;
		}
		fn stream() : Stream<String> => {
			return this.segments.stream();
		}
		fn popAndAppendToOption() : Optional<State> => {
			return this.pop().map((tuple : Tuple2<State, U16>) => tuple.a.append(tuple.b));
		}
		fn popAndAppendToTuple() : Optional<Tuple2<State, U16>> => {
			return this.pop().map((tuple : Tuple2<State, U16>) => {
				let appended = tuple.a.append(tuple.b);
				return Tuple2<State, U16>(appended, tuple.b);
			});
		}
		fn startsWith(slice : String) : boolean => {
			if (slice.length() > this.input.length()) {
				return false;
			}
			let min = Math.min(this.index + slice.length(), this.input.length());
			let window = this.input.substring(this.index, min);
			return window.equals(slice);
		}
	}
	class fn WrappedExpression(value : String) => {
	}
	class fn EscapedFolder(folder : Folder) => {
		fn foldSingleEscapeChar(tuple : Tuple2<State, U16>) : State => {
			if (tuple.b == '\\') {
				return tuple.a.popAndAppendToOption().orElse(tuple.a);
			}
			else {
				return tuple.a;
			}
		}
		fn apply(state : State, next : U16) : State => {
			return this.foldQuotes(state, next).orElseGet(() => this.folder.apply(state, next));
		}
		fn foldQuotes(state : State, next : U16) : Optional<State> => {
			if (next != '\'' && next != '\"') {
				return Optional.empty();
			}
			let appended = state.append(next);
			if (next == '\"') {
				let value = this.foldDoubleQuotes(appended);
				return Optional.of(value);
			}
			return Optional.of(this.foldSingleQuotes(appended));
		}
		fn foldSingleQuotes(appended : State) : State => {
			return appended.popAndAppendToTuple().map(EscapedFolder::foldSingleEscapeChar).flatMap(State::popAndAppendToOption).orElse(appended);
		}
		fn foldDoubleQuotes(appended : State) : State => {
			let mut current = Tuple2<Boolean, State>(true, appended);
			while (current.a) {
				current = this.foldInDoubleQuote(current.b);
			}
			return current.b;
		}
		fn foldInDoubleQuote(state : State) : Tuple2<Boolean, State> => {
			let maybeTuple = state.popAndAppendToTuple();
			if (maybeTuple.isEmpty()) {
				return Tuple2<Boolean, State>(false, state);
			}
			let tuple = maybeTuple.get();
			let mut appended = tuple.a;
			let withinQuotes = tuple.b;
			if (withinQuotes == '\\') {
				appended = appended.popAndAppendToOption().orElse(appended);
			}
			if (withinQuotes == '\"') {
				return Tuple2<Boolean, State>(false, appended);
			}
			return Tuple2<Boolean, State>(true, appended);
		}
	}
	class fn StatementFolder() => {
		fn apply(state : State, character : U16) : State => {
			let appended = state.append(character);
			if (character == ';' && appended.isLevel()) {
				return appended.advance();
			}
			if (character == '}' && appended.isShallow()) {
				let appended1 = this.foldTrailingSemicolon(appended);
				return appended1.exit();
			}
			if (character == '{' || character == '(') {
				return appended.enter();
			}
			if (character == '}' || character == ')') {
				return appended.exit();
			}
			return appended;
		}
		fn foldTrailingSemicolon(state : State) : State => {
			if (state.startsWith(";")) {
				return state.popAndAppendToOption().orElse(state);
			}
			return state.advance();
		}
	}
	class fn ValueFolder() => {
		fn apply(state : State, character : U16) : State => {
			if (character == ',' && state.isLevel()) {
				return state.advance();
			}
			let appended = state.append(character);
			let maybeArrow = this.foldArrow(appended, character);
			if (maybeArrow.isPresent()) {
				return maybeArrow.get();
			}
			if (character == '<' || character == '(') {
				return appended.enter();
			}
			if (character == '>' || character == ')') {
				return appended.exit();
			}
			return appended;
		}
		fn foldArrow(state : State, character : U16) : Optional<State> => {
			if (character != '-') {
				return Optional.empty();
			}
			if (!state.startsWith(">")) {
				return Optional.empty();
			}
			return state.popAndAppendToOption();
		}
	}
	class fn ExprEndFolder() => {
		fn apply(state : State, c : U16) : State => {
			let appended = state.append(c);
			if (c == '(') {
				return appended.enter();
			}
			if (c == ')') {
				return foldClosingParentheses(appended);
			}
			return appended;
		}
	}
	class fn OperationFolder(operator : String) => {
		fn apply(state : State, next : U16) : State => {
			let appended = state.append(next);
			if (appended.startsWith(this.operator) && state.isLevel()) {
				return this.foldOverOperator(appended);
			}
			if (next == '(') {
				return appended.enter();
			}
			if (next == ')') {
				return appended.exit();
			}
			return appended;
		}
		fn foldOverOperator(appended : State) : State => {
			let mut current = appended;
			let mut i = 0;
			while (i < this.operator.length()) {
				current = current.popAndAppendToOption().orElse(current);
				i++;
			}
			return current.advance();
		}
	}
	let imports : Map<List<String>, List<String>> = HashMap<List<String>, List<String>>();
	fn foldClosingParentheses(appended : State) : State => {
		if (appended.isLevel()) {
			return appended.advance().exit();
		}
		return appended.exit();
	}
	fn main(args : *[String]) : Void => {
		Main().run().ifPresent(Throwable::printStackTrace);
	}
	fn run() : Optional<IOException> => {
		let source = Paths.get(".", "src", "main", "java", "tuff", "Main.java");
		let target = Paths.get(".", "src", "main", "tuff", "tuff", "Main.tuff");
		return match (this.readString(source)) {
			Err<String, IOException>(error) => Optional.of(error);
			Ok<String, IOException>(value) => {
				let output = this.compile(value);
				this.writeString(target, output)
			}
		};
	}
	expect fn writeString(target : Path, output : String) : Optional<IOException>;
	expect fn readString(source : Path) : Result<String, IOException>;
	fn compile(input : String) : String => {
		let compiled = this.compileStatements(input, this::compileRootSegment);
		let useStatements = this.imports.entrySet().stream().map((entry : Entry<List<String>, List<String>>) => {
			let usedNamespace = String.join("::", entry.getKey());
			let usedChildren = String.join(", ", entry.getValue());
			return "from " + usedNamespace + " use { " + usedChildren + " };" + System.lineSeparator();
		}).collect(Collectors.joining());
		return useStatements + compiled;
	}
	fn compileStatements(input : String, mapper : Function<String, String>) : String => {
		return this.divideStatements(input).map(mapper).collect(Collectors.joining());
	}
	fn divideStatements(input : String) : Stream<String> => {
		return this.divide(input, EscapedFolder(StatementFolder()));
	}
	fn divide(input : String, folder : Folder) : Stream<String> => {
		let segments = ArrayList<String>();
		let mut buffer = StringBuilder();
		let mut depth = 0;
		let mut i = 0;
		return this.getStringStream(State(input, i, buffer, depth, segments), folder);
	}
	fn getStringStream(state : State, folder : Folder) : Stream<String> => {
		let mut current = state;
		while (true) {
			let maybePopped = current.pop();
			if (maybePopped.isEmpty()) {
				break;
			}
			let popped = maybePopped.get();
			current = folder.apply(popped.a, popped.b);
		}
		return current.advance().stream();
	}
	fn compileRootSegment(input : String) : String => {
		let stripped = input.strip();
		if (stripped.isEmpty()) {
			return "";
		}
		if (stripped.startsWith("package ")) {
			return "";
		}
		if (stripped.startsWith("import ") && stripped.endsWith(";")) {
			let slice = stripped.substring("import ".length(), stripped.length() - 1);
			let copy = Arrays.asList(slice.split(Pattern.quote(".")));
			let namespace = copy.subList(0, copy.size() - 1);
			if (!this.imports.containsKey(namespace)) {
				this.imports.put(namespace, ArrayList<String>());
			}
			this.imports.get(namespace).add(copy.getLast());
			return "";
		}
		return this.compileRootSegmentValue(stripped) + System.lineSeparator();
	}
	fn compileRootSegmentValue(input : String) : String => {
		return this.compileStructure("class", input, 0).orElseGet(() => this.wrap(input));
	}
	fn compileStructure(type : String, input : String, indent : I32) : Optional<String> => {
		let i = input.indexOf(type + " ");
		if (i < 0) {
			return Optional.empty();
		}
		let afterKeyword = input.substring(i + (type + " ").length());
		let i1 = afterKeyword.indexOf("{");
		if (i1 < 0) {
			return Optional.empty();
		}
		let mut name = afterKeyword.substring(0, i1).strip();
		let i2 = name.indexOf("implements ");
		if (i2 >= 0) {
			name = name.substring(0, i2).strip();
		}
		let mut parameters : List<String> = ArrayList<String>();
		if (name.endsWith(")")) {
			let withParameters = name.substring(0, name.length() - 1).strip();
			let i3 = withParameters.indexOf("(");
			if (i3 >= 0) {
				name = withParameters.substring(0, i3).strip();
				let substring = withParameters.substring(i3 + 1);
				parameters = this.compileParameters(substring);
			}
		}
		let mut typeParameters : List<String> = ArrayList<String>();
		if (name.endsWith(">")) {
			let stripped = name.substring(0, name.length() - 1).strip();
			let i3 = stripped.indexOf("<");
			if (i3 >= 0) {
				name = stripped.substring(0, i3).strip();
				typeParameters = Arrays.stream(stripped.substring(i3 + 1).split(Pattern.quote(","))).map(String::strip).filter((slice : String) => !slice.isEmpty()).toList();
			}
		}
		let substring1 = afterKeyword.substring(i1 + 1).strip();
		if (substring1.endsWith("}")) {
			let body = substring1.substring(0, substring1.length() - 1);
			if (this.isIdentifier(name)) {
				let compiled = this.compileStatements(body, (input1 : String) => this.compileStructureSegment(input1, indent + 1));
				let joinedTypeParameters = this.joinTypeParameters(typeParameters);
				let generated = "class fn " + name + joinedTypeParameters + "(" + String.join(", ", parameters) + ") => {" + compiled +
						this.createIndent(indent) + "}";
				return Optional.of(generated);
			}
		}
		return Optional.empty();
	}
	fn joinTypeParameters(typeParameters : List<String>) : String => {
		joinedTypeParameters : String
		if (typeParameters.isEmpty()) {
			joinedTypeParameters = "";
		}
		else {
			joinedTypeParameters = "<" + String.join(", ", typeParameters) + ">";
		}
		return joinedTypeParameters;
	}
	fn compileParameters(input : String) : List<String> => {
		return this.divideValues(input).map(String::strip).filter((slice : String) => !slice.isEmpty()).map(this::parseDefinitionOrPlaceholderToTuff).map(this::transformParameter).map(this::generateDefinitionOrPlaceholder).toList();
	}
	fn transformParameter(node : TuffDeclarationOrPlaceholder) : TuffDeclarationOrPlaceholder => {
		return match (node) {
			Placeholder placeholder => placeholder;
			TuffDeclaration tuffDeclaration => tuffDeclaration.toggleMutable();
		};
	}
	fn createIndent(indent : I32) : String => {
		return System.lineSeparator() + "\t".repeat(indent);
	}
	fn wrap(input : String) : String => {
		return "/**/" + input + "/**/";
	}
	fn compileStructureSegment(input : String, indent : I32) : String => {
		let stripped = input.strip();
		if (stripped.isEmpty()) {
			return "";
		}
		return this.createIndent(indent) + this.compileStructureSegmentValue(stripped, indent);
	}
	fn compileStructureSegmentValue(input : String, indent : I32) : String => {
		if (input.endsWith(";")) {
			let slice = input.substring(0, input.length() - 1);
			return this.compileClassStatement(slice, indent) + ";";
		}
		let maybeInterface = this.compileSealedInterface(input);
		if (maybeInterface.isPresent()) {
			return maybeInterface.get();
		}
		let maybeClass = this.compileStructure("class", input, indent);
		if (maybeClass.isPresent()) {
			return maybeClass.get();
		}
		let maybeRecord = this.compileStructure("record", input, indent);
		if (maybeRecord.isPresent()) {
			return maybeRecord.get();
		}
		let modifiers = this.compileMethod(input, indent);
		if (modifiers.isPresent()) {
			return modifiers.get();
		}
		if (input.contains("@interface")) {
			return "";
		}
		return this.wrap(input);
	}
	fn compileSealedInterface(input : String) : Optional<String> => {
		let i1 = input.indexOf("interface ");
		if (i1 < 0) {
			return Optional.empty();
		}
		let modifiers = Arrays.stream(input.substring(0, i1).split(Pattern.quote(" "))).map(String::strip).filter((slice : String) => !slice.isEmpty()).toList();
		let afterKeyword = input.substring(i1 + "interface ".length());
		if (!modifiers.contains("sealed")) {
			return Optional.empty();
		}
		let i = afterKeyword.indexOf("permits ");
		if (i < 0) {
			return Optional.empty();
		}
		let mut name = afterKeyword.substring(0, i).strip();
		let mut typeParameters : List<String> = ArrayList<String>();
		if (name.endsWith(">")) {
			let slice = name.substring(0, name.length() - 1);
			let i2 = slice.indexOf("<");
			if (i2 >= 0) {
				name = slice.substring(0, i2);
				typeParameters = Arrays.stream(slice.substring(i2 + 1).split(Pattern.quote(","))).map(String::strip).filter((segment : String) => !segment.isEmpty()).toList();
			}
		}
		let stripped = afterKeyword.substring(i + "permits ".length()).strip();
		joinedTypeParameters : String
		if (typeParameters.isEmpty()) {
			joinedTypeParameters = "";
		}
		else {
			joinedTypeParameters = "<" + String.join(", ", typeParameters) + ">";
		}
		let i2 = stripped.indexOf("{");
		if (i2 >= 0) {
			let variants = Arrays.stream(stripped.substring(0, i2).split(Pattern.quote(","))).map(String::strip).filter((slice : String) => !slice.isEmpty()).map((slice : String) => slice + joinedTypeParameters).collect(Collectors.joining(" | "));
			return Optional.of("type " + name + joinedTypeParameters + " = " + variants + ";");
		}
		return Optional.empty();
	}
	fn compileMethod(input : String, indent : I32) : Optional<String> => {
		let i = input.indexOf("(");
		if (i < 0) {
			return Optional.empty();
		}
		let substring = input.substring(0, i);
		let withParameters = input.substring(i + 1);
		let i2 = withParameters.indexOf(")");
		if (i2 < 0) {
			return Optional.empty();
		}
		let parameterString = withParameters.substring(0, i2);
		let withBraces = withParameters.substring(i2 + 1).strip();
		let declarationOrPlaceholder = this.parseDefinitionOrPlaceholderToTuff(substring);
		let parameters = this.compileParameters(parameterString);
		if (!(declarationOrPlaceholder is TuffDeclaration { modifiers, name, type, isMutable })) {
			return Optional.empty();
		}
		if (!withBraces.startsWith("{") || !withBraces.endsWith("}")) {
			return Optional.empty();
		}
		let content = withBraces.substring(1, withBraces.length() - 1);
		let joinedParameters = String.join(", ", parameters);
		outputContent : String
		if (modifiers.contains("expect")) {
			outputContent = ";";
		}
		else {
			let compiledContent = this.compileMethodStatements(content, indent);
			outputContent = " => {" + compiledContent + this.createIndent(indent) + "}";
		}
		return Optional.of(this.joinModifiers(modifiers) + "fn " + name + "(" + joinedParameters + ") : " + type + outputContent);
	}
	fn compileMethodSegment(input : String, indent : I32) : String => {
		let stripped = input.strip();
		if (stripped.isEmpty()) {
			return "";
		}
		return this.createIndent(indent) + this.compileMethodSegmentValue(stripped, indent);
	}
	fn compileMethodSegmentValue(input : String, indent : I32) : String => {
		let stripped = input.strip();
		if (stripped.startsWith("yield ") && stripped.endsWith(";")) {
			let substring = stripped.substring("yield ".length(), stripped.length() - 1);
			return this.compileExpressionOrPlaceholder(substring, indent);
		}
		let maybeIf = this.compileConditional(indent, stripped, "if");
		if (maybeIf.isPresent()) {
			return maybeIf.get();
		}
		let maybeWhile = this.compileConditional(indent, stripped, "while");
		if (maybeWhile.isPresent()) {
			return maybeWhile.get();
		}
		if (stripped.endsWith(";")) {
			let slice = stripped.substring(0, stripped.length() - 1);
			let maybeInitialization = this.compileMethodStatementValue(slice, indent);
			if (maybeInitialization.isPresent()) {
				return maybeInitialization.get() + ";";
			}
			let maybeDefinition = this.parseDefinitionToTuff(slice);
			if (maybeDefinition.isPresent()) {
				return this.generateDefinitionOrPlaceholder(maybeDefinition.get());
			}
		}
		if (stripped.startsWith("else")) {
			let slice = stripped.substring(4).strip();
			if (slice.startsWith("{") && slice.endsWith("}")) {
				let substring = slice.substring(1, slice.length() - 1);
				return "else {" + this.compileMethodStatements(substring, indent) + this.createIndent(indent) + "}";
			}
		}
		return this.wrap(stripped);
	}
	fn compileConditional(indent : I32, input : String, type : String) : Optional<String> => {
		if (!input.startsWith(type)) {
			return Optional.empty();
		}
		let substring = input.substring(type.length()).strip();
		if (!substring.startsWith("(")) {
			return Optional.empty();
		}
		let substring1 = substring.substring(1);
		let divisions = this.findExprEnd(substring1);
		if (divisions.size() < 2) {
			return Optional.empty();
		}
		let conditionStringWithSuffix = divisions.getFirst().strip();
		let withBraces = String.join("", divisions.subList(1, divisions.size())).strip();
		if (!conditionStringWithSuffix.endsWith(")")) {
			return Optional.empty();
		}
		let conditionString = conditionStringWithSuffix.substring(0, conditionStringWithSuffix.length() - 1);
		let condition = this.compileExpressionOrPlaceholder(conditionString, indent);
		if (!withBraces.startsWith("{") || !withBraces.endsWith("}")) {
			return Optional.empty();
		}
		let content = withBraces.substring(1, withBraces.length() - 1);
		return Optional.of(type + " (" + condition + ") {" + this.compileMethodStatements(content, indent) + this.createIndent(indent) +
				"}");
	}
	fn findExprEnd(input : String) : List<String> => {
		return this.divide(input, EscapedFolder(ExprEndFolder())).toList();
	}
	fn compileMethodStatementValue(input : String, indent : I32) : Optional<String> => {
		if (input.equals("break") || input.equals("continue")) {
			return Optional.of(input);
		}
		if (input.startsWith("return ")) {
			let substring = input.substring("return ".length());
			return Optional.of("return " + this.compileExpressionOrPlaceholder(substring, indent));
		}
		let maybePostIncrement = this.compilePost(input, indent, "++");
		if (maybePostIncrement.isPresent()) {
			return maybePostIncrement;
		}
		let maybePostDecrement = this.compilePost(input, indent, "--");
		if (maybePostDecrement.isPresent()) {
			return maybePostDecrement;
		}
		let maybeInitialization = this.compileInitialization(input, indent);
		if (maybeInitialization.isPresent()) {
			return maybeInitialization;
		}
		return this.compileInvokable(input, indent);
	}
	fn compilePost(input : String, indent : I32, operator : String) : Optional<String> => {
		if (input.endsWith(operator)) {
			let substring = input.substring(0, input.length() - 2);
			return Optional.of(this.compileExpressionOrPlaceholder(substring, indent) + operator);
		}
		return Optional.empty();
	}
	fn compileClassStatement(input : String, indent : I32) : String => {
		return this.compileInitialization(input, indent).orElseGet(() => this.compileDefinitionOrPlaceholder(input));
	}
	fn compileInitialization(input : String, indent : I32) : Optional<String> => {
		let i = input.indexOf("=");
		if (i >= 0) {
			let substring = input.substring(0, i);
			let substring1 = input.substring(i + 1);
			let string = this.parseDefinitionToTuff(substring). < TuffLValue > map((value : TuffDeclaration) => value).or(() => this.parseExpression(substring, 0). < TuffLValue > map((value : TuffExpression) => value)).orElseGet(() => Placeholder(substring));
			return Optional.of(this.generateAssignable(string) + " = " + this.compileExpressionOrPlaceholder(substring1, indent));
		}
		return Optional.empty();
	}
	fn generateAssignable(value : TuffLValue) : String => {
		return match (value) {
			Placeholder placeholder => this.wrap(placeholder.input);
			TuffDeclaration tuffDeclaration => "let " + this.generateDefinitionOrPlaceholder(tuffDeclaration);
			TuffExpression tuffExpression => this.generateExpression(tuffExpression);
		};
	}
	fn compileExpressionOrPlaceholder(input : String, indent : I32) : String => {
		return this.compileExpression(input, indent).orElseGet(() => this.wrap(input.strip()));
	}
	fn compileExpression(input : String, indent : I32) : Optional<String> => {
		return this.parseExpression(input, indent).map(this::generateExpression);
	}
	fn generateExpression(expr : TuffExpression) : String => {
		return match (expr) {
			WrappedExpression(value) => value;
		};
	}
	fn parseExpression(input : String, indent : I32) : Optional<TuffExpression> => {
		return this.compileExpression0(input, indent).map(WrappedExpression::new);
	}
	fn compileExpression0(input : String, indent : I32) : Optional<String> => {
		let maybeLambda = this.compileLambda(input, indent);
		if (maybeLambda.isPresent()) {
			return maybeLambda;
		}
		let stripped = input.strip();
		if (stripped.startsWith("!")) {
			let substring = stripped.substring(1);
			return Optional.of("!" + this.compileExpressionOrPlaceholder(substring, indent));
		}
		let maybeInstanceOf = this.compileInstanceOf(input, indent);
		if (maybeInstanceOf.isPresent()) {
			return maybeInstanceOf;
		}
		return this.compileInvokable(input, indent).or(() => this.compileString(input)).or(() => this.compileSwitch(input, indent)).or(() => this.compileOperation(indent, input, "<")).or(() => this.compileOperation(indent, input, ">=")).or(() => this.compileOperation(indent, input, ">")).or(() => this.compileOperation(indent, input, "+")).or(() => this.compileOperation(indent, input, "-")).or(() => this.compileOperation(indent, input, "&&")).or(() => this.compileOperation(indent, input, "||")).or(() => this.compileOperation(indent, input, "==")).or(() => this.compileOperation(indent, input, "!=")).or(() => this.compileAccess(input, indent, ".")).or(() => this.compileAccess(input, indent, "::")).or(() => this.compileIdentifier(input)).or(() => this.compileNumber(input)).or(() => this.compileChar(input));
	}
	fn compileLambda(input : String, indent : I32) : Optional<String> => {
		let i = input.indexOf("->");
		if (i < 0) {
			return Optional.empty();
		}
		let beforeArrow = input.substring(0, i).strip();
		let maybeWithBraces = input.substring(i + 2).strip();
		if (!beforeArrow.startsWith("(") || !beforeArrow.endsWith(")")) {
			return Optional.empty();
		}
		let substring = beforeArrow.substring(1, beforeArrow.length() - 1);
		let compiled = String.join(", ", this.compileParameters(substring));
		compiled1 : String
		if (maybeWithBraces.startsWith("{") && maybeWithBraces.endsWith("}")) {
			let body = maybeWithBraces.substring(1, maybeWithBraces.length() - 1);
			compiled1 = "{" + this.compileMethodStatements(body, indent) + this.createIndent(indent) + "}";
		}
		else {
			compiled1 = this.compileExpressionOrPlaceholder(maybeWithBraces, indent);
		}
		return Optional.of("(" + compiled + ")" + " => " + compiled1);
	}
	fn compileInstanceOf(input : String, indent : I32) : Optional<String> => {
		let divisions = this.divide(input, EscapedFolder(OperationFolder("instanceof"))).toList();
		if (divisions.size() < 2) {
			return Optional.empty();
		}
		let first = divisions.getFirst();
		let substring = first.substring(0, first.length() - "instanceof".length());
		let substring1 = String.join("", divisions.subList(1, divisions.size()));
		if (!substring1.endsWith(")")) {
			return Optional.empty();
		}
		let substring2 = substring1.substring(0, substring1.length() - 1);
		let i2 = substring2.indexOf("(");
		if (i2 < 0) {
			return Optional.empty();
		}
		let substring3 = substring2.substring(0, i2).strip();
		let substring4 = substring2.substring(i2 + 1);
		let parameters = this.divideValues(substring4).map(String::strip).filter((slice : String) => !slice.isEmpty()).map(this::parseDefinitionOrPlaceholderToTuff).map(this::retainDefinition).flatMap(Optional::stream).toList();
		let joinedNames = parameters.stream().map((declaration : TuffDeclaration) => declaration.name).collect(Collectors.joining(", "));
		return Optional.of(this.compileExpressionOrPlaceholder(substring, indent) + " is " + substring3 + " { " + joinedNames + " }");
	}
	fn retainDefinition(node : TuffDeclarationOrPlaceholder) : Optional<TuffDeclaration> => {
		return match (node) {
			Placeholder _ => Optional.empty();
			TuffDeclaration tuffDeclaration => Optional.of(tuffDeclaration);
		};
	}
	fn compileChar(input : String) : Optional<String> => {
		let stripped = input.strip();
		if (stripped.startsWith("'") && stripped.endsWith("'")) {
			return Optional.of(stripped);
		}
		else {
			return Optional.empty();
		}
	}
	fn compileAccess(input : String, indent : I32, separator : String) : Optional<String> => {
		return this.compileAccess(input, separator, (input1 : String) => this.compileAccessInstance(indent, input1));
	}
	fn compileAccessInstance(indent : I32, input : String) : String => {
		return Main.this.compileType(input).orElseGet(() => this.compileExpressionOrPlaceholder(input, indent));
	}
	fn compileNumber(input : String) : Optional<String> => {
		let stripped = input.strip();
		if (this.isNumber(stripped)) {
			return Optional.of(stripped);
		}
		return Optional.empty();
	}
	fn isNumber(input : String) : boolean => {
		stripped : String
		if (input.startsWith("-")) {
			stripped = input.substring(1);
		}
		else {
			stripped = input;
		}
		return this.streamString(stripped).allMatch(U16::isDigit);
	}
	fn streamString(value : String) : Stream<U16> => {
		return IntStream.range(0, value.length()).mapToObj(value::charAt);
	}
	fn compileOperation(indent : I32, input : String, operator : String) : Optional<String> => {
		let divisions = this.divide(input, EscapedFolder(OperationFolder(operator))).toList();
		if (divisions.size() >= 2) {
			let first = divisions.getFirst();
			let left = first.substring(0, first.length() - operator.length());
			let elements = divisions.subList(1, divisions.size());
			let right = String.join("", elements);
			let leftResult = this.compileExpressionOrPlaceholder(left, indent);
			let rightResult = this.compileExpressionOrPlaceholder(right, indent);
			return Optional.of(leftResult + " " + operator + " " + rightResult);
		}
		else {
			return Optional.empty();
		}
	}
	fn compileSwitch(input : String, indent : I32) : Optional<String> => {
		let stripped = input.strip();
		if (!stripped.startsWith("switch")) {
			return Optional.empty();
		}
		let substring = stripped.substring("switch".length()).strip();
		if (!substring.startsWith("(")) {
			return Optional.empty();
		}
		let withExpr = substring.substring(1);
		let divisions = this.findExprEnd(withExpr);
		if (divisions.size() < 2) {
			return Optional.empty();
		}
		let exprWithSuffix = divisions.getFirst();
		let withBraces = String.join("", divisions.subList(1, divisions.size())).strip();
		if (!exprWithSuffix.endsWith(")")) {
			return Optional.empty();
		}
		let expr = exprWithSuffix.substring(0, exprWithSuffix.length() - 1);
		let compiledExpr = this.compileExpressionOrPlaceholder(expr, indent);
		if (!withBraces.startsWith("{") || !withBraces.endsWith("}")) {
			return Optional.empty();
		}
		let content = withBraces.substring(1, withBraces.length() - 1);
		let collect = this.compileCases(indent, content);
		return Optional.of("match (" + compiledExpr + ") {" + collect + this.createIndent(indent) + "}");
	}
	fn compileCases(indent : I32, content : String) : String => {
		return this.divideStatements(content).map(String::strip).filter((slice : String) => !slice.isEmpty()).map((input1 : String) => this.compileCase(input1, indent + 1)).map((slice : String) => this.createIndent(indent + 1) + slice).collect(Collectors.joining());
	}
	fn compileCase(input : String, indent : I32) : String => {
		let stripped = input.strip();
		if (stripped.startsWith("case ")) {
			let substring = stripped.substring("case ".length());
			let i = substring.indexOf("->");
			if (i >= 0) {
				let substring1 = substring.substring(0, i);
				let substring2 = substring.substring(i + "->".length());
				return this.compileDestructuring(substring1) + " => " + this.compileCaseValue(substring2, indent);
			}
		}
		if (stripped.startsWith("default")) {
			let i = stripped.indexOf("->");
			if (i >= 0) {
				let substring2 = stripped.substring(i + "->".length());
				return "default => " + this.compileCaseValue(substring2, indent);
			}
		}
		return this.wrap(stripped);
	}
	fn compileDestructuring(input : String) : String => {
		return input.replace("var ", "").strip();
	}
	fn compileCaseValue(input : String, indent : I32) : String => {
		let stripped = input.strip();
		if (stripped.endsWith(";")) {
			let substring = stripped.substring(0, stripped.length() - 1);
			return this.compileExpressionOrPlaceholder(substring, indent) + ";";
		}
		if (stripped.startsWith("{") && stripped.endsWith("}")) {
			let substring = stripped.substring(1, stripped.length() - 1);
			let compiled = this.compileMethodStatements(substring, indent);
			return "{" + compiled + this.createIndent(indent) + "}";
		}
		return this.wrap(stripped);
	}
	fn compileMethodStatements(input : String, indent : I32) : String => {
		return this.compileStatements(input, (segment : String) => this.compileMethodSegment(segment, indent + 1));
	}
	fn compileString(input : String) : Optional<String> => {
		let stripped = input.strip();
		if (stripped.startsWith("\"") && stripped.endsWith("\"")) {
			return Optional.of(stripped);
		}
		else {
			return Optional.empty();
		}
	}
	fn compileIdentifier(input : String) : Optional<String> => {
		let stripped = input.strip();
		if (this.isIdentifier(stripped)) {
			return Optional.of(stripped);
		}
		else {
			return Optional.empty();
		}
	}
	fn compileAccess(input : String, separator : String, mapper : Function<String, String>) : Optional<String> => {
		let i = input.lastIndexOf(separator);
		if (i < 0) {
			return Optional.empty();
		}
		let substring = input.substring(0, i);
		let mut memberName = input.substring(i + separator.length()).strip();
		if (memberName.startsWith("<")) {
			let substring1 = memberName.substring(1);
			let i1 = substring1.indexOf(">");
			if (i1 >= 0) {
				memberName = substring1.substring(i1 + 1).strip();
			}
		}
		if (this.isIdentifier(memberName)) {
			return Optional.of(mapper.apply(substring) + separator + memberName);
		}
		return Optional.empty();
	}
	fn compileInvokable(input : String, indent : I32) : Optional<String> => {
		let stripped = input.strip();
		if (stripped.endsWith(")")) {
			let withoutEnd = stripped.substring(0, stripped.length() - 1);
			let i = this.findInvokableStart(withoutEnd);
			if (i >= 0) {
				let caller = withoutEnd.substring(0, i);
				let arguments = withoutEnd.substring(i + 1);
				let joinedArguments = this.divideValues(arguments).map(String::strip).filter((slice : String) => !slice.isEmpty()).map((input1 : String) => this.compileExpressionOrPlaceholder(input1, indent)).collect(Collectors.joining(", "));
				return Optional.of(this.compileCaller(caller, indent) + "(" + joinedArguments + ")");
			}
		}
		return Optional.empty();
	}
	fn findInvokableStart(withoutEnd : String) : I32 => {
		let mut current = Tuple3<Integer, Integer, Integer>(-1, 0, 0);
		while (current.b < withoutEnd.length()) {
			current = this.fold(withoutEnd, current);
		}
		return current.a;
	}
	fn fold(withoutEnd : String, current : Tuple3<Integer, Integer, Integer>) : Tuple3<Integer, Integer, Integer> => {
		let mut indexToReturn = current.a;
		let mut indexCurrent = current.b;
		let mut depth = current.c;
		let c = withoutEnd.charAt(indexCurrent);
		let next = indexCurrent + 1;
		if (c == '(') {
			if (depth == 0) {
				indexToReturn = indexCurrent;
			}
			depth++;
		}
		if (c == ')') {
			depth--;
		}
		return Tuple3<Integer, Integer, Integer>(indexToReturn, next, depth);
	}
	fn divideValues(input : String) : Stream<String> => {
		return this.divide(input, EscapedFolder(ValueFolder()));
	}
	fn compileCaller(input : String, indent : I32) : String => {
		let stripped = input.strip();
		if (stripped.startsWith("new ")) {
			let substring = stripped.substring("new ".length());
			let maybeType = this.compileType(substring);
			if (maybeType.isPresent()) {
				return maybeType.get();
			}
		}
		let maybeExpression = this.compileExpression(input, indent);
		if (maybeExpression.isPresent()) {
			return maybeExpression.get();
		}
		if (stripped.startsWith("new ")) {
			let substring = stripped.substring("new ".length());
			return this.compileTypeOrPlaceholder(substring);
		}
		return this.wrap(stripped);
	}
	fn compileDefinitionOrPlaceholder(input : String) : String => {
		return this.generateDefinitionOrPlaceholder(this.parseDefinitionOrPlaceholderToTuff(input));
	}
	fn generateDefinitionOrPlaceholder(string : TuffDeclarationOrPlaceholder) : String => {
		return match (string) {
			TuffDeclaration(modifiers, name, type, isMutable) => this.generateDefinition(modifiers, name, type, isMutable);
			Placeholder placeholder => this.wrap(placeholder.input);
		};
	}
	fn generateDefinition(modifiers : List<String>, name : String, type : String, isMutable : boolean) : String => {
		mutableString : String
		if (isMutable) {
			mutableString = "mut ";
		}
		else {
			mutableString = "";
		}
		let joinedModifiers = this.joinModifiers(modifiers);
		if (type.equals("var")) {
			return joinedModifiers + mutableString + name;
		}
		return joinedModifiers + mutableString + name + " : " + type;
	}
	fn joinModifiers(modifiers : List<String>) : String => {
		return modifiers.stream().map((modifier : String) => modifier + " ").collect(Collectors.joining());
	}
	fn parseDefinitionOrPlaceholderToTuff(input : String) : TuffDeclarationOrPlaceholder => {
		return this.parseDefinitionToTuff(input). < TuffDeclarationOrPlaceholder > map((value : TuffDeclaration) => value).orElseGet(() => Placeholder(input));
	}
	fn parseDefinitionToTuff(input : String) : Optional<TuffDeclaration> => {
		let stripped = input.strip();
		let i = stripped.lastIndexOf(" ");
		if (i >= 0) {
			let beforeName = stripped.substring(0, i);
			let name = stripped.substring(i + 1);
			let i1 = this.findTypeSeparator(beforeName);
			if (i1 < 0) {
				let compiled = this.compileTypeOrPlaceholder(beforeName);
				return Optional.of(TuffDeclaration(ArrayList<String>(), name, compiled, true));
			}
			let mut beforeType = beforeName.substring(0, i1);
			let i2 = beforeType.lastIndexOf("\n");
			let mut annotations : List<String> = ArrayList<String>();
			if (i2 >= 0) {
				let substring = beforeType.substring(0, i2);
				annotations = Arrays.stream(substring.split(Pattern.quote(" "))).map(String::strip).filter((slice : String) => !slice.isEmpty()).map((slice : String) => slice.substring(1)).toList();
				beforeType = beforeType.substring(i2 + 1).strip();
			}
			let oldModifiers = Arrays.stream(beforeType.split(" ")).map(String::strip).filter((slice : String) => !slice.isEmpty()).toList();
			let type = beforeName.substring(i1 + 1);
			let compiled = this.compileTypeOrPlaceholder(type);
			let newModifiers : List<String> = ArrayList<String>();
			if (annotations.contains("Actual")) {
				newModifiers.add("expect");
			}
			let isMutable = !oldModifiers.contains("final");
			return Optional.of(TuffDeclaration(newModifiers, name, compiled, isMutable));
		}
		return Optional.empty();
	}
	fn compileTypeOrPlaceholder(input : String) : String => {
		return this.compileType(input).orElseGet(() => this.wrap(input));
	}
	fn compileType(input : String) : Optional<String> => {
		let stripped = input.strip();
		let maybePrimitiveType = this.compilePrimitiveType(stripped);
		if (maybePrimitiveType.isPresent()) {
			return maybePrimitiveType;
		}
		let i = stripped.indexOf("<");
		if (i >= 0) {
			let base = stripped.substring(0, i);
			let substring1 = stripped.substring(i + 1).strip();
			if (substring1.endsWith(">")) {
				let args = substring1.substring(0, substring1.length() - 1);
				let joinedTypeArguments = this.divideValues(args).map(this::compileTypeOrPlaceholder).collect(Collectors.joining(", "));
				return Optional.of(base + "<" + joinedTypeArguments + ">");
			}
		}
		if (this.isIdentifier(stripped)) {
			return Optional.of(stripped);
		}
		if (stripped.endsWith("[]")) {
			let substring = stripped.substring(0, stripped.length() - 2);
			return Optional.of("*[" + substring + "]");
		}
		return Optional.empty();
	}
	fn compilePrimitiveType(stripped : String) : Optional<String> => {
		return match (stripped) {
			"char", "Character" => Optional.of("U16");
			"int" => Optional.of("I32");
			"void" => Optional.of("Void");
			default => Optional.empty();
		};
	}
	fn isIdentifier(input : String) : boolean => {
		let stripped = input.strip();
		return IntStream.range(0, stripped.length()).allMatch((index : I32) => {
			let c = stripped.charAt(index);
			return U16.isLetter(c) || (index != 0 && U16.isDigit(c));
		});
	}
	fn findTypeSeparator(beforeName : String) : I32 => {
		let mut i1 =  - 1;
		let mut depth = 0;
		let mut i2 = 0;
		while (i2 < beforeName.length()) {
			let c = beforeName.charAt(i2);
			if (c == ' ' && depth == 0) {
				i1 = i2;
			}
			if (c == '<') {
				depth++;
			}
			if (c == '>') {
				depth--;
			}
			i2++;
		}
		return i1;
	}
}
