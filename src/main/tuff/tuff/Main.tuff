from java::util::function use { Function };
from java::util::stream use { Collectors };
from java::io use { IOException };
from java::nio::file use { Files, Paths };
from java::util use { ArrayList, Arrays, HashMap, List, Map };
from java::util::regex use { Pattern };
class fn Main() => {
	let imports : Map<List<String>, List<String>> = HashMap<List<String>, List<String>>();
	/*Raw*/public static void main(String[] args) {
		new Main().run();
	}
	/*Raw*/private void run() {
		try {
			final var input = Files.readString(Paths.get(".", "src", "main", "java", "tuff", "Main.java"));
			Files.writeString(Paths.get(".", "src", "main", "tuff", "tuff", "Main.tuff"), this.compile(input));
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
	/*Raw*/private String compile(String input) {
		final var compiled = this.compileStatements(input, this::compileRootSegment);
		final var useStatements = this.imports.entrySet().stream().map(entry -> {
			final var usedNamespace = String.join("::", entry.getKey());
			final var usedChildren = String.join(", ", entry.getValue());
			return "from " + usedNamespace + " use { " + usedChildren + " };" + System.lineSeparator();
		}).collect(Collectors.joining());

		return useStatements + compiled;
	}
	/*Raw*/private String compileStatements(String input, Function<String, String> mapper) {
		final var segments = new ArrayList<String>();
		var buffer = new StringBuilder();
		var depth = 0;
		for (var i = 0; i < input.length(); i++) {
			final var c = input.charAt(i);
			buffer.append(c);
			if (c == ';' && depth == 0) {
				segments.add(buffer.toString());
				buffer = new StringBuilder();
				continue;
			}
			if (c == '}' && depth == 1) {
				segments.add(buffer.toString());
				buffer = new StringBuilder();
				depth--;
				continue;
			}
			if (c == '{') {
				depth++;
			}
			if (c == '}') {
				depth--;
			}
		}
	/*Raw*/segments.add(buffer.toString());
	/*Raw*/return segments.stream().map(mapper).collect(Collectors.joining());
	/*Raw*/
}
/*Raw*/private String compileRootSegment(String input) {
		final var stripped = input.strip();
		if (stripped.startsWith("package ")) {
			return "";
		}

		if (stripped.startsWith("import ") && stripped.endsWith(";")) {
			final var slice = stripped.substring("import ".length(), stripped.length() - 1);
			final var copy = Arrays.asList(slice.split(Pattern.quote(".")));
			final var namespace = copy.subList(0, copy.size() - 1);

			if (!this.imports.containsKey(namespace)) {
				this.imports.put(namespace, new ArrayList<String>());
			}

			this.imports.get(namespace).add(copy.getLast());
			return "";
		}

		return this.compileRootSegmentValue(stripped) + System.lineSeparator();
	}
class fn ");
		if (i >= 0)() => {
	let afterKeyword : var = /*Raw*/input.substring(/*Raw*/i + "class ".length());
	/*Raw*/final var i1 = afterKeyword.indexOf("{");
			if (i1 >= 0) {
				final var name = afterKeyword.substring(0, i1).strip();
				final var substring1 = afterKeyword.substring(i1 + 1).strip();
				if (substring1.endsWith("}")) {
					final var body = substring1.substring(0, substring1.length() - 1);
					return "class fn " + name + "() => {" + this.compileStatements(body, this::compileClassSegment) +
								 System.lineSeparator() + "}";
				}
			}
	/*Raw*/}

		return this.wrap(input);
}
/*Raw*/private String wrap(String input) {
		return "/*Raw*/" + input;
	}
/*Raw*/private String compileClassSegment(String input) {
		final var stripped = input.strip();
		return System.lineSeparator() + "\t" + this.compileClassSegmentValue(stripped);
	}
/*Raw*/private String compileClassSegmentValue(String input) {
		if (input.endsWith(";")) {
			final var slice = input.substring(0, input.length() - 1);
			return this.compileClassStatement(slice) + ";";
		}

		return this.wrap(input);
	}
/*Raw*/private String compileClassStatement(String input) {
		final var i = input.indexOf("=");
		if (i >= 0) {
			final var substring = input.substring(0, i);
			final var substring1 = input.substring(i + 1);
			return "let " + this.compileDefinition(substring) + " = " + this.compileExpression(substring1);
		}

		return this.wrap(input);
	}
/*Raw*/private String compileExpression(String input) {
		final var stripped = input.strip();
		if (stripped.endsWith(")")) {
			final var substring = stripped.substring(0, stripped.length() - 1);
			final var i = substring.indexOf("(");
			if (i >= 0) {
				final var caller = substring.substring(0, i);
				final var arguments = substring.substring(i + 1);
				final var joinedArguments = Arrays
						.stream(arguments.split(Pattern.quote(",")))
						.map(String::strip)
						.filter(slice -> !slice.isEmpty())
						.map(this::compileExpression)
						.collect(Collectors.joining());

				return this.compileCaller(caller) + "(" + joinedArguments + ")";
			}
		}

		return this.wrap(stripped);
	}
/*Raw*/private String compileCaller(String input) {
		final var stripped = input.strip();
		if (stripped.startsWith("new ")) {
			final var substring = stripped.substring("new ".length());
			return this.compileType(substring);
		}

		return this.wrap(stripped);
	}
/*Raw*/private String compileDefinition(String input) {
		final var stripped = input.strip();
		final var i = stripped.lastIndexOf(" ");
		if (i >= 0) {
			final var beforeName = stripped.substring(0, i);
			final var name = stripped.substring(i + 1);
			final var i1 = this.findTypeSeparator(beforeName);
			if (i1 >= 0) {
				final var type = beforeName.substring(i1 + 1);
				return name + " : " + this.compileType(type);
			}
		}

		return this.wrap(stripped);
	}
/*Raw*/private String compileType(String input) {
		final var stripped = input.strip();
		final var i = stripped.indexOf("<");
		if (i >= 0) {
			final var base = stripped.substring(0, i);
			final var substring1 = stripped.substring(i + 1).strip();
			if (substring1.endsWith(">")) {
				final var args = substring1.substring(0, substring1.length() - 1);
				final var joinedTypeArguments =
						Arrays.stream(args.split(Pattern.quote(","))).map(this::compileType).collect(Collectors.joining(", "));

				return base + "<" + joinedTypeArguments + ">";
			}
		}

		if (this.isIdentifier(stripped)) {
			return stripped;
		}

		return this.wrap(stripped);
	}
/*Raw*/private boolean isIdentifier(String input) {
		final var stripped = input.strip();
		for (var i = 0; i < stripped.length(); i++) {
			final var c = stripped.charAt(i);
			if (Character.isLetter(c)) {continue;}
			return false;
		}
		return true;
	}
/*Raw*/private int findTypeSeparator(String beforeName) {
		int i1 = -1;
		var depth = 0;
		for (var i2 = 0; i2 < beforeName.length(); i2++) {
			final var c = beforeName.charAt(i2);
			if (c == ' ' && depth == 0) {
				i1 = i2;
			}
			if (c == '<') {
				depth++;
			}
			if (c == '>') {
				depth--;
			}
		}
		return i1;
	}
/*Raw*/}
