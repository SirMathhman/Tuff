// EBNF Grammar Validator - Phase 2 of the bidirectional grammar system
// Validates grammar for well-formedness: undefined non-terminals, left recursion, etc.

extern from rt::stdlib use { stringLen, stringSlice, stringCharCodeAt, print };
extern from rt::vec use { vec_new, vec_push, vec_len, vec_get };

from src::main::tuff::tools::ebnf_parser use {
  Grammar,
  Rule,
  Production,
  PSequence,
  PAlternation,
  PTerm,
  Term,
  TNonTerminal,
  TLiteral,
  TCharClass,
  TRepeat,
  TGroup,
  TAnnotation
};

// =============================================================================
// Validation Result Types
// =============================================================================

struct ValidationResult {
  valid: Bool,
  errors: Vec<String>,
  warnings: Vec<String>
}

fn mk_result() : ValidationResult => 
  ValidationResult { true, vec_new(), vec_new() }

fn add_error(result: ValidationResult, msg: String) : ValidationResult => {
  vec_push(result.errors, msg);
  ValidationResult { false, result.errors, result.warnings }
}

fn add_warning(result: ValidationResult, msg: String) : ValidationResult => {
  vec_push(result.warnings, msg);
  result
}

// =============================================================================
// Helper: Collect defined rule names
// =============================================================================

fn collect_defined_names(g: Grammar) : Vec<String> => {
  let names = vec_new();
  let mut i = 0;
  while (i < vec_len(g.rules)) {
    let rule = vec_get(g.rules, i);
    vec_push(names, rule.name);
    i = i + 1;
  }
  names
}

fn vec_contains(v: Vec<String>, s: String) : Bool => {
  let mut i = 0;
  while (i < vec_len(v)) {
    if (vec_get(v, i) == s) { yield true; }
    i = i + 1;
  }
  false
}

// =============================================================================
// Collect all non-terminal references from a production
// =============================================================================

fn collect_nonterminals_from_production(p: Production, refs: Vec<String>) : Void => {
  if (p is PSequence) {
    let mut i = 0;
    while (i < vec_len(p.terms)) {
      collect_nonterminals_from_production(vec_get(p.terms, i), refs);
      i = i + 1;
    }
    yield;
  }
  
  if (p is PAlternation) {
    let mut i = 0;
    while (i < vec_len(p.choices)) {
      collect_nonterminals_from_production(vec_get(p.choices, i), refs);
      i = i + 1;
    }
    yield;
  }
  
  if (p is PTerm) {
    collect_nonterminals_from_term(p.term, refs);
    yield;
  }
}

fn collect_nonterminals_from_term(t: Term, refs: Vec<String>) : Void => {
  if (t is TNonTerminal) {
    if (!vec_contains(refs, t.name)) {
      vec_push(refs, t.name);
    }
    yield;
  }
  
  if (t is TRepeat) {
    collect_nonterminals_from_production(t.inner, refs);
    yield;
  }
  
  if (t is TGroup) {
    collect_nonterminals_from_production(t.inner, refs);
    yield;
  }
  
  if (t is TAnnotation) {
    collect_nonterminals_from_production(t.inner, refs);
    yield;
  }
  
  // TLiteral and TCharClass don't reference non-terminals
}

// =============================================================================
// Check: Undefined Non-Terminals
// =============================================================================

fn check_undefined_nonterminals(g: Grammar, result: ValidationResult) : ValidationResult => {
  let defined = collect_defined_names(g);
  let mut res = result;
  
  let mut i = 0;
  while (i < vec_len(g.rules)) {
    let rule = vec_get(g.rules, i);
    let refs = vec_new();
    collect_nonterminals_from_production(rule.production, refs);
    
    let mut j = 0;
    while (j < vec_len(refs)) {
      let ref = vec_get(refs, j);
      if (!vec_contains(defined, ref)) {
        res = add_error(res, "undefined non-terminal '" + ref + "' in rule '" + rule.name + "'");
      }
      j = j + 1;
    }
    i = i + 1;
  }
  
  res
}

// =============================================================================
// Check: Duplicate Rule Names
// =============================================================================

fn check_duplicate_rules(g: Grammar, result: ValidationResult) : ValidationResult => {
  let seen = vec_new();
  let mut res = result;
  
  let mut i = 0;
  while (i < vec_len(g.rules)) {
    let rule = vec_get(g.rules, i);
    if (vec_contains(seen, rule.name)) {
      res = add_error(res, "duplicate rule name: '" + rule.name + "'");
    } else {
      vec_push(seen, rule.name);
    }
    i = i + 1;
  }
  
  res
}

// =============================================================================
// Check: Empty Grammar
// =============================================================================

fn check_empty_grammar(g: Grammar, result: ValidationResult) : ValidationResult => {
  if (vec_len(g.rules) == 0) {
    yield add_warning(result, "grammar has no rules");
  }
  result
}

// =============================================================================
// Check: Unreachable Rules (rules not reachable from program/entry)
// =============================================================================

fn collect_reachable(g: Grammar, start: String) : Vec<String> => {
  let reachable = vec_new();
  let worklist = vec_new();
  vec_push(worklist, start);
  
  while (vec_len(worklist) > 0) {
    // Pop from worklist
    let current = vec_get(worklist, vec_len(worklist) - 1);
    // Remove last element by creating new vec (simplistic approach)
    let newWorklist = vec_new();
    let mut wi = 0;
    while (wi < vec_len(worklist) - 1) {
      vec_push(newWorklist, vec_get(worklist, wi));
      wi = wi + 1;
    }
    
    if (vec_contains(reachable, current)) {
      // Already visited, continue with next in worklist
      // Use newWorklist for remaining iterations
      let mut continue_loop = true;
      while (continue_loop && vec_len(newWorklist) > 0) {
        let next = vec_get(newWorklist, vec_len(newWorklist) - 1);
        let nextWorklist = vec_new();
        let mut nwi = 0;
        while (nwi < vec_len(newWorklist) - 1) {
          vec_push(nextWorklist, vec_get(newWorklist, nwi));
          nwi = nwi + 1;
        }
        
        if (!vec_contains(reachable, next)) {
          vec_push(reachable, next);
          // Find rule and add its references
          let mut ri = 0;
          while (ri < vec_len(g.rules)) {
            let rule = vec_get(g.rules, ri);
            if (rule.name == next) {
              let refs = vec_new();
              collect_nonterminals_from_production(rule.production, refs);
              let mut rj = 0;
              while (rj < vec_len(refs)) {
                let ref = vec_get(refs, rj);
                if (!vec_contains(reachable, ref)) {
                  vec_push(nextWorklist, ref);
                }
                rj = rj + 1;
              }
            }
            ri = ri + 1;
          }
        }
        
        // Replace worklist
        let mut copy = 0;
        while (copy < vec_len(nextWorklist)) {
          vec_push(newWorklist, vec_get(nextWorklist, copy));
          copy = copy + 1;
        }
        
        if (vec_len(nextWorklist) == 0) {
          continue_loop = false;
        }
      }
      break;
    }
    
    vec_push(reachable, current);
    
    // Find rule with this name
    let mut ri = 0;
    while (ri < vec_len(g.rules)) {
      let rule = vec_get(g.rules, ri);
      if (rule.name == current) {
        let refs = vec_new();
        collect_nonterminals_from_production(rule.production, refs);
        let mut rj = 0;
        while (rj < vec_len(refs)) {
          let ref = vec_get(refs, rj);
          if (!vec_contains(reachable, ref)) {
            vec_push(newWorklist, ref);
          }
          rj = rj + 1;
        }
      }
      ri = ri + 1;
    }
    
    // Simple recursive approach - just restart
    break;
  }
  
  // Simplified: just return what we have
  reachable
}

fn check_unreachable_rules(g: Grammar, result: ValidationResult) : ValidationResult => {
  // Skip if no rules
  if (vec_len(g.rules) == 0) { yield result; }
  
  // Assume first rule is the entry point (often "program" or similar)
  let entryRule = vec_get(g.rules, 0).name;
  
  // For now, we'll just do a simple depth-first reachability check
  // This is a simplified version
  let defined = collect_defined_names(g);
  let mut res = result;
  
  // Mark everything reachable for now (full implementation would do graph traversal)
  // TODO: implement proper reachability check
  
  res
}

// =============================================================================
// Main Validation Function
// =============================================================================

out fn validate_grammar(g: Grammar) : ValidationResult => {
  let mut result = mk_result();
  
  // Check 1: Empty grammar
  result = check_empty_grammar(g, result);
  
  // Check 2: Duplicate rule names
  result = check_duplicate_rules(g, result);
  
  // Check 3: Undefined non-terminals
  result = check_undefined_nonterminals(g, result);
  
  // Check 4: Unreachable rules (warning only)
  result = check_unreachable_rules(g, result);
  
  result
}

// =============================================================================
// Print Validation Results
// =============================================================================

out fn print_validation_result(result: ValidationResult) : Void => {
  if (result.valid) {
    print("Grammar is valid.");
  } else {
    print("Grammar validation failed:");
  }
  
  let mut i = 0;
  while (i < vec_len(result.errors)) {
    print("  ERROR: " + vec_get(result.errors, i));
    i = i + 1;
  }
  
  let mut j = 0;
  while (j < vec_len(result.warnings)) {
    print("  WARNING: " + vec_get(result.warnings, j));
    j = j + 1;
  }
}
