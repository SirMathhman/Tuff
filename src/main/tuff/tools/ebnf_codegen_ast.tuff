// EBNF Code Generator for AST-Producing Parsers
// This module generates parsers that directly produce the Tuff AST types
// instead of generic CST nodes.
//
// The key difference from ebnf_codegen.tuff is that this generates code
// that calls the AST factory functions (expr_int, expr_binary, etc.)
// to construct typed AST nodes.

extern from rt::stdlib use { stringLen, stringSlice, stringCharCodeAt, stringFromCharCode };
extern from rt::vec use { vec_new, vec_push, vec_len, vec_get };

from src::main::tuff::tools::ebnf_parser use {
  Grammar,
  Rule,
  Production,
  PSequence,
  PAlternation,
  PTerm,
  Term,
  TNonTerminal,
  TLiteral,
  TCharClass,
  TRepeat,
  TGroup,
  TAnnotation,
  RepeatKind,
  RepeatZeroOrMore,
  RepeatOneOrMore,
  RepeatOptional,
  CharRange
};

// =============================================================================
// AST Mapping Configuration
// =============================================================================

// Maps rule names to AST constructor calls
// For example: "int_literal" -> "expr_int"

struct AstMapping {
  ruleName: String,
  astConstructor: String,
  // If non-empty, specifies the AST type (Expr, Stmt, Decl, etc.)
  astType: String
}

struct AstConfig {
  mappings: Vec<AstMapping>
}

out fn mk_ast_mapping(ruleName: String, constructor: String, astType: String) : AstMapping =>
  AstMapping { ruleName, constructor, astType }

out fn mk_ast_config() : AstConfig =>
  AstConfig { vec_new() }

out fn config_add_mapping(config: AstConfig, m: AstMapping) : Void => {
  vec_push(config.mappings, m);
}

fn find_mapping(config: AstConfig, ruleName: String) : AstMapping => {
  let mut i = 0;
  while (i < vec_len(config.mappings)) {
    let m = vec_get(config.mappings, i);
    if (m.ruleName == ruleName) {
      yield m;
    }
    i = i + 1;
  }
  AstMapping { "", "", "" }
}

// =============================================================================
// Default Tuff AST Mappings
// =============================================================================

out fn default_tuff_ast_config() : AstConfig => {
  let config = mk_ast_config();
  
  // Expression mappings
  config_add_mapping(config, mk_ast_mapping("int_literal", "expr_int", "Expr"));
  config_add_mapping(config, mk_ast_mapping("float_literal", "expr_float", "Expr"));
  config_add_mapping(config, mk_ast_mapping("bool_literal", "expr_bool", "Expr"));
  config_add_mapping(config, mk_ast_mapping("string_literal", "expr_string", "Expr"));
  config_add_mapping(config, mk_ast_mapping("ident", "expr_ident", "Expr"));
  config_add_mapping(config, mk_ast_mapping("if_expr", "expr_if", "Expr"));
  config_add_mapping(config, mk_ast_mapping("block", "expr_block", "Expr"));
  config_add_mapping(config, mk_ast_mapping("match_expr", "expr_match", "Expr"));
  config_add_mapping(config, mk_ast_mapping("lambda_expr", "expr_lambda", "Expr"));
  config_add_mapping(config, mk_ast_mapping("vec_lit", "expr_vec_lit", "Expr"));
  config_add_mapping(config, mk_ast_mapping("tuple_lit", "expr_tuple_lit", "Expr"));
  config_add_mapping(config, mk_ast_mapping("struct_lit", "expr_struct_lit", "Expr"));
  
  // Statement mappings
  config_add_mapping(config, mk_ast_mapping("let_stmt", "stmt_let", "Stmt"));
  config_add_mapping(config, mk_ast_mapping("assign_stmt", "stmt_assign", "Stmt"));
  config_add_mapping(config, mk_ast_mapping("yield_stmt", "stmt_yield", "Stmt"));
  config_add_mapping(config, mk_ast_mapping("while_stmt", "stmt_while", "Stmt"));
  config_add_mapping(config, mk_ast_mapping("if_stmt", "stmt_if", "Stmt"));
  config_add_mapping(config, mk_ast_mapping("expr_stmt", "stmt_expr", "Stmt"));
  
  // Declaration mappings
  config_add_mapping(config, mk_ast_mapping("fn_decl", "decl_fn", "Decl"));
  config_add_mapping(config, mk_ast_mapping("struct_decl", "decl_struct", "Decl"));
  config_add_mapping(config, mk_ast_mapping("type_decl", "decl_type_union", "Decl"));
  config_add_mapping(config, mk_ast_mapping("import_decl", "decl_import", "Decl"));
  config_add_mapping(config, mk_ast_mapping("extern_decl", "decl_extern_from", "Decl"));
  
  // Binary operators - these need special handling
  config_add_mapping(config, mk_ast_mapping("add_expr", "__binary_left", "Expr"));
  config_add_mapping(config, mk_ast_mapping("mul_expr", "__binary_left", "Expr"));
  config_add_mapping(config, mk_ast_mapping("or_expr", "__binary_left", "Expr"));
  config_add_mapping(config, mk_ast_mapping("and_expr", "__binary_left", "Expr"));
  config_add_mapping(config, mk_ast_mapping("eq_expr", "__binary_left", "Expr"));
  config_add_mapping(config, mk_ast_mapping("rel_expr", "__binary_left", "Expr"));
  
  // Unary operators
  config_add_mapping(config, mk_ast_mapping("unary_expr", "__unary", "Expr"));
  
  config
}

// =============================================================================
// Generate AST-Producing Parser
// =============================================================================

fn indent(level: I32) : String => {
  let mut s = "";
  let mut i = 0;
  while (i < level) {
    s = s + "  ";
    i = i + 1;
  }
  s
}

out fn generate_ast_parser(g: Grammar, config: AstConfig) : String => {
  let mut code = "";
  
  // Header
  code = code + "// Generated AST Parser - DO NOT EDIT\n";
  code = code + "// Generated from EBNF grammar\n";
  code = code + "// This parser produces Tuff AST nodes directly.\n\n";
  
  // Imports
  code = code + "extern from rt::stdlib use { stringLen, stringSlice, stringCharCodeAt, stringFromCharCode };\n";
  code = code + "extern from rt::vec use { vec_new, vec_push, vec_len, vec_get };\n\n";
  
  code = code + "from ast use {\n";
  code = code + "  span,\n";
  code = code + "  Expr, Stmt, Decl, Span,\n";
  code = code + "  expr_int, expr_float, expr_bool, expr_string, expr_ident,\n";
  code = code + "  expr_binary, expr_unary, expr_call, expr_if, expr_block,\n";
  code = code + "  expr_vec_lit, expr_tuple_lit, expr_struct_lit, expr_match,\n";
  code = code + "  expr_lambda, expr_field, expr_index, expr_tuple_index,\n";
  code = code + "  stmt_let, stmt_assign, stmt_expr, stmt_yield, stmt_while, stmt_if,\n";
  code = code + "  decl_fn, decl_struct, decl_type_union, decl_import, decl_extern_from,\n";
  code = code + "  op_add, op_sub, op_mul, op_div, op_eq, op_ne, op_lt, op_le, op_gt, op_ge, op_and, op_or,\n";
  code = code + "  op_not, op_neg\n";
  code = code + "};\n\n";
  
  // Parse result types
  code = code + "// =============================================================================\n";
  code = code + "// Parse Result Types\n";
  code = code + "// =============================================================================\n\n";
  
  code = code + "struct ParsedExpr {\n";
  code = code + "  success: Bool,\n";
  code = code + "  expr: Expr,\n";
  code = code + "  nextPos: I32,\n";
  code = code + "  error: String\n";
  code = code + "}\n\n";
  
  code = code + "struct ParsedStmt {\n";
  code = code + "  success: Bool,\n";
  code = code + "  stmt: Stmt,\n";
  code = code + "  nextPos: I32,\n";
  code = code + "  error: String\n";
  code = code + "}\n\n";
  
  code = code + "struct ParsedDecl {\n";
  code = code + "  success: Bool,\n";
  code = code + "  decl: Decl,\n";
  code = code + "  nextPos: I32,\n";
  code = code + "  error: String\n";
  code = code + "}\n\n";
  
  code = code + "struct ParsedString {\n";
  code = code + "  success: Bool,\n";
  code = code + "  value: String,\n";
  code = code + "  nextPos: I32,\n";
  code = code + "  error: String\n";
  code = code + "}\n\n";
  
  code = code + "struct ParsedI32 {\n";
  code = code + "  success: Bool,\n";
  code = code + "  value: I32,\n";
  code = code + "  nextPos: I32,\n";
  code = code + "  error: String\n";
  code = code + "}\n\n";
  
  // Helper functions
  code = code + "// =============================================================================\n";
  code = code + "// Helper Functions\n";
  code = code + "// =============================================================================\n\n";
  
  code = code + "fn is_ws(c: I32) : Bool => c == 32 || c == 9 || c == 10 || c == 13\n\n";
  
  code = code + "fn skip_ws(src: String, pos: I32) : I32 => {\n";
  code = code + "  let len = stringLen(src);\n";
  code = code + "  let mut p = pos;\n";
  code = code + "  while (p < len && is_ws(stringCharCodeAt(src, p))) {\n";
  code = code + "    p = p + 1;\n";
  code = code + "  }\n";
  code = code + "  p\n";
  code = code + "}\n\n";
  
  code = code + "fn ok_expr(expr: Expr, nextPos: I32) : ParsedExpr =>\n";
  code = code + "  ParsedExpr { true, expr, nextPos, \"\" }\n\n";
  
  code = code + "fn err_expr(pos: I32, error: String) : ParsedExpr =>\n";
  code = code + "  ParsedExpr { false, expr_int(span(0, 0), 0), pos, error }\n\n";
  
  code = code + "fn ok_string(value: String, nextPos: I32) : ParsedString =>\n";
  code = code + "  ParsedString { true, value, nextPos, \"\" }\n\n";
  
  code = code + "fn err_string(pos: I32, error: String) : ParsedString =>\n";
  code = code + "  ParsedString { false, \"\", pos, error }\n\n";
  
  code = code + "fn ok_i32(value: I32, nextPos: I32) : ParsedI32 =>\n";
  code = code + "  ParsedI32 { true, value, nextPos, \"\" }\n\n";
  
  code = code + "fn err_i32(pos: I32, error: String) : ParsedI32 =>\n";
  code = code + "  ParsedI32 { false, 0, pos, error }\n\n";
  
  // Generate expect_lit helper
  code = code + "fn expect_lit(src: String, pos: I32, lit: String) : ParsedString => {\n";
  code = code + "  let p = skip_ws(src, pos);\n";
  code = code + "  let len = stringLen(src);\n";
  code = code + "  let litLen = stringLen(lit);\n";
  code = code + "  if (p + litLen > len) {\n";
  code = code + "    yield err_string(p, \"expected '\" + lit + \"'\");\n";
  code = code + "  }\n";
  code = code + "  let mut i = 0;\n";
  code = code + "  while (i < litLen) {\n";
  code = code + "    if (stringCharCodeAt(src, p + i) != stringCharCodeAt(lit, i)) {\n";
  code = code + "      yield err_string(p, \"expected '\" + lit + \"'\");\n";
  code = code + "    }\n";
  code = code + "    i = i + 1;\n";
  code = code + "  }\n";
  code = code + "  ok_string(lit, p + litLen)\n";
  code = code + "}\n\n";
  
  // Generate parse_number helper
  code = code + "fn parse_number_raw(src: String, pos: I32) : ParsedI32 => {\n";
  code = code + "  let p = skip_ws(src, pos);\n";
  code = code + "  let len = stringLen(src);\n";
  code = code + "  if (p >= len) { yield err_i32(p, \"unexpected end\"); }\n";
  code = code + "  let c = stringCharCodeAt(src, p);\n";
  code = code + "  let is_digit = (c >= 48 && c <= 57);\n";
  code = code + "  if (is_digit == false) { yield err_i32(p, \"expected digit\"); }\n";
  code = code + "  let mut endp = p;\n";
  code = code + "  let mut value = 0;\n";
  code = code + "  while (endp < len) {\n";
  code = code + "    let d = stringCharCodeAt(src, endp);\n";
  code = code + "    let is_d = (d >= 48 && d <= 57);\n";
  code = code + "    if (is_d == false) { break; }\n";
  code = code + "    value = value * 10 + (d - 48);\n";
  code = code + "    endp = endp + 1;\n";
  code = code + "  }\n";
  code = code + "  ok_i32(value, endp)\n";
  code = code + "}\n\n";
  
  // Generate parse_ident_raw helper  
  code = code + "fn is_ident_start(c: I32) : Bool => (c >= 65 && c <= 90) || (c >= 97 && c <= 122) || c == 95\n\n";
  code = code + "fn is_ident_part(c: I32) : Bool => is_ident_start(c) || (c >= 48 && c <= 57)\n\n";
  
  code = code + "fn parse_ident_raw(src: String, pos: I32) : ParsedString => {\n";
  code = code + "  let p = skip_ws(src, pos);\n";
  code = code + "  let len = stringLen(src);\n";
  code = code + "  if (p >= len) { yield err_string(p, \"unexpected end\"); }\n";
  code = code + "  let c = stringCharCodeAt(src, p);\n";
  code = code + "  if (is_ident_start(c) == false) { yield err_string(p, \"expected identifier\"); }\n";
  code = code + "  let mut endp = p + 1;\n";
  code = code + "  while (endp < len && is_ident_part(stringCharCodeAt(src, endp))) {\n";
  code = code + "    endp = endp + 1;\n";
  code = code + "  }\n";
  code = code + "  ok_string(stringSlice(src, p, endp), endp)\n";
  code = code + "}\n\n";
  
  // Generate rule parsers
  code = code + "// =============================================================================\n";
  code = code + "// Generated Rule Parsers\n";
  code = code + "// =============================================================================\n\n";
  
  let mut i = 0;
  while (i < vec_len(g.rules)) {
    let rule = vec_get(g.rules, i);
    code = code + generate_ast_rule_parser(rule, config);
    code = code + "\n";
    i = i + 1;
  }
  
  code
}

fn generate_ast_rule_parser(rule: Rule, config: AstConfig) : String => {
  let mapping = find_mapping(config, rule.name);
  let returnType = if (stringLen(mapping.astType) > 0) "Parsed" + mapping.astType else "ParsedExpr";
  
  let mut code = "";
  code = code + "fn parse_" + rule.name + "(src: String, pos: I32) : " + returnType + " => {\n";
  code = code + "  let startPos = skip_ws(src, pos);\n";
  code = code + generate_ast_production_parser(rule.production, "startPos", rule.name, config, 1);
  code = code + "}\n";
  code
}

fn generate_ast_production_parser(prod: Production, posVar: String, ruleName: String, config: AstConfig, indentLevel: I32) : String => {
  if (prod is PSequence) {
    yield generate_ast_sequence_parser(prod, posVar, ruleName, config, indentLevel);
  }
  if (prod is PAlternation) {
    yield generate_ast_alternation_parser(prod, posVar, ruleName, config, indentLevel);
  }
  if (prod is PTerm) {
    yield generate_ast_term_parser(prod.term, posVar, ruleName, config, indentLevel);
  }
  ""
}

fn generate_ast_alternation_parser(prod: PAlternation, posVar: String, ruleName: String, config: AstConfig, indentLevel: I32) : String => {
  let ind = indent(indentLevel);
  let mut code = "";
  
  let mut i = 0;
  while (i < vec_len(prod.choices)) {
    let choice = vec_get(prod.choices, i);
    let tryVar = "try" + i;
    
    code = code + ind + "let " + tryVar + " = {\n";
    code = code + generate_ast_production_parser(choice, posVar, ruleName + "_alt" + i, config, indentLevel + 1);
    code = code + ind + "};\n";
    code = code + ind + "if (" + tryVar + ".success) { yield " + tryVar + "; }\n";
    
    i = i + 1;
  }
  
  code = code + ind + "err_expr(" + posVar + ", \"no alternative matched for " + ruleName + "\")\n";
  code
}

fn generate_ast_sequence_parser(prod: PSequence, posVar: String, ruleName: String, config: AstConfig, indentLevel: I32) : String => {
  let ind = indent(indentLevel);
  let mapping = find_mapping(config, ruleName);
  let mut code = "";
  
  // Check if this is a binary operator rule
  if (mapping.astConstructor == "__binary_left") {
    yield generate_ast_binary_parser(prod, posVar, ruleName, config, indentLevel);
  }
  
  code = code + ind + "let mut curPos = " + posVar + ";\n";
  
  let mut i = 0;
  while (i < vec_len(prod.terms)) {
    let term = vec_get(prod.terms, i);
    let partVar = "part" + i;
    
    code = code + ind + "let " + partVar + " = {\n";
    code = code + generate_ast_production_parser(term, "curPos", ruleName + "_part" + i, config, indentLevel + 1);
    code = code + ind + "};\n";
    code = code + ind + "if (" + partVar + ".success == false) {\n";
    code = code + ind + "  yield err_expr(curPos, " + partVar + ".error);\n";
    code = code + ind + "}\n";
    code = code + ind + "curPos = " + partVar + ".nextPos;\n";
    
    i = i + 1;
  }
  
  // Return last part's result (simplified)
  let lastIdx = vec_len(prod.terms) - 1;
  if (lastIdx >= 0) {
    code = code + ind + "part" + lastIdx + "\n";
  } else {
    code = code + ind + "ok_expr(expr_int(span(startPos, curPos), 0), curPos)\n";
  }
  
  code
}

fn generate_ast_binary_parser(prod: PSequence, posVar: String, ruleName: String, config: AstConfig, indentLevel: I32) : String => {
  // Generate a left-associative binary operator parser
  // Pattern: lower_expr (op lower_expr)*
  let ind = indent(indentLevel);
  let mut code = "";
  
  // We need to find the lower precedence rule and the operators
  // For now, assume the pattern is: first_term (op second_term)*
  
  if (vec_len(prod.terms) < 1) {
    yield ind + "err_expr(" + posVar + ", \"invalid binary rule\")\n";
  }
  
  let firstTerm = vec_get(prod.terms, 0);
  
  // Parse first operand
  code = code + ind + "let first = {\n";
  code = code + generate_ast_production_parser(firstTerm, posVar, ruleName + "_first", config, indentLevel + 1);
  code = code + ind + "};\n";
  code = code + ind + "if (first.success == false) { yield first; }\n";
  code = code + ind + "let mut left = first.expr;\n";
  code = code + ind + "let mut curPos = first.nextPos;\n";
  code = code + ind + "// Parse (op expr)* loop\n";
  code = code + ind + "while (true) {\n";
  
  // Try to parse operators - this is simplified for now
  // In a real implementation, we'd examine the grammar structure
  code = code + ind + "  let opPos = skip_ws(src, curPos);\n";
  code = code + ind + "  let len = stringLen(src);\n";
  code = code + ind + "  if (opPos >= len) { break; }\n";
  code = code + ind + "  // Check for operators (simplified - would need to extract from grammar)\n";
  code = code + ind + "  let c = stringCharCodeAt(src, opPos);\n";
  code = code + ind + "  let mut opMatch = false;\n";
  code = code + ind + "  let mut opFn = op_add;\n";
  code = code + ind + "  if (c == 43) { opMatch = true; opFn = op_add(); } // +\n";
  code = code + ind + "  if (c == 45) { opMatch = true; opFn = op_sub(); } // -\n";
  code = code + ind + "  if (c == 42) { opMatch = true; opFn = op_mul(); } // *\n";
  code = code + ind + "  if (c == 47) { opMatch = true; opFn = op_div(); } // /\n";
  code = code + ind + "  if (opMatch == false) { break; }\n";
  code = code + ind + "  let right = {\n";
  code = code + generate_ast_production_parser(firstTerm, "opPos + 1", ruleName + "_right", config, indentLevel + 2);
  code = code + ind + "  };\n";
  code = code + ind + "  if (right.success == false) { break; }\n";
  code = code + ind + "  left = expr_binary(span(startPos, right.nextPos), opFn, left, right.expr);\n";
  code = code + ind + "  curPos = right.nextPos;\n";
  code = code + ind + "}\n";
  code = code + ind + "ok_expr(left, curPos)\n";
  
  code
}

fn generate_ast_term_parser(term: Term, posVar: String, ruleName: String, config: AstConfig, indentLevel: I32) : String => {
  let ind = indent(indentLevel);
  
  if (term is TNonTerminal) {
    yield ind + "parse_" + term.name + "(src, " + posVar + ")\n";
  }
  
  if (term is TLiteral) {
    let mut code = "";
    code = code + ind + "{\n";
    code = code + ind + "  let lit = expect_lit(src, " + posVar + ", \"" + term.value + "\");\n";
    code = code + ind + "  if (lit.success) {\n";
    code = code + ind + "    ok_expr(expr_string(span(" + posVar + ", lit.nextPos), \"" + term.value + "\"), lit.nextPos)\n";
    code = code + ind + "  } else {\n";
    code = code + ind + "    err_expr(" + posVar + ", lit.error)\n";
    code = code + ind + "  }\n";
    code = code + ind + "}\n";
    yield code;
  }
  
  if (term is TCharClass) {
    yield generate_ast_char_class_parser(term, posVar, ruleName, config, indentLevel);
  }
  
  if (term is TRepeat) {
    yield generate_ast_repeat_parser(term, posVar, ruleName, config, indentLevel);
  }
  
  if (term is TGroup) {
    yield generate_ast_production_parser(term.inner, posVar, ruleName + "_group", config, indentLevel);
  }
  
  ind + "err_expr(" + posVar + ", \"unsupported term type\")\n"
}

fn generate_ast_char_class_parser(term: TCharClass, posVar: String, ruleName: String, config: AstConfig, indentLevel: I32) : String => {
  let ind = indent(indentLevel);
  let mut code = "";
  
  code = code + ind + "{\n";
  code = code + ind + "  let len = stringLen(src);\n";
  code = code + ind + "  let cp = skip_ws(src, " + posVar + ");\n";
  code = code + ind + "  if (cp >= len) { yield err_expr(cp, \"unexpected end\"); }\n";
  code = code + ind + "  let c = stringCharCodeAt(src, cp);\n";
  code = code + ind + "  let matched = ";
  
  // Generate range checks
  let mut i = 0;
  while (i < vec_len(term.ranges)) {
    let range = vec_get(term.ranges, i);
    if (i > 0) { code = code + " || "; }
    code = code + "(c >= " + range.start + " && c <= " + range.endChar + ")";
    i = i + 1;
  }
  
  if (vec_len(term.ranges) == 0) {
    code = code + "false";
  }
  
  code = code + ";\n";
  
  if (term.negated) {
    code = code + ind + "  if (matched) {\n";
  } else {
    code = code + ind + "  if (matched == false) {\n";
  }
  code = code + ind + "    yield err_expr(cp, \"character not in class\");\n";
  code = code + ind + "  }\n";
  code = code + ind + "  // For char class, return a string expr with the char\n";
  code = code + ind + "  ok_expr(expr_string(span(cp, cp + 1), stringSlice(src, cp, cp + 1)), cp + 1)\n";
  code = code + ind + "}\n";
  
  code
}

fn generate_ast_repeat_parser(term: TRepeat, posVar: String, ruleName: String, config: AstConfig, indentLevel: I32) : String => {
  let ind = indent(indentLevel);
  let mut code = "";
  
  if (term.kind is RepeatOptional) {
    // Optional: try to parse, return empty on failure
    code = code + ind + "{\n";
    code = code + ind + "  let opt = {\n";
    code = code + generate_ast_production_parser(term.inner, posVar, ruleName + "_opt", config, indentLevel + 2);
    code = code + ind + "  };\n";
    code = code + ind + "  if (opt.success) { opt } else {\n";
    code = code + ind + "    ok_expr(expr_int(span(" + posVar + ", " + posVar + "), 0), " + posVar + ")\n";
    code = code + ind + "  }\n";
    code = code + ind + "}\n";
    yield code;
  }
  
  // Zero-or-more or one-or-more
  code = code + ind + "{\n";
  code = code + ind + "  let items = vec_new();\n";
  code = code + ind + "  let mut curPos = " + posVar + ";\n";
  code = code + ind + "  let mut keepGoing = true;\n";
  code = code + ind + "  while (keepGoing) {\n";
  code = code + ind + "    let item = {\n";
  code = code + generate_ast_production_parser(term.inner, "curPos", ruleName + "_item", config, indentLevel + 3);
  code = code + ind + "    };\n";
  code = code + ind + "    if (item.success) {\n";
  code = code + ind + "      vec_push(items, item.expr);\n";
  code = code + ind + "      curPos = item.nextPos;\n";
  code = code + ind + "    } else {\n";
  code = code + ind + "      keepGoing = false;\n";
  code = code + ind + "    }\n";
  code = code + ind + "  }\n";
  
  if (term.kind is RepeatOneOrMore) {
    code = code + ind + "  if (vec_len(items) == 0) {\n";
    code = code + ind + "    yield err_expr(" + posVar + ", \"expected at least one\");\n";
    code = code + ind + "  }\n";
  }
  
  code = code + ind + "  // Return vec lit containing the items\n";
  code = code + ind + "  ok_expr(expr_vec_lit(span(" + posVar + ", curPos), items), curPos)\n";
  code = code + ind + "}\n";
  
  code
}
