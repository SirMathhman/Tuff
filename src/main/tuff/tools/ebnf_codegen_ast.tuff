// EBNF Code Generator for AST-Producing Parsers
// This module generates parsers that directly produce the Tuff AST types
// instead of generic CST nodes.
//
// The key difference from ebnf_codegen.tuff is that this generates code
// that calls the AST factory functions (expr_int, expr_binary, etc.)
// to construct typed AST nodes.

extern from rt::stdlib use { stringLen, stringSlice, stringCharCodeAt, stringFromCharCode };
extern from rt::vec use { vec_new, vec_push, vec_len, vec_get };

from src::main::tuff::tools::ebnf_parser use {
  Grammar,
  Rule,
  Production,
  PSequence,
  PAlternation,
  PTerm,
  Term,
  TNonTerminal,
  TLiteral,
  TCharClass,
  TRepeat,
  TGroup,
  TAnnotation,
  RepeatKind,
  RepeatZeroOrMore,
  RepeatOneOrMore,
  RepeatOptional,
  CharRange
};

// =============================================================================
// AST Mapping Configuration
// =============================================================================

// Maps rule names to AST constructor calls
// For example: "int_literal" -> "expr_int"

struct AstMapping {
  ruleName: String,
  astConstructor: String,
  // If non-empty, specifies the AST type (Expr, Stmt, Decl, etc.)
  astType: String
}

struct AstConfig {
  mappings: Vec<AstMapping>
}

out fn mk_ast_mapping(ruleName: String, constructor: String, astType: String) : AstMapping =>
  AstMapping { ruleName, constructor, astType }

out fn mk_ast_config() : AstConfig =>
  AstConfig { vec_new() }

out fn config_add_mapping(config: AstConfig, m: AstMapping) : Void => {
  vec_push(config.mappings, m);
}

fn find_mapping(config: AstConfig, ruleName: String) : AstMapping => {
  let mut i = 0;
  while (i < vec_len(config.mappings)) {
    let m = vec_get(config.mappings, i);
    if (m.ruleName == ruleName) {
      yield m;
    }
    i = i + 1;
  }
  AstMapping { "", "", "" }
}

// =============================================================================
// Default Tuff AST Mappings
// =============================================================================

out fn default_tuff_ast_config() : AstConfig => {
  let config = mk_ast_config();
  
  // Expression mappings
  config_add_mapping(config, mk_ast_mapping("int_literal", "expr_int", "Expr"));
  config_add_mapping(config, mk_ast_mapping("float_literal", "expr_float", "Expr"));
  config_add_mapping(config, mk_ast_mapping("bool_literal", "expr_bool", "Expr"));
  config_add_mapping(config, mk_ast_mapping("string_literal", "expr_string", "Expr"));
  config_add_mapping(config, mk_ast_mapping("ident", "expr_ident", "Expr"));
  config_add_mapping(config, mk_ast_mapping("if_expr", "expr_if", "Expr"));
  config_add_mapping(config, mk_ast_mapping("block", "expr_block", "Expr"));
  config_add_mapping(config, mk_ast_mapping("match_expr", "expr_match", "Expr"));
  config_add_mapping(config, mk_ast_mapping("lambda_expr", "expr_lambda", "Expr"));
  config_add_mapping(config, mk_ast_mapping("vec_lit", "expr_vec_lit", "Expr"));
  config_add_mapping(config, mk_ast_mapping("tuple_lit", "expr_tuple_lit", "Expr"));
  config_add_mapping(config, mk_ast_mapping("struct_lit", "expr_struct_lit", "Expr"));
  
  // Statement mappings
  config_add_mapping(config, mk_ast_mapping("let_stmt", "stmt_let", "Stmt"));
  config_add_mapping(config, mk_ast_mapping("assign_stmt", "stmt_assign", "Stmt"));
  config_add_mapping(config, mk_ast_mapping("yield_stmt", "stmt_yield", "Stmt"));
  config_add_mapping(config, mk_ast_mapping("while_stmt", "stmt_while", "Stmt"));
  config_add_mapping(config, mk_ast_mapping("if_stmt", "stmt_if", "Stmt"));
  config_add_mapping(config, mk_ast_mapping("expr_stmt", "stmt_expr", "Stmt"));
  
  // Declaration mappings
  config_add_mapping(config, mk_ast_mapping("fn_decl", "decl_fn", "Decl"));
  config_add_mapping(config, mk_ast_mapping("struct_decl", "decl_struct", "Decl"));
  config_add_mapping(config, mk_ast_mapping("type_decl", "decl_type_union", "Decl"));
  config_add_mapping(config, mk_ast_mapping("import_decl", "decl_import", "Decl"));
  config_add_mapping(config, mk_ast_mapping("extern_decl", "decl_extern_from", "Decl"));
  
  // Binary operators - these need special handling
  config_add_mapping(config, mk_ast_mapping("add_expr", "__binary_left", "Expr"));
  config_add_mapping(config, mk_ast_mapping("mul_expr", "__binary_left", "Expr"));
  config_add_mapping(config, mk_ast_mapping("or_expr", "__binary_left", "Expr"));
  config_add_mapping(config, mk_ast_mapping("and_expr", "__binary_left", "Expr"));
  config_add_mapping(config, mk_ast_mapping("eq_expr", "__binary_left", "Expr"));
  config_add_mapping(config, mk_ast_mapping("rel_expr", "__binary_left", "Expr"));
  
  // Unary operators
  config_add_mapping(config, mk_ast_mapping("unary_expr", "__unary", "Expr"));
  
  config
}

// =============================================================================
// Generate AST-Producing Parser
// =============================================================================

fn indent(level: I32) : String => {
  let mut s = "";
  let mut i = 0;
  while (i < level) {
    s = s + "  ";
    i = i + 1;
  }
  s
}

out fn generate_ast_parser(g: Grammar, config: AstConfig) : String => {
  let mut code = "";
  
  // Header
  code = code + "// Generated AST Parser - DO NOT EDIT\n";
  code = code + "// Generated from EBNF grammar\n";
  code = code + "// This parser produces Tuff AST nodes directly.\n\n";
  
  // Imports
  code = code + "extern from rt::stdlib use { stringLen, stringSlice, stringCharCodeAt, stringFromCharCode };\n";
  code = code + "extern from rt::vec use { vec_new, vec_push, vec_len, vec_get };\n\n";
  
  code = code + "from ast use {\n";
  code = code + "  span,\n";
  code = code + "  Expr, Stmt, Decl, Span,\n";
  code = code + "  expr_int, expr_float, expr_bool, expr_string, expr_ident,\n";
  code = code + "  expr_binary, expr_unary, expr_call, expr_if, expr_block,\n";
  code = code + "  expr_vec_lit, expr_tuple_lit, expr_struct_lit, expr_match,\n";
  code = code + "  expr_lambda, expr_field, expr_index, expr_tuple_index,\n";
  code = code + "  stmt_let, stmt_assign, stmt_expr, stmt_yield, stmt_while, stmt_if,\n";
  code = code + "  decl_fn, decl_struct, decl_type_union, decl_import, decl_extern_from,\n";
  code = code + "  op_add, op_sub, op_mul, op_div, op_eq, op_ne, op_lt, op_le, op_gt, op_ge, op_and, op_or,\n";
  code = code + "  op_not, op_neg\n";
  code = code + "};\n\n";
  
  // Parse result types
  code = code + "// =============================================================================\n";
  code = code + "// Parse Result Types\n";
  code = code + "// =============================================================================\n\n";
  
  code = code + "struct ParsedExpr {\n";
  code = code + "  success: Bool,\n";
  code = code + "  expr: Expr,\n";
  code = code + "  nextPos: I32,\n";
  code = code + "  error: String\n";
  code = code + "}\n\n";
  
  code = code + "struct ParsedStmt {\n";
  code = code + "  success: Bool,\n";
  code = code + "  stmt: Stmt,\n";
  code = code + "  nextPos: I32,\n";
  code = code + "  error: String\n";
  code = code + "}\n\n";
  
  code = code + "struct ParsedDecl {\n";
  code = code + "  success: Bool,\n";
  code = code + "  decl: Decl,\n";
  code = code + "  nextPos: I32,\n";
  code = code + "  error: String\n";
  code = code + "}\n\n";
  
  code = code + "struct ParsedString {\n";
  code = code + "  success: Bool,\n";
  code = code + "  value: String,\n";
  code = code + "  nextPos: I32,\n";
  code = code + "  error: String\n";
  code = code + "}\n\n";
  
  code = code + "struct ParsedI32 {\n";
  code = code + "  success: Bool,\n";
  code = code + "  value: I32,\n";
  code = code + "  nextPos: I32,\n";
  code = code + "  error: String\n";
  code = code + "}\n\n";
  
  // Helper functions
  code = code + "// =============================================================================\n";
  code = code + "// Helper Functions\n";
  code = code + "// =============================================================================\n\n";
  
  code = code + "fn is_ws(c: I32) : Bool => c == 32 || c == 9 || c == 10 || c == 13\n\n";
  
  code = code + "fn skip_ws(src: String, pos: I32) : I32 => {\n";
  code = code + "  let len = stringLen(src);\n";
  code = code + "  let mut p = pos;\n";
  // NOTE: Avoid '<' in generated code; it can be parsed as start of type args.
  code = code + "  while (len > p && is_ws(stringCharCodeAt(src, p))) {\n";
  code = code + "    p = p + 1;\n";
  code = code + "  }\n";
  code = code + "  p\n";
  code = code + "}\n\n";
  
  code = code + "fn ok_expr(expr: Expr, nextPos: I32) : ParsedExpr =>\n";
  code = code + "  ParsedExpr { true, expr, nextPos, \"\" }\n\n";
  
  code = code + "fn err_expr(pos: I32, error: String) : ParsedExpr =>\n";
  code = code + "  ParsedExpr { false, expr_int(span(0, 0), 0), pos, error }\n\n";
  
  code = code + "fn ok_string(value: String, nextPos: I32) : ParsedString =>\n";
  code = code + "  ParsedString { true, value, nextPos, \"\" }\n\n";
  
  code = code + "fn err_string(pos: I32, error: String) : ParsedString =>\n";
  code = code + "  ParsedString { false, \"\", pos, error }\n\n";
  
  code = code + "fn ok_i32(value: I32, nextPos: I32) : ParsedI32 =>\n";
  code = code + "  ParsedI32 { true, value, nextPos, \"\" }\n\n";
  
  code = code + "fn err_i32(pos: I32, error: String) : ParsedI32 =>\n";
  code = code + "  ParsedI32 { false, 0, pos, error }\n\n";
  
  // Generate expect_lit helper
  code = code + "fn expect_lit(src: String, pos: I32, lit: String) : ParsedString => {\n";
  code = code + "  let p = skip_ws(src, pos);\n";
  code = code + "  let len = stringLen(src);\n";
  code = code + "  let litLen = stringLen(lit);\n";
  code = code + "  if (p + litLen > len) {\n";
  code = code + "    yield err_string(p, \"expected '\" + lit + \"'\");\n";
  code = code + "  }\n";
  code = code + "  let mut i = 0;\n";
  code = code + "  while (i < litLen) {\n";
  code = code + "    if (stringCharCodeAt(src, p + i) != stringCharCodeAt(lit, i)) {\n";
  code = code + "      yield err_string(p, \"expected '\" + lit + \"'\");\n";
  code = code + "    }\n";
  code = code + "    i = i + 1;\n";
  code = code + "  }\n";
  code = code + "  ok_string(lit, p + litLen)\n";
  code = code + "}\n\n";
  
  // Generate parse_number helper
  code = code + "fn parse_number_raw(src: String, pos: I32) : ParsedI32 => {\n";
  code = code + "  let p = skip_ws(src, pos);\n";
  code = code + "  let len = stringLen(src);\n";
  code = code + "  if (p >= len) { yield err_i32(p, \"unexpected end\"); }\n";
  code = code + "  let c = stringCharCodeAt(src, p);\n";
  code = code + "  let is_digit = (c >= 48 && 57 >= c);\n";
  code = code + "  if (is_digit == false) { yield err_i32(p, \"expected digit\"); }\n";
  code = code + "  let mut endp = p;\n";
  code = code + "  let mut value = 0;\n";
  code = code + "  while (len > endp) {\n";
  code = code + "    let d = stringCharCodeAt(src, endp);\n";
  code = code + "    let is_d = (d >= 48 && 57 >= d);\n";
  code = code + "    if (is_d == false) { break; }\n";
  code = code + "    value = value * 10 + (d - 48);\n";
  code = code + "    endp = endp + 1;\n";
  code = code + "  }\n";
  code = code + "  ok_i32(value, endp)\n";
  code = code + "}\n\n";
  
  // Generate parse_ident_raw helper  
  code = code + "fn is_ident_start(c: I32) : Bool => (c >= 65 && 90 >= c) || (c >= 97 && 122 >= c) || c == 95\n\n";
  code = code + "fn is_ident_part(c: I32) : Bool => is_ident_start(c) || (c >= 48 && 57 >= c)\n\n";
  
  code = code + "fn parse_ident_raw(src: String, pos: I32) : ParsedString => {\n";
  code = code + "  let p = skip_ws(src, pos);\n";
  code = code + "  let len = stringLen(src);\n";
  code = code + "  if (p >= len) { yield err_string(p, \"unexpected end\"); }\n";
  code = code + "  let c = stringCharCodeAt(src, p);\n";
  code = code + "  if (is_ident_start(c) == false) { yield err_string(p, \"expected identifier\"); }\n";
  code = code + "  let mut endp = p + 1;\n";
  code = code + "  while (len > endp && is_ident_part(stringCharCodeAt(src, endp))) {\n";
  code = code + "    endp = endp + 1;\n";
  code = code + "  }\n";
  code = code + "  ok_string(stringSlice(src, p, endp), endp)\n";
  code = code + "}\n\n";
  
  // Generate rule parsers
  code = code + "// =============================================================================\n";
  code = code + "// Generated Rule Parsers\n";
  code = code + "// =============================================================================\n\n";
  
  let mut i = 0;
  while (i < vec_len(g.rules)) {
    let rule = vec_get(g.rules, i);
    code = code + generate_ast_rule_parser(rule, config);
    code = code + "\n";
    i = i + 1;
  }
  
  code
}

fn generate_ast_rule_parser(rule: Rule, config: AstConfig) : String => {
  let mapping = find_mapping(config, rule.name);
  let returnType = if (stringLen(mapping.astType) > 0) "Parsed" + mapping.astType else "ParsedExpr";
  
  let mut code = "";
  code = code + "out fn parse_" + rule.name + "(src: String, pos: I32) : " + returnType + " => {\n";
  code = code + "  let startPos = skip_ws(src, pos);\n";

  // Hand-written fast paths for common token-like rules.
  // Without these, a rule like `int_literal ::= [0-9]+` would produce a Vec
  // of per-digit nodes rather than a single Expr.
  if (rule.name == "int_literal") {
    code = code + "  let n = parse_number_raw(src, startPos);\n";
    code = code + "  if (n.success == false) { yield err_expr(startPos, n.error); }\n";
    code = code + "  ok_expr(expr_int(span(startPos, n.nextPos), n.value), n.nextPos)\n";
    code = code + "}\n";
    yield code;
  }

  if (rule.name == "ident") {
    code = code + "  let id = parse_ident_raw(src, startPos);\n";
    code = code + "  if (id.success == false) { yield err_expr(startPos, id.error); }\n";
    code = code + "  ok_expr(expr_ident(span(startPos, id.nextPos), id.value), id.nextPos)\n";
    code = code + "}\n";
    yield code;
  }

  if (rule.name == "unary_expr") {
    code = code + "  let len = stringLen(src);\n";
    code = code + "  if (len > startPos) {\n";
    code = code + "    let c = stringCharCodeAt(src, startPos);\n";
    code = code + "    if (c == 45) { // '-'\n";
    code = code + "      let inner = parse_unary_expr(src, startPos + 1);\n";
    code = code + "      if (inner.success == false) { yield inner; }\n";
    code = code + "      yield ok_expr(expr_unary(span(startPos, inner.nextPos), op_neg(), inner.expr), inner.nextPos);\n";
    code = code + "    }\n";
    code = code + "    if (c == 33) { // '!'\n";
    code = code + "      let inner = parse_unary_expr(src, startPos + 1);\n";
    code = code + "      if (inner.success == false) { yield inner; }\n";
    code = code + "      yield ok_expr(expr_unary(span(startPos, inner.nextPos), op_not(), inner.expr), inner.nextPos);\n";
    code = code + "    }\n";
    code = code + "  }\n";
    code = code + "  parse_postfix_expr(src, startPos)\n";
    code = code + "}\n";
    yield code;
  }

  // `atom` is token-ish, but includes parenthesized expressions.
  if (rule.name == "atom") {
    code = code + "  // ( expr ) | int_literal | ident\n";
    code = code + "  let len = stringLen(src);\n";
    code = code + "  if (len > startPos && stringCharCodeAt(src, startPos) == 40) { // '('\n";
    code = code + "    let inner = parse_expr(src, startPos + 1);\n";
    code = code + "    if (inner.success == false) { yield inner; }\n";
    code = code + "    let close = expect_lit(src, inner.nextPos, \")\");\n";
    code = code + "    if (close.success == false) { yield err_expr(inner.nextPos, close.error); }\n";
    code = code + "    yield ok_expr(inner.expr, close.nextPos);\n";
    code = code + "  }\n";
    code = code + "  let n = parse_number_raw(src, startPos);\n";
    code = code + "  if (n.success) { yield ok_expr(expr_int(span(startPos, n.nextPos), n.value), n.nextPos); }\n";
    code = code + "  let id = parse_ident_raw(src, startPos);\n";
    code = code + "  if (id.success == false) { yield err_expr(startPos, id.error); }\n";
    code = code + "  ok_expr(expr_ident(span(startPos, id.nextPos), id.value), id.nextPos)\n";
    code = code + "}\n";
    yield code;
  }

  // Postfix expression builder for: calls, field access, indexing.
  // This is intentionally handwritten to keep the generator simple while we
  // iterate on grammar coverage.
  if (rule.name == "postfix_expr") {
    code = code + "  let base0 = parse_atom(src, startPos);\n";
    code = code + "  if (base0.success == false) { yield base0; }\n";
    code = code + "  let mut base = base0.expr;\n";
    code = code + "  let mut p = base0.nextPos;\n";
    code = code + "  let len = stringLen(src);\n";
    code = code + "  while (true) {\n";
    code = code + "    let opPos = skip_ws(src, p);\n";
    code = code + "    if (opPos >= len) { break; }\n";
    code = code + "    let c = stringCharCodeAt(src, opPos);\n";

    // call: '(' arg_list? ')'
    code = code + "    if (c == 40) { // '('\n";
    code = code + "      let mut args = vec_new();\n";
    code = code + "      let mut ap = opPos + 1;\n";
    code = code + "      ap = skip_ws(src, ap);\n";
    code = code + "      if (len > ap && stringCharCodeAt(src, ap) != 41) {\n";
    code = code + "        let a0 = parse_expr(src, ap);\n";
    code = code + "        if (a0.success == false) { yield a0; }\n";
    code = code + "        vec_push(args, a0.expr);\n";
    code = code + "        ap = a0.nextPos;\n";
    code = code + "        while (true) {\n";
    code = code + "          let comma = expect_lit(src, ap, \",\");\n";
    code = code + "          if (comma.success == false) { break; }\n";
    code = code + "          let aN = parse_expr(src, comma.nextPos);\n";
    code = code + "          if (aN.success == false) { yield aN; }\n";
    code = code + "          vec_push(args, aN.expr);\n";
    code = code + "          ap = aN.nextPos;\n";
    code = code + "        }\n";
    code = code + "      }\n";
    code = code + "      let close = expect_lit(src, ap, \")\");\n";
    code = code + "      if (close.success == false) { yield err_expr(ap, close.error); }\n";
    code = code + "      base = expr_call(span(startPos, close.nextPos), base, args);\n";
    code = code + "      p = close.nextPos;\n";
    code = code + "      continue;\n";
    code = code + "    }\n";

    // field: '.' ident
    code = code + "    if (c == 46) { // '.'\n";
    code = code + "      let id = parse_ident_raw(src, opPos + 1);\n";
    code = code + "      if (id.success == false) { yield err_expr(opPos + 1, id.error); }\n";
    code = code + "      base = expr_field(span(startPos, id.nextPos), base, id.value);\n";
    code = code + "      p = id.nextPos;\n";
    code = code + "      continue;\n";
    code = code + "    }\n";

    // index: '[' expr ']'
    code = code + "    if (c == 91) { // '['\n";
    code = code + "      let ix = parse_expr(src, opPos + 1);\n";
    code = code + "      if (ix.success == false) { yield ix; }\n";
    code = code + "      let close = expect_lit(src, ix.nextPos, \"]\");\n";
    code = code + "      if (close.success == false) { yield err_expr(ix.nextPos, close.error); }\n";
    code = code + "      base = expr_index(span(startPos, close.nextPos), base, ix.expr);\n";
    code = code + "      p = close.nextPos;\n";
    code = code + "      continue;\n";
    code = code + "    }\n";

    code = code + "    break;\n";
    code = code + "  }\n";
    code = code + "  ok_expr(base, p)\n";
    code = code + "}\n";
    yield code;
  }

  code = code + generate_ast_production_parser(rule.production, "startPos", rule.name, config, 1);
  code = code + "}\n";
  code
}

fn generate_ast_production_parser(prod: Production, posVar: String, ruleName: String, config: AstConfig, indentLevel: I32) : String => {
  if (prod is PSequence) {
    yield generate_ast_sequence_parser(prod, posVar, ruleName, config, indentLevel);
  }
  if (prod is PAlternation) {
    yield generate_ast_alternation_parser(prod, posVar, ruleName, config, indentLevel);
  }
  if (prod is PTerm) {
    yield generate_ast_term_parser(prod.term, posVar, ruleName, config, indentLevel);
  }
  ""
}

fn generate_ast_alternation_parser(prod: PAlternation, posVar: String, ruleName: String, config: AstConfig, indentLevel: I32) : String => {
  let ind = indent(indentLevel);
  let mut code = "";
  
  let mut i = 0;
  while (i < vec_len(prod.choices)) {
    let choice = vec_get(prod.choices, i);
    let tryVar = ruleName + "_try" + i;
    
    code = code + ind + "let " + tryVar + " = {\n";
    code = code + generate_ast_production_parser(choice, posVar, ruleName + "_alt" + i, config, indentLevel + 1);
    code = code + ind + "};\n";
    code = code + ind + "if (" + tryVar + ".success) { yield " + tryVar + "; }\n";
    
    i = i + 1;
  }
  
  code = code + ind + "err_expr(" + posVar + ", \"no alternative matched for " + ruleName + "\")\n";
  code
}

fn generate_ast_sequence_parser(prod: PSequence, posVar: String, ruleName: String, config: AstConfig, indentLevel: I32) : String => {
  let ind = indent(indentLevel);
  let mapping = find_mapping(config, ruleName);
  let mut code = "";
  
  // Check if this is a binary operator rule
  if (mapping.astConstructor == "__binary_left") {
    yield generate_ast_binary_parser(prod, posVar, ruleName, config, indentLevel);
  }

  // IMPORTANT: no-shadowing rule means we must avoid generic names like
  // `curPos` / `part0` in nested blocks. Use rule-scoped names instead.
  let seqPos = ruleName + "_pos";
  code = code + ind + "let mut " + seqPos + " = " + posVar + ";\n";
  
  let mut i = 0;
  while (i < vec_len(prod.terms)) {
    let term = vec_get(prod.terms, i);
    let partVar = ruleName + "_part" + i;
    
    code = code + ind + "let " + partVar + " = {\n";
    code = code + generate_ast_production_parser(term, seqPos, ruleName + "_part" + i, config, indentLevel + 1);
    code = code + ind + "};\n";
    code = code + ind + "if (" + partVar + ".success == false) {\n";
    code = code + ind + "  yield err_expr(" + seqPos + ", " + partVar + ".error);\n";
    code = code + ind + "}\n";
    code = code + ind + seqPos + " = " + partVar + ".nextPos;\n";
    
    i = i + 1;
  }
  
  // Return the last *meaningful* part.
  // Many sequences end with punctuation literals like ")" or ";" which we
  // don't want to become the returned Expr.
  let mut retIdx = vec_len(prod.terms) - 1;
  while (retIdx >= 0) {
    let p = vec_get(prod.terms, retIdx);
    if (p is PTerm) {
      if (p.term is TLiteral) {
        retIdx = retIdx - 1;
        continue;
      }
    }
    break;
  }
  if (retIdx >= 0) {
    // Use the selected expr, but advance to the sequence's final position.
    code = code + ind + "ok_expr(" + ruleName + "_part" + retIdx + ".expr, " + seqPos + ")\n";
  } else {
    code = code + ind + "ok_expr(expr_int(span(startPos, " + seqPos + "), 0), " + seqPos + ")\n";
  }
  
  code
}

fn generate_ast_binary_parser(prod: PSequence, posVar: String, ruleName: String, config: AstConfig, indentLevel: I32) : String => {
  // Generate a left-associative binary operator parser
  // Pattern: lower_expr (op lower_expr)*
  let ind = indent(indentLevel);
  let mut code = "";
  
  // We need to find the lower precedence rule and the operators
  // For now, assume the pattern is: first_term (op second_term)*
  
  if (vec_len(prod.terms) < 1) {
    yield ind + "err_expr(" + posVar + ", \"invalid binary rule\")\n";
  }
  
  let firstTerm = vec_get(prod.terms, 0);

  let firstVar = ruleName + "_first";
  let leftVar = ruleName + "_left";
  let curPosVar = ruleName + "_pos";
  let opPosVar = ruleName + "_opPos";
  let opValVar = ruleName + "_opVal";
  let opMatchVar = ruleName + "_opMatch";
  let rightVar = ruleName + "_right";
  
  // Parse first operand
  code = code + ind + "let " + firstVar + " = {\n";
  code = code + generate_ast_production_parser(firstTerm, posVar, ruleName + "_first", config, indentLevel + 1);
  code = code + ind + "};\n";
  code = code + ind + "if (" + firstVar + ".success == false) { yield " + firstVar + "; }\n";
  code = code + ind + "let mut " + leftVar + " = " + firstVar + ".expr;\n";
  code = code + ind + "let mut " + curPosVar + " = " + firstVar + ".nextPos;\n";
  code = code + ind + "// Parse (op expr)* loop\n";
  code = code + ind + "while (true) {\n";
  
  // Try to parse operators - this is simplified for now
  // In a real implementation, we'd examine the grammar structure
  code = code + ind + "  let " + opPosVar + " = skip_ws(src, " + curPosVar + ");\n";
  code = code + ind + "  let len = stringLen(src);\n";
  code = code + ind + "  if (" + opPosVar + " >= len) { break; }\n";
  code = code + ind + "  // Check for operators (simplified - would need to extract from grammar)\n";
  code = code + ind + "  let c = stringCharCodeAt(src, " + opPosVar + ");\n";
  code = code + ind + "  let mut " + opMatchVar + " = false;\n";
  code = code + ind + "  let mut " + opValVar + " = op_add();\n";

  // Operator sets are tied to the specific precedence level.
  if (ruleName == "add_expr") {
    code = code + ind + "  if (c == 43) { " + opMatchVar + " = true; " + opValVar + " = op_add(); } // +\n";
    code = code + ind + "  if (c == 45) { " + opMatchVar + " = true; " + opValVar + " = op_sub(); } // -\n";
  } else {
    if (ruleName == "mul_expr") {
      code = code + ind + "  if (c == 42) { " + opMatchVar + " = true; " + opValVar + " = op_mul(); } // *\n";
      code = code + ind + "  if (c == 47) { " + opMatchVar + " = true; " + opValVar + " = op_div(); } // /\n";
    } else {
      // Fallback (older behavior): accept basic arithmetic ops.
      code = code + ind + "  if (c == 43) { " + opMatchVar + " = true; " + opValVar + " = op_add(); } // +\n";
      code = code + ind + "  if (c == 45) { " + opMatchVar + " = true; " + opValVar + " = op_sub(); } // -\n";
      code = code + ind + "  if (c == 42) { " + opMatchVar + " = true; " + opValVar + " = op_mul(); } // *\n";
      code = code + ind + "  if (c == 47) { " + opMatchVar + " = true; " + opValVar + " = op_div(); } // /\n";
    }
  }
  code = code + ind + "  if (" + opMatchVar + " == false) { break; }\n";
  code = code + ind + "  let " + rightVar + " = {\n";
  code = code + generate_ast_production_parser(firstTerm, opPosVar + " + 1", ruleName + "_right", config, indentLevel + 2);
  code = code + ind + "  };\n";
  code = code + ind + "  if (" + rightVar + ".success == false) { break; }\n";
  code = code + ind + "  " + leftVar + " = expr_binary(span(startPos, " + rightVar + ".nextPos), " + opValVar + ", " + leftVar + ", " + rightVar + ".expr);\n";
  code = code + ind + "  " + curPosVar + " = " + rightVar + ".nextPos;\n";
  code = code + ind + "}\n";
  code = code + ind + "ok_expr(" + leftVar + ", " + curPosVar + ")\n";
  
  code
}

fn generate_ast_term_parser(term: Term, posVar: String, ruleName: String, config: AstConfig, indentLevel: I32) : String => {
  let ind = indent(indentLevel);
  
  if (term is TNonTerminal) {
    yield ind + "parse_" + term.name + "(src, " + posVar + ")\n";
  }
  
  if (term is TLiteral) {
    let mut code = "";
    code = code + ind + "{\n";
    code = code + ind + "  let lit = expect_lit(src, " + posVar + ", \"" + term.value + "\");\n";
    code = code + ind + "  if (lit.success) {\n";
    code = code + ind + "    ok_expr(expr_string(span(" + posVar + ", lit.nextPos), \"" + term.value + "\"), lit.nextPos)\n";
    code = code + ind + "  } else {\n";
    code = code + ind + "    err_expr(" + posVar + ", lit.error)\n";
    code = code + ind + "  }\n";
    code = code + ind + "}\n";
    yield code;
  }
  
  if (term is TCharClass) {
    yield generate_ast_char_class_parser(term, posVar, ruleName, config, indentLevel);
  }
  
  if (term is TRepeat) {
    yield generate_ast_repeat_parser(term, posVar, ruleName, config, indentLevel);
  }
  
  if (term is TGroup) {
    yield generate_ast_production_parser(term.inner, posVar, ruleName + "_group", config, indentLevel);
  }
  
  ind + "err_expr(" + posVar + ", \"unsupported term type\")\n"
}

fn generate_ast_char_class_parser(term: TCharClass, posVar: String, ruleName: String, config: AstConfig, indentLevel: I32) : String => {
  let ind = indent(indentLevel);
  let mut code = "";
  
  code = code + ind + "{\n";
  code = code + ind + "  let len = stringLen(src);\n";
  code = code + ind + "  let cp = skip_ws(src, " + posVar + ");\n";
  code = code + ind + "  if (cp >= len) { yield err_expr(cp, \"unexpected end\"); }\n";
  code = code + ind + "  let c = stringCharCodeAt(src, cp);\n";
  // IMPORTANT: avoid identifiers that start with keywords like `match`.
  code = code + ind + "  let inClass = ";
  
  // Generate range checks
  let mut i = 0;
  while (i < vec_len(term.ranges)) {
    let range = vec_get(term.ranges, i);
    if (i > 0) { code = code + " || "; }
    code = code + "(c >= " + range.start + " && " + range.endChar + " >= c)";
    i = i + 1;
  }
  
  if (vec_len(term.ranges) == 0) {
    code = code + "false";
  }
  
  code = code + ";\n";
  
  if (term.negated) {
    code = code + ind + "  if (inClass) {\n";
  } else {
    code = code + ind + "  if (inClass == false) {\n";
  }
  code = code + ind + "    yield err_expr(cp, \"character not in class\");\n";
  code = code + ind + "  }\n";
  code = code + ind + "  // For char class, return a string expr with the char\n";
  code = code + ind + "  ok_expr(expr_string(span(cp, cp + 1), stringSlice(src, cp, cp + 1)), cp + 1)\n";
  code = code + ind + "}\n";
  
  code
}

fn generate_ast_repeat_parser(term: TRepeat, posVar: String, ruleName: String, config: AstConfig, indentLevel: I32) : String => {
  let ind = indent(indentLevel);
  let mut code = "";
  
  if (term.kind is RepeatOptional) {
    // Optional: try to parse, return empty on failure
    code = code + ind + "{\n";
    code = code + ind + "  let opt = {\n";
    code = code + generate_ast_production_parser(term.inner, posVar, ruleName + "_opt", config, indentLevel + 2);
    code = code + ind + "  };\n";
    code = code + ind + "  if (opt.success) { opt } else {\n";
    code = code + ind + "    ok_expr(expr_int(span(" + posVar + ", " + posVar + "), 0), " + posVar + ")\n";
    code = code + ind + "  }\n";
    code = code + ind + "}\n";
    yield code;
  }
  
  // Zero-or-more or one-or-more
  code = code + ind + "{\n";
  let itemsVar = ruleName + "_items";
  let repPosVar = ruleName + "_repPos";
  let keepVar = ruleName + "_keepGoing";
  let itemVar = ruleName + "_item";

  code = code + ind + "  let " + itemsVar + " = vec_new();\n";
  code = code + ind + "  let mut " + repPosVar + " = " + posVar + ";\n";
  code = code + ind + "  let mut " + keepVar + " = true;\n";
  code = code + ind + "  while (" + keepVar + ") {\n";
  code = code + ind + "    let " + itemVar + " = {\n";
  code = code + generate_ast_production_parser(term.inner, repPosVar, ruleName + "_item", config, indentLevel + 3);
  code = code + ind + "    };\n";
  code = code + ind + "    if (" + itemVar + ".success) {\n";
  code = code + ind + "      vec_push(" + itemsVar + ", " + itemVar + ".expr);\n";
  code = code + ind + "      " + repPosVar + " = " + itemVar + ".nextPos;\n";
  code = code + ind + "    } else {\n";
  code = code + ind + "      " + keepVar + " = false;\n";
  code = code + ind + "    }\n";
  code = code + ind + "  }\n";
  
  if (term.kind is RepeatOneOrMore) {
    code = code + ind + "  if (vec_len(" + itemsVar + ") == 0) {\n";
    code = code + ind + "    yield err_expr(" + posVar + ", \"expected at least one\");\n";
    code = code + ind + "  }\n";
  }
  
  code = code + ind + "  // Return vec lit containing the items\n";
  code = code + ind + "  ok_expr(expr_vec_lit(span(" + posVar + ", " + repPosVar + "), " + itemsVar + "), " + repPosVar + ")\n";
  code = code + ind + "}\n";
  
  code
}
