// Test: End-to-end generated parser execution
// 
// This test generates a parser for a minimal expression language and then
// runs the SAME pattern manually to prove the generated code would work.
// 
// This is a stepping stone to full self-hosting.

extern from rt::vec use { vec_new, vec_len, vec_get, vec_push };
extern from rt::stdlib use { print, println, stringLen, stringSlice, stringCharCodeAt, stringFromCharCode };

from std::test use { reset, suite, it, expect_eq, expect_true, expect_false, summary, status };

from src::main::tuff::tools::ebnf_parser use { parse_grammar };
from src::main::tuff::tools::ebnf_codegen_ast use { generate_ast_parser, default_tuff_ast_config };

// =============================================================================
// Inline AST types (same pattern as generated parser would use)
// =============================================================================

struct Span {
  startPos: I32,
  endPos: I32
}

fn span(start: I32, endPos: I32) : Span => Span { start, endPos }
fn span_start(s: Span) : I32 => s.startPos
fn span_end(s: Span) : I32 => s.endPos

type Expr =
    EInt
  | EBool
  | EString
  | EIdent
  | EBinary
  | EUnary
  | EVecLit;

struct EInt { span: Span, value: I32 }
struct EBool { span: Span, value: Bool }
struct EString { span: Span, value: String }
struct EIdent { span: Span, name: String }
struct EBinary { span: Span, op: String, left: Expr, right: Expr }
struct EUnary { span: Span, op: String, expr: Expr }
struct EVecLit { span: Span, items: Vec<Expr> }

fn expr_int(s: Span, v: I32) : Expr => EInt { s, v }
fn expr_bool(s: Span, v: Bool) : Expr => EBool { s, v }
fn expr_string(s: Span, v: String) : Expr => EString { s, v }
fn expr_ident(s: Span, n: String) : Expr => EIdent { s, n }
fn expr_binary(s: Span, op: String, l: Expr, r: Expr) : Expr => EBinary { s, op, l, r }
fn expr_unary(s: Span, op: String, e: Expr) : Expr => EUnary { s, op, e }
fn expr_vec_lit(s: Span, items: Vec<Expr>) : Expr => EVecLit { s, items }

fn expr_span(e: Expr) : Span => e.span

// =============================================================================
// Parse result types (same pattern as generated)
// =============================================================================

struct ParsedExpr {
  success: Bool,
  expr: Expr,
  nextPos: I32,
  error: String
}

fn ok_expr(expr: Expr, nextPos: I32) : ParsedExpr =>
  ParsedExpr { true, expr, nextPos, "" }

fn err_expr(pos: I32, error: String) : ParsedExpr =>
  ParsedExpr { false, expr_int(span(0, 0), 0), pos, error }

// =============================================================================
// Helper functions (same pattern as generated)
// =============================================================================

fn is_ws(c: I32) : Bool => c == 32 || c == 9 || c == 10 || c == 13

fn lessThan(a: I32, b: I32) : Bool => a < b

fn skip_ws(src: String, pos: I32) : I32 => {
  let srcLen = stringLen(src);
  let mut p = pos;
  while (lessThan(p, srcLen) && is_ws(stringCharCodeAt(src, p))) {
    p = p + 1;
  }
  p
}

fn is_ident_start(c: I32) : Bool => (c >= 65 && c <= 90) || (c >= 97 && c <= 122) || c == 95
fn is_ident_part(c: I32) : Bool => is_ident_start(c) || (c >= 48 && c <= 57)

fn expect_lit(src: String, pos: I32, lit: String) : ParsedExpr => {
  let p = skip_ws(src, pos);
  let len = stringLen(src);
  let litLen = stringLen(lit);
  if (p + litLen > len) {
    yield err_expr(p, "expected '" + lit + "'");
  }
  let mut i = 0;
  while (lessThan(i, litLen)) {
    if (stringCharCodeAt(src, p + i) != stringCharCodeAt(lit, i)) {
      yield err_expr(p, "expected '" + lit + "'");
    }
    i = i + 1;
  }
  ok_expr(expr_string(span(p, p + litLen), lit), p + litLen)
}

// =============================================================================
// Generated parser pattern (manually written, mirrors generated code)
// =============================================================================

// Grammar:
//   expr     ::= add_expr
//   add_expr ::= mul_expr (('+' | '-') mul_expr)*
//   mul_expr ::= unary (('*' | '/') unary)*
//   unary    ::= '-' unary | '!' unary | primary
//   primary  ::= number | ident | 'true' | 'false' | '(' expr ')'
//   number   ::= [0-9]+
//   ident    ::= [a-zA-Z_][a-zA-Z0-9_]*

fn parse_number(src: String, pos: I32) : ParsedExpr => {
  let p = skip_ws(src, pos);
  let len = stringLen(src);
  if (p >= len) { yield err_expr(p, "unexpected end"); }
  let c = stringCharCodeAt(src, p);
  let is_digit = (c >= 48 && c <= 57);
  if (is_digit == false) { yield err_expr(p, "expected digit"); }
  let mut endp = p;
  let mut value = 0;
  while (lessThan(endp, len)) {
    let d = stringCharCodeAt(src, endp);
    let is_d = (d >= 48 && d <= 57);
    if (is_d == false) { break; }
    value = value * 10 + (d - 48);
    endp = endp + 1;
  }
  ok_expr(expr_int(span(p, endp), value), endp)
}

fn parse_ident(src: String, pos: I32) : ParsedExpr => {
  let p = skip_ws(src, pos);
  let len = stringLen(src);
  if (p >= len) { yield err_expr(p, "unexpected end"); }
  let c = stringCharCodeAt(src, p);
  if (is_ident_start(c) == false) { yield err_expr(p, "expected identifier"); }
  let mut endp = p + 1;
  while (lessThan(endp, len) && is_ident_part(stringCharCodeAt(src, endp))) {
    endp = endp + 1;
  }
  let name = stringSlice(src, p, endp);
  // Check for reserved words
  if (name == "true") {
    yield ok_expr(expr_bool(span(p, endp), true), endp);
  }
  if (name == "false") {
    yield ok_expr(expr_bool(span(p, endp), false), endp);
  }
  ok_expr(expr_ident(span(p, endp), name), endp)
}

fn parse_primary(src: String, pos: I32) : ParsedExpr => {
  let p = skip_ws(src, pos);
  let len = stringLen(src);
  if (p >= len) { yield err_expr(p, "unexpected end"); }
  let c = stringCharCodeAt(src, p);
  
  // Check for '('
  if (c == 40) {
    let inner = parse_expr(src, p + 1);
    if (inner.success == false) { yield inner; }
    let close = expect_lit(src, inner.nextPos, ")");
    if (close.success == false) { yield close; }
    yield ok_expr(inner.expr, close.nextPos);
  }
  
  // Try number first
  let numResult = parse_number(src, p);
  if (numResult.success) { yield numResult; }
  
  // Try identifier
  parse_ident(src, p)
}

fn parse_unary(src: String, pos: I32) : ParsedExpr => {
  let p = skip_ws(src, pos);
  let len = stringLen(src);
  if (p >= len) { yield parse_primary(src, p); }
  
  let c = stringCharCodeAt(src, p);
  
  // Check for '-'
  if (c == 45) {
    let inner = parse_unary(src, p + 1);
    if (inner.success == false) { yield inner; }
    yield ok_expr(expr_unary(span(p, inner.nextPos), "-", inner.expr), inner.nextPos);
  }
  
  // Check for '!'
  if (c == 33) {
    let inner = parse_unary(src, p + 1);
    if (inner.success == false) { yield inner; }
    yield ok_expr(expr_unary(span(p, inner.nextPos), "!", inner.expr), inner.nextPos);
  }
  
  parse_primary(src, p)
}

fn parse_mul_expr(src: String, pos: I32) : ParsedExpr => {
  let startPos = skip_ws(src, pos);
  let first = parse_unary(src, startPos);
  if (first.success == false) { yield first; }
  
  let mut left = first.expr;
  let mut curPos = first.nextPos;
  
  while (true) {
    let cp = skip_ws(src, curPos);
    let len = stringLen(src);
    if (cp >= len) { break; }
    
    let c = stringCharCodeAt(src, cp);
    let mut op = "";
    if (c == 42) { op = "*"; }  // *
    if (c == 47) { op = "/"; }  // /
    
    if (stringLen(op) == 0) { break; }
    
    let right = parse_unary(src, cp + 1);
    if (right.success == false) { break; }
    
    left = expr_binary(span(startPos, right.nextPos), op, left, right.expr);
    curPos = right.nextPos;
  }
  
  ok_expr(left, curPos)
}

fn parse_add_expr(src: String, pos: I32) : ParsedExpr => {
  let startPos = skip_ws(src, pos);
  let first = parse_mul_expr(src, startPos);
  if (first.success == false) { yield first; }
  
  let mut left = first.expr;
  let mut curPos = first.nextPos;
  
  while (true) {
    let cp = skip_ws(src, curPos);
    let len = stringLen(src);
    if (cp >= len) { break; }
    
    let c = stringCharCodeAt(src, cp);
    let mut op = "";
    if (c == 43) { op = "+"; }  // +
    if (c == 45) { op = "-"; }  // -
    
    if (stringLen(op) == 0) { break; }
    
    let right = parse_mul_expr(src, cp + 1);
    if (right.success == false) { break; }
    
    left = expr_binary(span(startPos, right.nextPos), op, left, right.expr);
    curPos = right.nextPos;
  }
  
  ok_expr(left, curPos)
}

fn parse_expr(src: String, pos: I32) : ParsedExpr => parse_add_expr(src, pos)

// =============================================================================
// Evaluate expression for testing
// =============================================================================

fn eval_expr(e: Expr) : I32 => {
  if (e is EInt) { yield e.value; }
  if (e is EBinary) {
    let l = eval_expr(e.left);
    let r = eval_expr(e.right);
    if (e.op == "+") { yield l + r; }
    if (e.op == "-") { yield l - r; }
    if (e.op == "*") { yield l * r; }
    if (e.op == "/") { yield l / r; }
    yield 0;
  }
  if (e is EUnary) {
    let inner = eval_expr(e.expr);
    if (e.op == "-") { yield 0 - inner; }
    yield inner;
  }
  0
}

fn expr_to_string(e: Expr) : String => {
  if (e is EInt) { yield "" + e.value; }
  if (e is EBool) { yield if (e.value) "true" else "false"; }
  if (e is EIdent) { yield e.name; }
  if (e is EBinary) {
    yield "(" + expr_to_string(e.left) + " " + e.op + " " + expr_to_string(e.right) + ")";
  }
  if (e is EUnary) {
    yield "(" + e.op + expr_to_string(e.expr) + ")";
  }
  "?"
}

// =============================================================================
// Tests
// =============================================================================

out fn run() : I32 => {
  reset();
  
  suite("End-to-end generated parser pattern");
  
  // Basic parsing
  let r1 = parse_expr("42", 0);
  it("parses 42", expect_true("success", r1.success));
  it("42 is EInt", expect_true("is EInt", r1.expr is EInt));
  it("42 value", expect_eq("value", eval_expr(r1.expr), 42));
  
  // Addition
  let r2 = parse_expr("1 + 2", 0);
  it("parses 1+2", expect_true("success", r2.success));
  it("1+2 = 3", expect_eq("eval", eval_expr(r2.expr), 3));
  
  // Precedence
  let r3 = parse_expr("1 + 2 * 3", 0);
  it("parses 1+2*3", expect_true("success", r3.success));
  it("1+2*3 = 7", expect_eq("eval", eval_expr(r3.expr), 7));
  println("  Tree: " + expr_to_string(r3.expr));
  
  // Parentheses
  let r4 = parse_expr("(1 + 2) * 3", 0);
  it("parses (1+2)*3", expect_true("success", r4.success));
  it("(1+2)*3 = 9", expect_eq("eval", eval_expr(r4.expr), 9));
  println("  Tree: " + expr_to_string(r4.expr));
  
  // Unary minus
  let r5 = parse_expr("-5", 0);
  it("parses -5", expect_true("success", r5.success));
  it("-5 = -5", expect_eq("eval", eval_expr(r5.expr), 0 - 5));
  
  // Complex expression
  let r6 = parse_expr("10 - 3 * 2", 0);
  it("parses 10-3*2", expect_true("success", r6.success));
  it("10-3*2 = 4", expect_eq("eval", eval_expr(r6.expr), 4));
  
  // Boolean literals
  let r7 = parse_expr("true", 0);
  it("parses true", expect_true("success", r7.success));
  it("true is EBool", expect_true("is EBool", r7.expr is EBool));
  
  // Identifier
  let r8 = parse_expr("foo", 0);
  it("parses foo", expect_true("success", r8.success));
  it("foo is EIdent", expect_true("is EIdent", r8.expr is EIdent));
  
  suite("Code generator produces correct structure");
  
  // Generate parser for the same grammar
  let grammar = parse_grammar("
    expr     ::= add_expr ;
    add_expr ::= mul_expr (('+' | '-') mul_expr)* ;
    mul_expr ::= unary (('*' | '/') unary)* ;
    unary    ::= '-' unary | '!' unary | primary ;
    primary  ::= number | ident | '(' expr ')' ;
    number   ::= [0-9]+ ;
    ident    ::= [a-zA-Z_] [a-zA-Z0-9_]* ;
  ");
  
  it("grammar parses", expect_true("success", grammar.success));
  
  if (grammar.success) {
    let config = default_tuff_ast_config();
    let genCode = generate_ast_parser(grammar.value, config);
    
    it("generates parse_expr", expect_true("fn", stringContains(genCode, "fn parse_expr")));
    it("generates parse_add_expr", expect_true("fn", stringContains(genCode, "fn parse_add_expr")));
    it("generates parse_mul_expr", expect_true("fn", stringContains(genCode, "fn parse_mul_expr")));
    it("generates parse_unary", expect_true("fn", stringContains(genCode, "fn parse_unary")));
    it("generates parse_primary", expect_true("fn", stringContains(genCode, "fn parse_primary")));
    
    // The pattern matches what we manually implemented
    it("has binary parsing", expect_true("binary", stringContains(genCode, "expr_binary")));
    it("has span tracking", expect_true("span", stringContains(genCode, "span(")));
  }
  
  summary();
  status()
}

// Helper to check if string contains substring
fn stringContains(haystack: String, needle: String) : Bool => {
  let hLen = stringLen(haystack);
  let nLen = stringLen(needle);
  if (nLen > hLen) { yield false; }
  if (nLen == 0) { yield true; }
  
  let mut i = 0;
  while (i <= hLen - nLen) {
    let mut j = 0;
    let mut found = true;
    while (j < nLen && found) {
      if (stringCharCodeAt(haystack, i + j) != stringCharCodeAt(needle, j)) {
        found = false;
      }
      j = j + 1;
    }
    if (found) { yield true; }
    i = i + 1;
  }
  false
}
