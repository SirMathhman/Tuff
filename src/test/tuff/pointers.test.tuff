// Test pointer types (*mut T)
// In JS backend, pointers work as follows:
// - &expr creates { value: expr }
// - *ptr reads ptr.value
// - Pointers to objects share the object reference

from std::test use { reset, suite, it, expect_eq, summary, status };

struct Point {
  x: I32,
  y: I32
}

struct Container {
  value: I32
}

out fn run() : I32 => {
  reset();
  suite("pointers - struct reference sharing");

  // Test 1: Pointer to struct - shared reference
  let mut pt: Point = Point { 10, 20 };
  let pp: *mut Point = &pt;
  it("pointer to struct - read x", expect_eq("(*pp).x", (*pp).x, 10));
  it("pointer to struct - read y", expect_eq("(*pp).y", (*pp).y, 20));

  // Test 2: Modify struct field directly, pointer should see it
  pt.x = 50;
  it("pointer sees direct changes", expect_eq("(*pp).x after pt.x = 50", (*pp).x, 50));

  // Test 3: Modify through field access on dereferenced pointer is also visible
  pt.y = 100;
  it("pointer sees y change", expect_eq("(*pp).y after pt.y = 100", (*pp).y, 100));

  suite("pointers - pointer copy for structs");

  // Test 4: Copying pointer shares the struct reference
  let pp2: *mut Point = pp;
  it("copied pointer reads same x", expect_eq("(*pp2).x", (*pp2).x, 50));
  it("copied pointer reads same y", expect_eq("(*pp2).y", (*pp2).y, 100));

  suite("pointers - read through pointer");

  // Test 5: Simple read through pointer
  let mut c: Container = Container { 42 };
  let pc: *mut Container = &c;
  it("read through pointer", expect_eq("(*pc).value", (*pc).value, 42));

  // Test 6: Modify original, pointer sees it
  c.value = 99;
  it("pointer sees field modification", expect_eq("(*pc).value after c.value = 99", (*pc).value, 99));

  summary();
  status()
}
