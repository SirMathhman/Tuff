// Test for the EBNF Parser and Validator

extern from rt::vec use { vec_new, vec_len, vec_get };
extern from rt::stdlib use { print, readTextFile, stringLen, stringSlice, stringCharCodeAt };

from std::test use { reset, suite, it, expect_eq, expect_true, expect_false, summary, status };

from src::main::tuff::tools::ebnf_parser use {
  parse_grammar,
  grammar_to_string
};

from src::main::tuff::tools::ebnf_validator use {
  validate_grammar,
  print_validation_result
};

from src::main::tuff::tools::ebnf_codegen use {
  generate_parser,
  generate_emitter,
  generate_code
};

out fn run() : I32 => {
  reset();
  suite("EBNF Parser");
  
  // Test 1: Simple rule with literal
  let result1 = parse_grammar("foo ::= \"bar\" ;");
  it("parses simple literal rule", expect_true("success", result1.success));
  it("has one rule", expect_eq("rule count", vec_len(result1.value.rules), 1));
  if (result1.success && vec_len(result1.value.rules) > 0) {
    let rule = vec_get(result1.value.rules, 0);
    it("rule name is foo", expect_eq("name", rule.name, "foo"));
  }
  
  // Test 2: Rule with alternation
  let result2 = parse_grammar("digit ::= \"0\" | \"1\" | \"2\" ;");
  it("parses alternation rule", expect_true("success", result2.success));
  
  // Test 3: Rule with sequence
  let result3 = parse_grammar("pair ::= ident \":\" expr ;");
  it("parses sequence rule", expect_true("success", result3.success));
  
  // Test 4: Rule with repetition
  let result4 = parse_grammar("list ::= item* ;");
  it("parses zero-or-more", expect_true("success", result4.success));
  
  let result5 = parse_grammar("list ::= item+ ;");
  it("parses one-or-more", expect_true("success", result5.success));
  
  let result6 = parse_grammar("opt ::= item? ;");
  it("parses optional", expect_true("success", result6.success));
  
  // Test 5: Rule with character class
  let result7 = parse_grammar("digit ::= [0-9] ;");
  it("parses character class", expect_true("success", result7.success));
  
  // Test 6: Rule with grouping
  let result8 = parse_grammar("expr ::= (\"a\" | \"b\")+ ;");
  it("parses grouped alternation", expect_true("success", result8.success));
  
  // Test 7: Comments
  let result9 = parse_grammar("(* This is a comment *) foo ::= bar ;");
  it("ignores multi-line comments", expect_true("success", result9.success));
  
  let result10 = parse_grammar("// Single line comment\nfoo ::= bar ;");
  it("ignores single-line comments", expect_true("success", result10.success));
  
  // Test 8: Annotations
  let result11 = parse_grammar("expr ::= @space foo ;");
  it("parses annotation without args", expect_true("success", result11.success));
  
  let result12 = parse_grammar("expr ::= @indent(foo bar) ;");
  it("parses annotation with args", expect_true("success", result12.success));
  
  // Test 9: Multiple rules
  let result13 = parse_grammar("a ::= \"x\" ; b ::= \"y\" ; c ::= a b ;");
  it("parses multiple rules", expect_true("success", result13.success));
  it("has three rules", expect_eq("rule count", vec_len(result13.value.rules), 3));
  
  // Test 10: Round-trip (parse and re-emit)
  let src = "foo ::= bar | baz ;";
  let parsed = parse_grammar(src);
  if (parsed.success) {
    let emitted = grammar_to_string(parsed.value);
    print("Original: " + src);
    print("Emitted:  " + emitted);
  }
  
  // Test 11: Negated character class
  let result14 = parse_grammar("notdigit ::= [^0-9] ;");
  it("parses negated character class", expect_true("success", result14.success));
  
  // Test 12: Complex expression grammar
  let complexGrammar = "
    expr ::= term (('+' | '-') term)* ;
    term ::= factor (('*' | '/') factor)* ;
    factor ::= number | '(' expr ')' ;
    number ::= [0-9]+ ;
  ";
  let result15 = parse_grammar(complexGrammar);
  it("parses complex arithmetic grammar", expect_true("success", result15.success));
  it("complex grammar has 4 rules", expect_eq("rule count", vec_len(result15.value.rules), 4));
  
  // ==========================================================================
  // VALIDATION TESTS
  // ==========================================================================
  
  suite("EBNF Validator");
  
  // Test: Valid grammar passes validation
  let validGrammar = parse_grammar("a ::= b ; b ::= \"x\" ;");
  let validResult = validate_grammar(validGrammar.value);
  it("valid grammar passes", expect_true("valid", validResult.valid));
  it("valid grammar has no errors", expect_eq("error count", vec_len(validResult.errors), 0));
  
  // Test: Undefined non-terminal is detected
  let undefinedGrammar = parse_grammar("a ::= b c ; b ::= \"x\" ;");
  let undefinedResult = validate_grammar(undefinedGrammar.value);
  it("detects undefined non-terminal", expect_false("valid", undefinedResult.valid));
  it("has error for undefined", expect_eq("error count", vec_len(undefinedResult.errors), 1));
  
  // Test: Duplicate rule names are detected
  let dupGrammar = parse_grammar("a ::= \"x\" ; a ::= \"y\" ;");
  let dupResult = validate_grammar(dupGrammar.value);
  it("detects duplicate rule names", expect_false("valid", dupResult.valid));
  
  // Test: Self-referential rule is valid (not left recursive in our simple check)
  let selfRefGrammar = parse_grammar("expr ::= expr \"+\" term | term ; term ::= \"x\" ;");
  let selfRefResult = validate_grammar(selfRefGrammar.value);
  it("self-referential rule is syntactically valid", expect_true("valid", selfRefResult.valid));
  
  // Test: Complex valid grammar
  let complexValid = parse_grammar("
    program ::= decl* ;
    decl ::= fn_decl | struct_decl ;
    fn_decl ::= \"fn\" ident \"(\" \")\" ;
    struct_decl ::= \"struct\" ident \"{\" \"}\" ;
    ident ::= [a-zA-Z]+ ;
  ");
  let complexValidResult = validate_grammar(complexValid.value);
  it("complex grammar is valid", expect_true("valid", complexValidResult.valid));
  it("complex grammar has no errors", expect_eq("error count", vec_len(complexValidResult.errors), 0));
  
  // ==========================================================================
  // CODE GENERATION TESTS
  // ==========================================================================
  
  suite("EBNF Code Generator");
  
  // Test: Generate parser for simple grammar
  let simpleGrammar = parse_grammar("foo ::= \"bar\" ;");
  let parserCode = generate_parser(simpleGrammar.value);
  it("generates parser code", expect_true("has content", stringLen(parserCode) > 100));
  
  // Test: Parser code contains expected function
  let containsParseFunc = stringContains(parserCode, "fn parse_foo");
  it("parser has parse_foo function", expect_true("contains fn", containsParseFunc));
  
  // Test: Parser code contains helper functions
  let containsSkipWs = stringContains(parserCode, "fn skip_ws");
  it("parser has skip_ws helper", expect_true("contains helper", containsSkipWs));
  
  // Test: Generate emitter for simple grammar
  let emitterCode = generate_emitter(simpleGrammar.value);
  it("generates emitter code", expect_true("has content", stringLen(emitterCode) > 100));
  
  // Test: Emitter code contains expected function
  let containsEmitFunc = stringContains(emitterCode, "fn emit_foo");
  it("emitter has emit_foo function", expect_true("contains fn", containsEmitFunc));
  
  // Test: Generate code for expression grammar
  let exprGrammar = parse_grammar("
    expr ::= term (\"+\" term)* ;
    term ::= \"x\" | \"y\" ;
  ");
  let exprCode = generate_code(exprGrammar.value);
  it("generates both parser and emitter", expect_true("parser exists", stringLen(exprCode.parserCode) > 0));
  it("emitter exists too", expect_true("emitter exists", stringLen(exprCode.emitterCode) > 0));
  
  // Test: Print generated code for inspection
  print("=== Generated Parser (first 500 chars) ===");
  print(stringSlice(parserCode, 0, 500));
  print("=== Generated Emitter (first 500 chars) ===");
  print(stringSlice(emitterCode, 0, 500));
  
  summary();
  status()
}

// Helper to check if string contains substring
fn stringContains(haystack: String, needle: String) : Bool => {
  let hLen = stringLen(haystack);
  let nLen = stringLen(needle);
  if (nLen > hLen) { yield false; }
  if (nLen == 0) { yield true; }
  
  let mut i = 0;
  while (i <= hLen - nLen) {
    let mut j = 0;
    let mut found = true;
    while (j < nLen && found) {
      if (stringCharCodeAt(haystack, i + j) != stringCharCodeAt(needle, j)) {
        found = false;
      }
      j = j + 1;
    }
    if (found) { yield true; }
    i = i + 1;
  }
  false
}
