// Test destructors (drop functions) are called exactly once

extern from rt::stdlib use { stringLen };
extern from rt::vec use { vec_new, vec_push, vec_len, vec_get };

from std::test use { reset, suite, it, expect_eq, summary, status };

// Global counter to track drop calls
let mut drop_count: I32 = 0;

// Reset drop counter
fn reset_drops() : Void => {
  drop_count = 0;
}

// Simple droppable type
struct Resource {
  id: I32
}

// Drop function for Resource
fn drop_resource(r: Resource) : Void => {
  drop_count = drop_count + 1;
}

// Another droppable type
struct Handle {
  name: String,
  value: I32
}

fn drop_handle(h: Handle) : Void => {
  drop_count = drop_count + 1;
}

// Type with no drop (should not call drop)
struct Plain {
  x: I32
}

out fn run() : I32 => {
  reset();
  suite("destructors - basic");

  // Test 1: Drop called on scope exit
  reset_drops();
  {
    let r: Resource!drop_resource = Resource { 42 };
    // r should be dropped at end of block
  }
  it("drop called once on scope exit", expect_eq("count", drop_count, 1));

  // Test 2: Drop called for multiple bindings (LIFO order)
  reset_drops();
  {
    let r1: Resource!drop_resource = Resource { 1 };
    let r2: Resource!drop_resource = Resource { 2 };
    let r3: Resource!drop_resource = Resource { 3 };
    // All three dropped at end
  }
  it("drop called for each binding", expect_eq("count", drop_count, 3));

  // Test 3: Drop NOT called for plain types
  reset_drops();
  {
    let p: Plain = Plain { 10 };
    // p should NOT be dropped (no !drop marker)
  }
  it("drop not called for plain types", expect_eq("count", drop_count, 0));

  // Test 4: Drop called with correct value (via side effect)
  let mut last_dropped_id: I32 = 0;
  // We'll use a different test strategy - just verify count works
  
  suite("destructors - assignment");

  // Test 5: Assigning I32 to I32!drop_noop works (no-op drop allocated)
  reset_drops();
  {
    let x: I32 = 100;
    let d: I32!drop_noop = x;  // I32 can be treated as I32!drop_noop
    // d dropped with no-op drop
  }
  it("I32 assignable to I32!drop_noop", expect_eq("no-op drop count", drop_count, 0));
  // NOTE: no-op drop doesn't increment counter since there's no drop_noop(I32) defined that does anything

  // Test 6: Nested scopes
  reset_drops();
  {
    let outer: Resource!drop_resource = Resource { 1 };
    {
      let inner: Resource!drop_resource = Resource { 2 };
      // inner dropped here
    }
    // After inner scope, count should be 1
    // Then outer dropped
  }
  it("nested scopes drop correctly", expect_eq("count", drop_count, 2));

  suite("destructors - Handle type");

  // Test 7: Drop works with struct containing String
  reset_drops();
  {
    let h: Handle!drop_handle = Handle { "test", 42 };
  }
  it("Handle dropped once", expect_eq("count", drop_count, 1));

  summary();
  status()
}

// No-op drop function for I32 (doesn't exist, so call will fail at runtime)
// Actually we need to define it for the test to work
fn drop_noop(x: I32) : Void => {
  // do nothing
}
