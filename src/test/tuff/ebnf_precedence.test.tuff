// Test that the generated parser handles operator precedence correctly
// This validates that the grammar structure (expr → or_expr → ... → mul_expr) 
// produces correct precedence without special handling

extern from rt::vec use { vec_new, vec_len, vec_get, vec_push };
extern from rt::stdlib use { print, println, stringLen, stringSlice, stringCharCodeAt };

from std::test use { reset, suite, it, expect_eq, expect_true, expect_false, summary, status };

from src::main::tuff::tools::ebnf_parser use {
  parse_grammar,
  grammar_to_string
};

from src::main::tuff::tools::ebnf_codegen use {
  generate_parser,
  generate_emitter
};

// =============================================================================
// Manual implementation of a precedence-aware parser (mirrors generated pattern)
// Grammar:
//   expr     ::= add_expr
//   add_expr ::= mul_expr ('+' mul_expr)*
//   mul_expr ::= primary (('*' | '/') primary)*
//   primary  ::= number | '(' expr ')'
// =============================================================================

struct ParseResult {
  success: Bool,
  node: Node,
  nextPos: I32,
  error: String
}

type Node =
    NInt
  | NBinOp
  | NEmpty;

struct NInt {
  value: I32
}

struct NBinOp {
  op: String,
  left: Node,
  right: Node
}

struct NEmpty {}

fn ok_node(node: Node, nextPos: I32) : ParseResult =>
  ParseResult { true, node, nextPos, "" }

fn err_parse(pos: I32, error: String) : ParseResult =>
  ParseResult { false, NEmpty {}, pos, error }

fn is_ws(c: I32) : Bool => c == 32 || c == 9 || c == 10 || c == 13

fn skip_ws(src: String, pos: I32) : I32 => {
  let len = stringLen(src);
  let mut p = pos;
  while (p < len && is_ws(stringCharCodeAt(src, p))) {
    p = p + 1;
  }
  p
}

fn parse_number(src: String, pos: I32) : ParseResult => {
  let p = skip_ws(src, pos);
  let len = stringLen(src);
  
  if (p >= len) {
    yield err_parse(p, "unexpected end");
  }
  
  let c = stringCharCodeAt(src, p);
  let is_digit = (c >= 48 && c <= 57);
  if (is_digit == false) {
    yield err_parse(p, "expected digit");
  }
  
  let mut endp = p;
  let mut value = 0;
  while (endp < len) {
    let d = stringCharCodeAt(src, endp);
    let is_d = (d >= 48 && d <= 57);
    if (is_d == false) { break; }
    value = value * 10 + (d - 48);
    endp = endp + 1;
  }
  
  ok_node(NInt { value }, endp)
}

fn expect_char(src: String, pos: I32, ch: I32) : ParseResult => {
  let p = skip_ws(src, pos);
  let len = stringLen(src);
  if (p >= len || stringCharCodeAt(src, p) != ch) {
    yield err_parse(p, "expected char");
  }
  ok_node(NEmpty {}, p + 1)
}

fn parse_primary(src: String, pos: I32) : ParseResult => {
  let p = skip_ws(src, pos);
  let len = stringLen(src);
  
  if (p >= len) {
    yield err_parse(p, "unexpected end");
  }
  
  let c = stringCharCodeAt(src, p);
  
  // Check for '('
  if (c == 40) {
    let inner = parse_expr(src, p + 1);
    if (inner.success == false) { yield inner; }
    let close = expect_char(src, inner.nextPos, 41);  // ')'
    if (close.success == false) { yield close; }
    yield ok_node(inner.node, close.nextPos);
  }
  
  // Otherwise parse number
  parse_number(src, p)
}

fn parse_mul_expr(src: String, pos: I32) : ParseResult => {
  // mul_expr ::= primary (('*' | '/') primary)*
  let p = skip_ws(src, pos);
  
  let first = parse_primary(src, p);
  if (first.success == false) { yield first; }
  
  let mut left = first.node;
  let mut curPos = first.nextPos;
  
  while (true) {
    let cp = skip_ws(src, curPos);
    let len = stringLen(src);
    if (cp >= len) { break; }
    
    let c = stringCharCodeAt(src, cp);
    let mut op = "";
    if (c == 42) { op = "*"; }  // *
    if (c == 47) { op = "/"; }  // /
    
    if (stringLen(op) == 0) { break; }
    
    let right = parse_primary(src, cp + 1);
    if (right.success == false) { break; }
    
    left = NBinOp { op, left, right.node };
    curPos = right.nextPos;
  }
  
  ok_node(left, curPos)
}

fn parse_add_expr(src: String, pos: I32) : ParseResult => {
  // add_expr ::= mul_expr ('+' mul_expr | '-' mul_expr)*
  let p = skip_ws(src, pos);
  
  let first = parse_mul_expr(src, p);
  if (first.success == false) { yield first; }
  
  let mut left = first.node;
  let mut curPos = first.nextPos;
  
  while (true) {
    let cp = skip_ws(src, curPos);
    let len = stringLen(src);
    if (cp >= len) { break; }
    
    let c = stringCharCodeAt(src, cp);
    let mut op = "";
    if (c == 43) { op = "+"; }  // +
    if (c == 45) { op = "-"; }  // -
    
    if (stringLen(op) == 0) { break; }
    
    let right = parse_mul_expr(src, cp + 1);
    if (right.success == false) { break; }
    
    left = NBinOp { op, left, right.node };
    curPos = right.nextPos;
  }
  
  ok_node(left, curPos)
}

fn parse_expr(src: String, pos: I32) : ParseResult => {
  parse_add_expr(src, pos)
}

// Evaluate the parsed expression tree
fn eval_node(n: Node) : I32 => {
  if (n is NInt) { yield n.value; }
  if (n is NBinOp) {
    let l = eval_node(n.left);
    let r = eval_node(n.right);
    if (n.op == "+") { yield l + r; }
    if (n.op == "-") { yield l - r; }
    if (n.op == "*") { yield l * r; }
    if (n.op == "/") { yield l / r; }
    yield 0;
  }
  0
}

// Pretty-print the parse tree to show structure
fn node_to_string(n: Node) : String => {
  if (n is NInt) { yield "" + n.value; }
  if (n is NBinOp) {
    yield "(" + node_to_string(n.left) + " " + n.op + " " + node_to_string(n.right) + ")";
  }
  "?"
}

fn main() : I32 => {
  reset();
  
  suite("Precedence-aware parsing");
  
  // Test: Simple number
  let r1 = parse_expr("42", 0);
  it("parses single number", expect_true("success", r1.success));
  it("42 evaluates to 42", expect_eq("eval", eval_node(r1.node), 42));
  
  // Test: Simple addition
  let r2 = parse_expr("1 + 2", 0);
  it("parses 1 + 2", expect_true("success", r2.success));
  it("1 + 2 = 3", expect_eq("eval", eval_node(r2.node), 3));
  
  // Test: Precedence - mul before add
  let r3 = parse_expr("1 + 2 * 3", 0);
  it("parses 1 + 2 * 3", expect_true("success", r3.success));
  it("1 + 2 * 3 = 7 (not 9)", expect_eq("eval", eval_node(r3.node), 7));
  println("  Tree: " + node_to_string(r3.node));  // Should show (1 + (2 * 3))
  
  // Test: Precedence - mul before add (reversed)
  let r4 = parse_expr("2 * 3 + 1", 0);
  it("parses 2 * 3 + 1", expect_true("success", r4.success));
  it("2 * 3 + 1 = 7", expect_eq("eval", eval_node(r4.node), 7));
  println("  Tree: " + node_to_string(r4.node));  // Should show ((2 * 3) + 1)
  
  // Test: Complex precedence
  let r5 = parse_expr("1 + 2 * 3 + 4 * 5", 0);
  it("parses 1 + 2 * 3 + 4 * 5", expect_true("success", r5.success));
  it("1 + 2*3 + 4*5 = 27", expect_eq("eval", eval_node(r5.node), 27));
  println("  Tree: " + node_to_string(r5.node));
  
  // Test: Parentheses override precedence
  let r6 = parse_expr("(1 + 2) * 3", 0);
  it("parses (1 + 2) * 3", expect_true("success", r6.success));
  it("(1 + 2) * 3 = 9", expect_eq("eval", eval_node(r6.node), 9));
  println("  Tree: " + node_to_string(r6.node));  // Should show ((1 + 2) * 3)
  
  // Test: Multiplication precedence over subtraction
  let r7 = parse_expr("8 - 2 * 3", 0);
  it("parses 8 - 2 * 3", expect_true("success", r7.success));
  it("8 - 2 * 3 = 2 (not 18)", expect_eq("eval", eval_node(r7.node), 2));
  
  // Test: Left associativity of subtraction
  let r8 = parse_expr("10 - 3 - 2", 0);
  it("parses 10 - 3 - 2", expect_true("success", r8.success));
  it("10 - 3 - 2 = 5 (left-assoc)", expect_eq("eval", eval_node(r8.node), 5));
  println("  Tree: " + node_to_string(r8.node));  // Should show ((10 - 3) - 2)
  
  // ==========================================================================
  // Verify the EBNF grammar structure handles precedence
  // ==========================================================================
  
  suite("EBNF grammar precedence structure");
  
  let exprGrammar = parse_grammar("
    expr     ::= add_expr ;
    add_expr ::= mul_expr (('+' | '-') mul_expr)* ;
    mul_expr ::= primary (('*' | '/') primary)* ;
    primary  ::= [0-9]+ | '(' expr ')' ;
  ");
  
  it("expression grammar parses", expect_true("success", exprGrammar.success));
  
  if (exprGrammar.success) {
    let genParser = generate_parser(exprGrammar.value);
    
    // Check generated parser has the right function calls
    it("has parse_expr", expect_true("fn", stringContains(genParser, "fn parse_expr")));
    it("has parse_add_expr", expect_true("fn", stringContains(genParser, "fn parse_add_expr")));
    it("has parse_mul_expr", expect_true("fn", stringContains(genParser, "fn parse_mul_expr")));
    it("has parse_primary", expect_true("fn", stringContains(genParser, "fn parse_primary")));
    
    // Check that parse_expr calls parse_add_expr (precedence chain)
    it("expr calls add_expr", expect_true("call", stringContains(genParser, "parse_add_expr(src")));
    
    // Check that parse_add_expr calls parse_mul_expr  
    it("add_expr calls mul_expr", expect_true("call", stringContains(genParser, "parse_mul_expr(src")));
  }
  
  summary();
  status()
}

// Helper to check if string contains substring
fn stringContains(haystack: String, needle: String) : Bool => {
  let hLen = stringLen(haystack);
  let nLen = stringLen(needle);
  if (nLen > hLen) { yield false; }
  if (nLen == 0) { yield true; }
  
  let mut i = 0;
  while (i <= hLen - nLen) {
    let mut j = 0;
    let mut found = true;
    while (j < nLen && found) {
      if (stringCharCodeAt(haystack, i + j) != stringCharCodeAt(needle, j)) {
        found = false;
      }
      j = j + 1;
    }
    if (found) { yield true; }
    i = i + 1;
  }
  false
}
