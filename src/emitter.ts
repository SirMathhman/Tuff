import type {
  BlockExpr,
  BreakStmt,
  Expr,
  FnDecl,
  IfExpr,
  LetDecl,
  LoopExpr,
  MatchExpr,
  ModuleDecl,
  Program,
  Stmt,
  ThisExpr,
  TopLevelItem,
  TypeUnionDecl,
} from "./ast";

export type EmitResult = {
  js: string;
};

export function emitESM(program: Program): EmitResult {
  const w = new Writer();
  // bootstrap runtime helpers (minimal)
  w.line(`// Generated by tuff bootstrap compiler`);

  // Emit top-level items
  for (const item of program.items) {
    emitTopLevel(item, w);
    w.line();
  }

  return { js: w.toString() };
}

function emitTopLevel(item: TopLevelItem, w: Writer) {
  switch (item.kind) {
    case "ImportDecl": {
      const local = item.modulePath[item.modulePath.length - 1];
      const spec = `./${item.modulePath.join("/")}.mjs`;
      w.line(`import * as ${local} from ${JSON.stringify(spec)};`);
      return;
    }
    case "FromUseDecl": {
      const spec = `./${item.modulePath.join("/")}.mjs`;
      w.line(
        `import { ${item.names.join(", ")} } from ${JSON.stringify(spec)};`
      );
      return;
    }
    case "ExternFromUseDecl": {
      // Map :: path to ESM specifier (best effort). Example: node::fs => node:fs
      const spec = mapExternModule(item.modulePath);
      w.line(
        `import { ${item.names.join(", ")} } from ${JSON.stringify(spec)};`
      );
      return;
    }
    case "ModuleDecl":
      emitModule(item, w);
      return;
    case "TypeUnionDecl":
      emitTypeUnion(item, w);
      return;
    case "LetDecl":
      emitLet(item, w, true);
      return;
    case "FnDecl":
      emitFnDecl(item, w, true);
      return;
    default:
      // ignore
      return;
  }
}

function emitModule(mod: ModuleDecl, w: Writer) {
  w.line(`export const ${mod.name} = (() => {`);
  w.indent();
  // inside module: emit declarations and return namespace object
  const exports: string[] = [];
  for (const it of mod.items) {
    if (it.kind === "LetDecl") {
      emitLet(it, w, false);
      exports.push(it.name);
    } else if (it.kind === "FnDecl" && it.name) {
      emitFnDecl(it, w, false);
      exports.push(it.name);
    } else if (it.kind === "TypeUnionDecl") {
      emitTypeUnion(it, w);
      exports.push(...it.variants.map((v) => v.name));
    } else if (it.kind === "ModuleDecl") {
      emitModule(it, w);
      exports.push(it.name);
    }
  }
  w.line(`return { ${exports.join(", ")} };`);
  w.dedent();
  w.line(`})();`);
}

function emitTypeUnion(tu: TypeUnionDecl, w: Writer) {
  // Type itself is erased; emit constructors for variants
  for (const v of tu.variants) {
    if (v.typeArg) {
      // payload variant
      w.line(
        `export const ${v.name} = (value) => ({ tag: ${JSON.stringify(
          v.name
        )}, value });`
      );
    } else {
      w.line(`export const ${v.name} = { tag: ${JSON.stringify(v.name)} };`);
    }
  }
}

function emitLet(decl: LetDecl, w: Writer, exported: boolean) {
  const kw = decl.mutable ? "let" : "const";
  const exp = exported ? "export " : "";
  if (decl.init) {
    w.line(`${exp}${kw} ${decl.name} = ${emitExpr(decl.init, w)};`);
  } else {
    w.line(`${exp}${kw} ${decl.name} = undefined;`);
  }
}

function emitFnDecl(fn: FnDecl, w: Writer, exported: boolean) {
  const name = fn.name ?? "<anon>";
  const exp = exported ? "export " : "";
  const params = fn.params.map((p) => p.name).join(", ");

  // Represent as function declaration when named, otherwise const
  if (fn.name) {
    w.line(`${exp}function ${name}(${params}) {`);
  } else {
    w.line(`${exp}const ${name} = (${params}) => {`);
  }
  w.indent();
  emitBlockAsStatements(fn.body, w, { isFnBody: true, isClass: fn.isClass });
  if (fn.isClass) {
    // implicit yield this;
    w.line(`return ${emitThisCaptureForClassFn(fn)};`);
  } else if (fn.body.tail) {
    w.line(`return ${emitExpr(fn.body.tail, w)};`);
  } else {
    w.line(`return;`);
  }
  w.dedent();
  w.line(`}`);
}

function emitThisCaptureForClassFn(fn: FnDecl): string {
  // Prefer an explicit `this` capture if present (analyzer will fill captureNames).
  const te = findThisExpr(fn.body);
  if (te?.captureNames && te.captureNames.length) {
    return `{ ${te.captureNames.map((n) => `${n}: ${n}`).join(", ")} }`;
  }

  // Otherwise, `class fn` implies an implicit `yield this;` at the end.
  // Capture the class scope: params + top-level lets + top-level inner fn decls.
  const names = collectClassScopeNames(fn);
  return `{ ${names.map((n) => `${n}: ${n}`).join(", ")} }`;
}

function collectClassScopeNames(fn: FnDecl): string[] {
  const set = new Set<string>();
  for (const p of fn.params) set.add(p.name);
  for (const s of fn.body.stmts) {
    if (s.kind === "LetDecl") set.add(s.name);
    if (s.kind === "FnDecl" && s.name) set.add(s.name);
  }
  return [...set].sort();
}

function findThisExpr(node: any): ThisExpr | undefined {
  if (!node) return undefined;
  if (node.kind === "ThisExpr") return node;
  if (node.kind === "BlockExpr") {
    for (const s of node.stmts) {
      const r = findThisExpr(s);
      if (r) return r;
    }
    if (node.tail) return findThisExpr(node.tail);
  }
  if (node.kind === "ExprStmt") return findThisExpr(node.expr);
  if (node.kind === "LetDecl") return findThisExpr(node.init);
  if (node.kind === "AssignStmt") return findThisExpr(node.expr);
  if (node.kind === "IfStmt")
    return findThisExpr(node.thenBranch) ?? findThisExpr(node.elseBranch);
  if (node.kind === "IfExpr")
    return findThisExpr(node.thenExpr) ?? findThisExpr(node.elseExpr);
  if (node.kind === "LoopExpr") return findThisExpr(node.body);
  if (node.kind === "MatchExpr") {
    for (const a of node.arms) {
      const r = findThisExpr(a.expr);
      if (r) return r;
    }
  }
  if (node.kind === "CallExpr") {
    return (
      findThisExpr(node.callee) ?? node.args.map(findThisExpr).find(Boolean)
    );
  }
  return undefined;
}

function emitBlockAsStatements(
  block: BlockExpr,
  w: Writer,
  opts: { isFnBody: boolean; isClass: boolean }
) {
  for (const stmt of block.stmts) emitStmt(stmt, w, opts);
  // tail is handled by caller (return)
}

function emitStmt(
  stmt: Stmt,
  w: Writer,
  opts: { isFnBody: boolean; isClass: boolean }
) {
  switch (stmt.kind) {
    case "LetDecl":
      emitLet(stmt, w, false);
      return;
    case "AssignStmt": {
      w.line(
        `${emitExpr(stmt.target, w)} ${stmt.op} ${emitExpr(stmt.expr, w)};`
      );
      return;
    }
    case "ExprStmt": {
      w.line(`${emitExpr(stmt.expr, w)};`);
      return;
    }
    case "IfStmt": {
      w.line(`if (${emitExpr(stmt.cond, w)}) {`);
      w.indent();
      emitBranch(stmt.thenBranch, w, opts);
      w.dedent();
      w.line(`}`);
      if (stmt.elseBranch) {
        w.line(`else {`);
        w.indent();
        emitBranch(stmt.elseBranch as any, w, opts);
        w.dedent();
        w.line(`}`);
      }
      return;
    }
    case "WhileStmt": {
      w.line(`while (${emitExpr(stmt.cond, w)}) {`);
      w.indent();
      emitBranch(stmt.body, w, opts);
      w.dedent();
      w.line(`}`);
      return;
    }
    case "LoopStmt": {
      w.line(`for (;;) {`);
      w.indent();
      emitBranch(stmt.body, w, opts);
      w.dedent();
      w.line(`}`);
      return;
    }
    case "BreakStmt": {
      const bs = stmt as BreakStmt;
      if (bs.value) {
        // in statement loops we ignore value
        w.line(`break; // value ignored in statement loop`);
      } else {
        w.line(`break;`);
      }
      return;
    }
    case "ContinueStmt":
      w.line(`continue;`);
      return;
    case "YieldStmt": {
      if (stmt.value) w.line(`return ${emitExpr(stmt.value, w)};`);
      else w.line(`return;`);
      return;
    }
    case "FnDecl": {
      emitFnDecl(stmt, w, false);
      return;
    }
  }
}

function emitBranch(
  node: any,
  w: Writer,
  opts: { isFnBody: boolean; isClass: boolean }
) {
  if (!node) return;
  if (node.kind === "BlockExpr") {
    emitBlockAsStatements(node, w, opts);
    if (node.tail) {
      w.line(`${emitExpr(node.tail, w)};`);
    }
  } else {
    emitStmt(node, w, opts);
  }
}

function emitExpr(expr: Expr, w: Writer): string {
  switch (expr.kind) {
    case "LiteralExpr": {
      if (expr.literalKind === "string") return JSON.stringify(expr.value);
      if (expr.literalKind === "none") return "null";
      return String(expr.value);
    }
    case "IdentExpr":
      return expr.name;
    case "PathExpr": {
      // a::b::c -> a.b.c
      return expr.parts.join(".");
    }
    case "UnaryExpr":
      return `(${expr.op}${emitExpr(expr.expr, w)})`;
    case "BinaryExpr": {
      if (expr.op === "is") {
        // left is Variant => left.tag === "Variant" (best effort)
        if (expr.right.kind === "IdentExpr") {
          return `(${emitExpr(expr.left, w)}.tag === ${JSON.stringify(
            expr.right.name
          )})`;
        }
        return `(${emitExpr(expr.left, w)}.tag === ${emitExpr(expr.right, w)})`;
      }
      if (expr.op === "::") {
        // should not reach here; parser turns into PathExpr
        return `${emitExpr(expr.left, w)}.${emitExpr(expr.right, w)}`;
      }
      return `(${emitExpr(expr.left, w)} ${expr.op} ${emitExpr(
        expr.right,
        w
      )})`;
    }
    case "CallExpr":
      return `${emitExpr(expr.callee, w)}(${expr.args
        .map((a) => emitExpr(a, w))
        .join(", ")})`;
    case "MemberExpr":
      return `${emitExpr(expr.object, w)}.${expr.member}`;
    case "IndexExpr":
      return `${emitExpr(expr.object, w)}[${emitExpr(expr.index, w)}]`;
    case "ParenExpr":
      return `(${emitExpr(expr.expr, w)})`;
    case "TupleLiteralExpr":
      return `[${expr.items.map((it) => emitExpr(it, w)).join(", ")}]`;
    case "ObjectLiteralExpr":
      return `{ ${expr.fields
        .map((f) => `${f.name}: ${emitExpr(f.value, w)}`)
        .join(", ")} }`;
    case "BlockExpr": {
      // IIFE to preserve expression semantics
      w = w; // satisfy lint
      const inner = new Writer();
      inner.line(`(() => {`);
      inner.indent();
      for (const stmt of expr.stmts) {
        const line = emitStmtToString(stmt);
        inner.line(line);
      }
      if (expr.tail) {
        inner.line(`return ${emitExpr(expr.tail, w)};`);
      } else {
        inner.line(`return undefined;`);
      }
      inner.dedent();
      inner.line(`})()`);
      return inner.toString().trim();
    }
    case "IfExpr": {
      const ie = expr as IfExpr;
      return `(${emitExpr(ie.cond, w)} ? ${emitExpr(
        ie.thenExpr,
        w
      )} : ${emitExpr(ie.elseExpr, w)})`;
    }
    case "LoopExpr": {
      const le = expr as LoopExpr;
      // Emit as IIFE with labeled break value
      const inner = new Writer();
      inner.line(`(() => {`);
      inner.indent();
      inner.line(`let __tuff_loop_value;`);
      inner.line(`for (;;) {`);
      inner.indent();
      emitLoopBody(le.body, inner);
      inner.dedent();
      inner.line(`}`);
      inner.line(`return __tuff_loop_value;`);
      inner.dedent();
      inner.line(`})()`);
      return inner.toString().trim();
    }
    case "MatchExpr": {
      const me = expr as MatchExpr;
      const inner = new Writer();
      inner.line(`(() => {`);
      inner.indent();
      inner.line(`const __v = ${emitExpr(me.value, w)};`);
      inner.line(`switch (__v.tag ?? __v) {`);
      inner.indent();
      let hasDefault = false;
      for (const arm of me.arms) {
        if (arm.pattern.kind === "Wildcard") {
          hasDefault = true;
          inner.line(`default: return ${emitExpr(arm.expr, w)};`);
        } else if (arm.pattern.kind === "Variant") {
          inner.line(
            `case ${JSON.stringify(arm.pattern.name)}: return ${emitExpr(
              arm.expr,
              w
            )};`
          );
        } else if (arm.pattern.kind === "String") {
          inner.line(
            `case ${JSON.stringify(arm.pattern.value)}: return ${emitExpr(
              arm.expr,
              w
            )};`
          );
        }
      }
      if (!hasDefault) inner.line(`default: return undefined;`);
      inner.dedent();
      inner.line(`}`);
      inner.dedent();
      inner.line(`})()`);
      return inner.toString().trim();
    }
    case "ThisExpr": {
      const te = expr as ThisExpr;
      const names = te.captureNames ?? [];
      return `{ ${names.map((n) => `${n}: ${n}`).join(", ")} }`;
    }
    case "LambdaExpr": {
      const params = expr.params.map((p) => p.name).join(", ");
      const inner = new Writer();
      inner.line(`(${params}) => {`);
      inner.indent();
      // statements
      for (const s of expr.body.stmts) inner.line(emitStmtToString(s));
      if (expr.body.tail) inner.line(`return ${emitExpr(expr.body.tail, w)};`);
      else inner.line(`return;`);
      inner.dedent();
      inner.line(`}`);
      return inner.toString().trim();
    }
  }
}

function emitLoopBody(body: BlockExpr, w: Writer) {
  for (const stmt of body.stmts) {
    if (stmt.kind === "BreakStmt" && stmt.value) {
      w.line(`__tuff_loop_value = ${emitExpr(stmt.value as any, w)};`);
      w.line(`break;`);
      continue;
    }
    w.line(emitStmtToString(stmt));
  }
  if (body.tail) {
    // tail expression in a loop body is just evaluated
    w.line(`${emitExpr(body.tail, w)};`);
  }
}

function emitStmtToString(stmt: Stmt): string {
  const tmp = new Writer();
  // use existing emitter logic in minimal form
  // (we only need this inside expression IIFEs, so keep it conservative)
  switch (stmt.kind) {
    case "LetDecl": {
      const kw = stmt.mutable ? "let" : "const";
      if (stmt.init)
        return `${kw} ${stmt.name} = ${emitExpr(stmt.init as any, tmp)};`;
      return `${kw} ${stmt.name} = undefined;`;
    }
    case "AssignStmt":
      return `${emitExpr(stmt.target as any, tmp)} ${stmt.op} ${emitExpr(
        stmt.expr as any,
        tmp
      )};`;
    case "ExprStmt":
      return `${emitExpr(stmt.expr as any, tmp)};`;
    case "YieldStmt":
      return stmt.value
        ? `return ${emitExpr(stmt.value as any, tmp)};`
        : `return;`;
    case "BreakStmt": {
      const b = stmt as BreakStmt;
      if (b.value) return `break; // value handled by loop expr lowering`;
      return `break;`;
    }
    case "ContinueStmt":
      return `continue;`;
    case "IfStmt": {
      // minimal: wrap branches in blocks
      const cond = emitExpr((stmt as any).cond, tmp);
      const inner = new Writer();
      inner.line(`if (${cond}) {`);
      inner.indent();
      // then
      if ((stmt as any).thenBranch.kind === "BlockExpr") {
        for (const s of (stmt as any).thenBranch.stmts)
          inner.line(emitStmtToString(s));
        if ((stmt as any).thenBranch.tail)
          inner.line(`${emitExpr((stmt as any).thenBranch.tail, tmp)};`);
      } else {
        inner.line(emitStmtToString((stmt as any).thenBranch));
      }
      inner.dedent();
      inner.line(`}`);
      if ((stmt as any).elseBranch) {
        inner.line(`else {`);
        inner.indent();
        const eb = (stmt as any).elseBranch;
        if (eb.kind === "BlockExpr") {
          for (const s of eb.stmts) inner.line(emitStmtToString(s));
          if (eb.tail) inner.line(`${emitExpr(eb.tail, tmp)};`);
        } else {
          inner.line(emitStmtToString(eb));
        }
        inner.dedent();
        inner.line(`}`);
      }
      return inner.toString().trim();
    }
    case "WhileStmt": {
      const inner = new Writer();
      inner.line(`while (${emitExpr((stmt as any).cond, tmp)}) {`);
      inner.indent();
      const b = (stmt as any).body;
      if (b.kind === "BlockExpr") {
        for (const s of b.stmts) inner.line(emitStmtToString(s));
        if (b.tail) inner.line(`${emitExpr(b.tail, tmp)};`);
      } else {
        inner.line(emitStmtToString(b));
      }
      inner.dedent();
      inner.line(`}`);
      return inner.toString().trim();
    }
    case "LoopStmt": {
      const inner = new Writer();
      inner.line(`for (;;) {`);
      inner.indent();
      const b = (stmt as any).body;
      if (b.kind === "BlockExpr") {
        for (const s of b.stmts) inner.line(emitStmtToString(s));
        if (b.tail) inner.line(`${emitExpr(b.tail, tmp)};`);
      } else {
        inner.line(emitStmtToString(b));
      }
      inner.dedent();
      inner.line(`}`);
      return inner.toString().trim();
    }
    case "FnDecl": {
      // avoid nested function declarations in expression contexts for now
      return `// nested fn omitted in expr context`;
    }
  }
}

function mapExternModule(parts: string[]): string {
  if (parts.length >= 2 && parts[0] === "node") {
    return `node:${parts.slice(1).join("/")}`;
  }
  return parts.join("/");
}

class Writer {
  private out: string[] = [];
  private level = 0;

  indent() {
    this.level++;
  }

  dedent() {
    this.level = Math.max(0, this.level - 1);
  }

  line(s = "") {
    if (s.length === 0) {
      this.out.push("");
      return;
    }
    this.out.push(`${"  ".repeat(this.level)}${s}`);
  }

  toString(): string {
    return this.out.join("\n");
  }
}
