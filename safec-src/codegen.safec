// SafeC Code Generator - Self-hosting version
// Generates C code from AST with monomorphization

#include <stdio.h>
#include "ast"
#include "lexer"
#include <stdlib.h>
#include <string.h>

struct Instantiation {
	char *generic_name;
	struct TypeRef *type_args;
	char *mangled_name;
	struct Instantiation *next;
};

struct CodeGen {
	FILE *output;
	struct Instantiation *struct_instantiations;
	struct Instantiation *func_instantiations;
	struct ASTNode *program;
	int indent;
};

void codegen_init(struct CodeGen *gen, FILE *output, struct ASTNode *program)
{
	gen->output = output;
	gen->struct_instantiations = (struct Instantiation *)0;
	gen->func_instantiations = (struct Instantiation *)0;
	gen->program = program;
	gen->indent = 0;
}

static void free_instantiations(struct Instantiation *inst)
{
	while (inst)
	{
		struct Instantiation *next = inst->next;
		free(inst->generic_name);
		ast_free_type_ref(inst->type_args);
		free(inst->mangled_name);
		free(inst);
		inst = next;
	}
}

void codegen_free(struct CodeGen *gen)
{
	free_instantiations(gen->struct_instantiations);
	free_instantiations(gen->func_instantiations);
}

static void emit(struct CodeGen *gen, const char *str)
{
	fprintf(gen->output, "%s", str);
}

static void emit_indent(struct CodeGen *gen)
{
	int i = 0;
	for (i = 0; i < gen->indent; i++)
	{
		fprintf(gen->output, "    ");
	}
}

static void emit_newline(struct CodeGen *gen)
{
	fprintf(gen->output, "\n");
}

char *mangle_name(const char *base, struct TypeRef *type_args)
{
	if (!type_args)
	{
		return strdup(base);
	}

	size_t len = strlen(base);
	struct TypeRef *arg = type_args;
	while (arg)
	{
		len = len + 1 + strlen(arg->name);
		int i = 0;
		for (i = 0; i < arg->pointer_level; i++)
		{
			len = len + 3;
		}
		arg = arg->next;
	}

	char *result = (char *)malloc(len + 1);
	strcpy(result, base);

	arg = type_args;
	while (arg)
	{
		strcat(result, "_");
		strcat(result, arg->name);
		int i = 0;
		for (i = 0; i < arg->pointer_level; i++)
		{
			strcat(result, "_ptr");
		}
		arg = arg->next;
	}

	return result;
}

static struct Instantiation *find_instantiation(struct Instantiation *list, const char *name, struct TypeRef *args)
{
	while (list)
	{
		if (strcmp(list->generic_name, name) == 0)
		{
			struct TypeRef *a1 = list->type_args;
			struct TypeRef *a2 = args;
			int match = 1;

			while (a1 && a2)
			{
				if (strcmp(a1->name, a2->name) != 0 || a1->pointer_level != a2->pointer_level)
				{
					match = 0;
					break;
				}
				a1 = a1->next;
				a2 = a2->next;
			}

			if (match && !a1 && !a2)
			{
				return list;
			}
		}
		list = list->next;
	}
	return (struct Instantiation *)0;
}

static struct Instantiation *add_instantiation(struct Instantiation **list, const char *name, struct TypeRef *args)
{
	struct Instantiation *existing = find_instantiation(*list, name, args);
	if (existing)
		return existing;

	struct Instantiation *inst = (struct Instantiation *)malloc(sizeof(struct Instantiation));
	inst->generic_name = strdup(name);
	inst->type_args = type_ref_clone(args);
	inst->mangled_name = mangle_name(name, args);
	inst->next = *list;
	*list = inst;
	return inst;
}

// Forward declarations
static void emit_type(struct CodeGen *gen, struct TypeRef *type, struct TypeRef *substitutions);
static void emit_expression(struct CodeGen *gen, struct ASTNode *node, struct TypeRef *substitutions);
static void emit_statement(struct CodeGen *gen, struct ASTNode *node, struct TypeRef *substitutions);
static void emit_declaration(struct CodeGen *gen, struct ASTNode *node, struct TypeRef *substitutions);

void codegen_generate(struct CodeGen *gen)
{
	emit(gen, "/* Generated by SafeC compiler */\n\n");

	struct ASTNode *decl = gen->program;
	while (decl)
	{
		emit_declaration(gen, decl, (struct TypeRef *)0);
		decl = decl->next;
	}
}

void codegen_generate_header(struct CodeGen *gen, const char *guard_name)
{
	emit(gen, "#ifndef ");
	emit(gen, guard_name);
	emit(gen, "\n#define ");
	emit(gen, guard_name);
	emit(gen, "\n\n#include <stddef.h>\n\n");

	struct ASTNode *decl = gen->program;
	while (decl)
	{
		switch (decl->type)
		{
		case AST_STRUCT_DEF:
			if (!decl->data.struct_def.type_params)
			{
				emit(gen, "struct ");
				emit(gen, decl->data.struct_def.name);
				emit(gen, " {\n");
				struct ASTNode *member = decl->data.struct_def.members;
				while (member)
				{
					emit(gen, "    ");
					emit_type(gen, member->data.var_decl.type, (struct TypeRef *)0);
					emit(gen, " ");
					emit(gen, member->data.var_decl.name);
					emit(gen, ";\n");
					member = member->next;
				}
				emit(gen, "};\n\n");
			}
			break;
		case AST_FUNC_DEF:
		case AST_FUNC_DECL:
			if (!decl->data.func_def.type_params)
			{
				emit_type(gen, decl->data.func_def.return_type, (struct TypeRef *)0);
				emit(gen, " ");
				emit(gen, decl->data.func_def.name);
				emit(gen, "(");
				struct ASTNode *param = decl->data.func_def.params;
				while (param)
				{
					emit_type(gen, param->data.param.type, (struct TypeRef *)0);
					if (param->data.param.name && strlen(param->data.param.name) > 0)
					{
						emit(gen, " ");
						emit(gen, param->data.param.name);
					}
					if (param->next)
						emit(gen, ", ");
					param = param->next;
				}
				emit(gen, ");\n");
			}
			break;
		case AST_TYPEDEF:
			emit(gen, "typedef ");
			emit_type(gen, decl->data.typedef_stmt.type, (struct TypeRef *)0);
			emit(gen, " ");
			emit(gen, decl->data.typedef_stmt.name);
			emit(gen, ";\n");
			break;
		default:
			break;
		}
		decl = decl->next;
	}

	emit(gen, "\n#endif /* ");
	emit(gen, guard_name);
	emit(gen, " */\n");
}

static void emit_type(struct CodeGen *gen, struct TypeRef *type, struct TypeRef *substitutions)
{
	if (!type)
		return;

	emit(gen, type->name);
	int i = 0;
	for (i = 0; i < type->pointer_level; i++)
	{
		emit(gen, "*");
	}
}

static void emit_expression(struct CodeGen *gen, struct ASTNode *node, struct TypeRef *substitutions)
{
	if (!node)
		return;

	switch (node->type)
	{
	case AST_IDENTIFIER:
		emit(gen, node->data.ident.name);
		break;
	case AST_NUMBER:
		emit(gen, node->data.number.value);
		break;
	case AST_STRING:
		emit(gen, node->data.string.value);
		break;
	default:
		break;
	}
}

static void emit_statement(struct CodeGen *gen, struct ASTNode *node, struct TypeRef *substitutions)
{
	if (!node)
		return;
	// Minimal implementation
}

static void emit_declaration(struct CodeGen *gen, struct ASTNode *node, struct TypeRef *substitutions)
{
	if (!node)
		return;
	// Minimal implementation
}

// Note: Full codegen implementation continues in separate functions
// This is a minimal version for self-hosting bootstrap
