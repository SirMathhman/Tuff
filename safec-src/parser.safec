// SafeC Parser - Self-hosting version
// Recursive descent parser for SafeC

#include "lexer"
#include "ast"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Parser {
	struct Lexer lexer;
	struct Token current;
	struct Token previous;
	int had_error;
	int panic_mode;
	char *error_message;
};

// Forward declarations
static struct ASTNode *parse_declaration(struct Parser *parser);
static struct ASTNode *parse_statement(struct Parser *parser);
static struct ASTNode *parse_expression(struct Parser *parser);
static struct ASTNode *parse_assignment(struct Parser *parser);
static struct TypeRef *parse_type(struct Parser *parser);

void parser_init(struct Parser *parser, const char *source)
{
	lexer_init(&parser->lexer, source);
	parser->had_error = 0;
	parser->panic_mode = 0;
	parser->error_message = (char *)malloc(256);
	parser->error_message[0] = '\0';
	parser->current = lexer_next_token(&parser->lexer);
}

static void error(struct Parser *parser, const char *message)
{
	if (parser->panic_mode)
		return;
	parser->panic_mode = 1;
	parser->had_error = 1;
	snprintf(parser->error_message, 256,
					 "Error at line %d: %s", parser->current.line, message);
}

static void advance(struct Parser *parser)
{
	parser->previous = parser->current;
	parser->current = lexer_next_token(&parser->lexer);

	if (parser->current.type == TOK_ERROR)
	{
		error(parser, parser->current.start);
	}
}

static int check(struct Parser *parser, TokenType type)
{
	return parser->current.type == type;
}

static int match(struct Parser *parser, TokenType type)
{
	if (!check(parser, type))
		return 0;
	advance(parser);
	return 1;
}

static void consume(struct Parser *parser, TokenType type, const char *message)
{
	if (parser->current.type == type)
	{
		advance(parser);
		return;
	}
	error(parser, message);
}

static char *token_to_string(struct Token *token)
{
	char *str = (char *)malloc(token->length + 1);
	memcpy(str, token->start, token->length);
	str[token->length] = '\0';
	return str;
}

static int is_type_start(struct Parser *parser)
{
	switch (parser->current.type)
	{
	case TOK_VOID:
	case TOK_INT:
	case TOK_CHAR:
	case TOK_FLOAT:
	case TOK_DOUBLE:
	case TOK_LONG:
	case TOK_SHORT:
	case TOK_UNSIGNED:
	case TOK_SIGNED:
	case TOK_CONST:
	case TOK_STRUCT:
	case TOK_ENUM:
	case TOK_UNION:
		return 1;
	case TOK_IDENTIFIER:
		return 1;
	default:
		return 0;
	}
}

static struct TypeParam *parse_type_params(struct Parser *parser)
{
	if (!match(parser, TOK_LT))
		return (struct TypeParam *)0;

	struct TypeParam *head = (struct TypeParam *)0;
	struct TypeParam *tail = (struct TypeParam *)0;

	// Parse first type parameter
	if (parser->current.type != TOK_IDENTIFIER)
	{
		error(parser, "Expected type parameter name");
		return head;
	}

	struct TypeParam *param = type_param_new(token_to_string(&parser->current));
	advance(parser);
	head = param;
	tail = param;

	// Parse remaining type parameters
	while (match(parser, TOK_COMMA))
	{
		if (parser->current.type != TOK_IDENTIFIER)
		{
			error(parser, "Expected type parameter name");
			return head;
		}

		param = type_param_new(token_to_string(&parser->current));
		advance(parser);
		tail->next = param;
		tail = param;
	}

	consume(parser, TOK_GT, "Expected '>' after type parameters");
	return head;
}

static struct TypeRef *parse_type_args(struct Parser *parser)
{
	if (!match(parser, TOK_LT))
		return (struct TypeRef *)0;

	struct TypeRef *head = (struct TypeRef *)0;
	struct TypeRef *tail = (struct TypeRef *)0;

	// Parse first type argument
	struct TypeRef *arg = parse_type(parser);
	if (!arg)
	{
		error(parser, "Expected type argument");
		return head;
	}
	head = arg;
	tail = arg;

	// Parse remaining type arguments
	while (match(parser, TOK_COMMA))
	{
		arg = parse_type(parser);
		if (!arg)
		{
			error(parser, "Expected type argument");
			return head;
		}
		tail->next = arg;
		tail = arg;
	}

	consume(parser, TOK_GT, "Expected '>' after type arguments");
	return head;
}

static struct TypeRef *parse_type(struct Parser *parser)
{
	struct TypeRef *ref = (struct TypeRef *)0;

	int is_const = match(parser, TOK_CONST);
	int is_unsigned = match(parser, TOK_UNSIGNED);
	int is_signed = match(parser, TOK_SIGNED);
	(void)is_const;
	(void)is_unsigned;
	(void)is_signed;

	if (match(parser, TOK_STRUCT) || match(parser, TOK_ENUM) || match(parser, TOK_UNION))
	{
		TokenType kind = parser->previous.type;

		if (check(parser, TOK_LBRACE))
		{
			const char *prefix = kind == TOK_STRUCT ? "struct " : (kind == TOK_ENUM ? "enum " : "union ");
			size_t cap = 256;
			size_t len = strlen(prefix);
			char *body = (char *)malloc(cap);
			strcpy(body, prefix);

			consume(parser, TOK_LBRACE, "Expected '{'");
			strcat(body, "{ ");
			len = len + 2;
			int brace_depth = 1;

			while (brace_depth > 0 && !check(parser, TOK_EOF))
			{
				char *part = token_to_string(&parser->current);
				size_t plen = strlen(part);
				if (len + plen + 2 >= cap)
				{
					cap = cap * 2;
					body = (char *)realloc(body, cap);
				}
				strcat(body, part);
				strcat(body, " ");
				len = len + plen + 1;
				free(part);

				if (parser->current.type == TOK_LBRACE)
					brace_depth++;
				else if (parser->current.type == TOK_RBRACE)
					brace_depth--;

				advance(parser);
			}

			ref = type_ref_new(body);
			free(body);
		}
		else if (parser->current.type != TOK_IDENTIFIER)
		{
			error(parser, "Expected name after struct/enum/union");
			return (struct TypeRef *)0;
		}
		else
		{
			char *name = token_to_string(&parser->current);
			advance(parser);

			const char *prefix = kind == TOK_STRUCT ? "struct " : (kind == TOK_ENUM ? "enum " : "union ");
			char *full_name = (char *)malloc(strlen(prefix) + strlen(name) + 1);
			strcpy(full_name, prefix);
			strcat(full_name, name);
			free(name);

			ref = type_ref_new(full_name);
			free(full_name);
		}
	}
	else if (parser->current.type == TOK_VOID ||
					 parser->current.type == TOK_INT ||
					 parser->current.type == TOK_CHAR ||
					 parser->current.type == TOK_FLOAT ||
					 parser->current.type == TOK_DOUBLE ||
					 parser->current.type == TOK_LONG ||
					 parser->current.type == TOK_SHORT)
	{
		ref = type_ref_new(token_to_string(&parser->current));
		advance(parser);

		while (parser->current.type == TOK_LONG ||
					 parser->current.type == TOK_INT ||
					 parser->current.type == TOK_DOUBLE)
		{
			char *old_name = ref->name;
			char *extra = token_to_string(&parser->current);
			ref->name = (char *)malloc(strlen(old_name) + strlen(extra) + 2);
			sprintf(ref->name, "%s %s", old_name, extra);
			free(old_name);
			free(extra);
			advance(parser);
		}
	}
	else if (parser->current.type == TOK_IDENTIFIER)
	{
		ref = type_ref_new(token_to_string(&parser->current));
		advance(parser);
		ref->type_args = parse_type_args(parser);
	}
	else
	{
		return (struct TypeRef *)0;
	}

	while (match(parser, TOK_STAR))
	{
		ref->pointer_level++;
	}

	return ref;
}

const char *parser_get_error(struct Parser *parser)
{
	return parser->error_message;
}

// Note: Full parser implementation continues in separate functions
// This is a minimal version for self-hosting bootstrap
