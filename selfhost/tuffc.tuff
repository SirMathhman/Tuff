// Self-hosted compiler (first whack)
//
// This is a *very* small compiler written in Tuff, intended to prove the loop:
//   bootstrap TS compiler -> emits JS -> JS runs and can compile a tiny subset.
//
// For now, it compiles only a restricted input shape:
//   fn main() => <number>
//   fn main() => { <number> }
//
// Output is ESM that exports `main`.

extern from rt::stdlib use { println, panic, readTextFile, writeTextFile, stringLen, stringSlice, stringCharCodeAt, stringFromCharCode };

extern from rt::vec use { vec_len, vec_get };

// Tiny record type used to return two values from parsing helpers.
class fn ParsedNumber(v0, v1) => {}
class fn ParsedIdent(v0, v1) => {}
class fn ParsedExpr(v0, v1) => {}
class fn ParsedMain(body, expr, v1) => {}
class fn ParsedBool(v0, v1) => {}

// Utility: ASCII checks
fn is_digit(code) => { code >= 48 && code <= 57 }
fn is_space(code) => { code == 32 || code == 10 || code == 9 || code == 13 }
fn is_alpha(code) => { (code >= 65 && code <= 90) || (code >= 97 && code <= 122) }
fn is_ident_start(code) => { is_alpha(code) || code == 95 }
fn is_ident_part(code) => { is_ident_start(code) || is_digit(code) }

fn skip_ws(src, i) => {
  let mut j = i;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (!is_space(c)) { break; }
    j = j + 1;
  }
  j
}

fn starts_with_at(src, i, lit) => {
  // compare bytewise
  let mut j = 0;
  while (j < stringLen(lit)) {
    if (i + j >= stringLen(src)) { yield false; }
    if (stringCharCodeAt(src, i + j) != stringCharCodeAt(lit, j)) { yield false; }
    j = j + 1;
  }
  true
}

fn parse_keyword(src, i, lit) => {
  let j = skip_ws(src, i);
  if (!starts_with_at(src, j, lit)) {
    let mut end = j + 16;
    if (end > stringLen(src)) { end = stringLen(src); }
    panic("expected keyword: " + lit + " but got '" + stringSlice(src, j, end) + "'");
  }
  j + stringLen(lit)
}

fn parse_number(src, i) => {
  let mut j = skip_ws(src, i);
  let mut acc = 0;
  let mut saw = false;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (!is_digit(c)) { break; }
    saw = true;
    acc = acc * 10 + (c - 48);
    j = j + 1;
  }
  if (!saw) {
    panic("expected number");
  }
  ParsedNumber(acc, j)
}

fn parse_ident(src, i) => {
  let mut j = skip_ws(src, i);
  if (!(j < stringLen(src))) { panic("expected identifier"); }
  let c0 = stringCharCodeAt(src, j);
  if (!is_ident_start(c0)) { panic("expected identifier"); }
  let start = j;
  j = j + 1;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (!is_ident_part(c)) { break; }
    j = j + 1;
  }
  ParsedIdent(stringSlice(src, start, j), j)
}

fn parse_expr(src, i) => parse_add(src, i)

fn parse_add(src, i) => {
  let mut left = parse_mul(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }
    let op = stringCharCodeAt(src, j);
    if (!(op == 43 || op == 45)) { break; } // '+' or '-'
    let rhs = parse_mul(src, j + 1);
    let opStr = if (op == 43) "+" else "-";
    left = ParsedExpr("(" + left.v0 + " " + opStr + " " + rhs.v0 + ")", rhs.v1);
    j = left.v1;
  }
  left
}

fn parse_mul(src, i) => {
  let mut left = parse_primary(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }
    let op = stringCharCodeAt(src, j);
    if (!(op == 42 || op == 47)) { break; } // '*' or '/'
    let rhs = parse_primary(src, j + 1);
    let opStr = if (op == 42) "*" else "/";
    left = ParsedExpr("(" + left.v0 + " " + opStr + " " + rhs.v0 + ")", rhs.v1);
    j = left.v1;
  }
  left
}

fn parse_primary(src, i) => {
  let j = skip_ws(src, i);
  if (!(j < stringLen(src))) { panic("expected expression"); }
  let c = stringCharCodeAt(src, j);
  if (c == 40) { // '('
    let inner = parse_expr(src, j + 1);
    let k = skip_ws(src, inner.v1);
    if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 41)) { // ')'
      panic("expected ')'");
    }
    yield ParsedExpr("(" + inner.v0 + ")", k + 1);
  }
  if (is_digit(c)) {
    let n = parse_number(src, j);
    yield ParsedExpr("" + n.v0, n.v1);
  }
  if (is_ident_start(c)) {
    let id = parse_ident(src, j);
    yield ParsedExpr(id.v0, id.v1);
  }
  panic("expected expression")
}

fn parse_optional_semicolon(src, i) => {
  let j = skip_ws(src, i);
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 59) { yield j + 1; }
  i
}

fn parse_required_semicolon(src, i) => {
  let j = skip_ws(src, i);
  if (!(j < stringLen(src) && stringCharCodeAt(src, j) == 59)) { panic("expected ';'"); }
  j + 1
}

fn parse_mut_opt(src, i) => {
  let j = skip_ws(src, i);
  if (starts_with_at(src, j, "mut")) { yield ParsedBool(true, j + 3); }
  ParsedBool(false, i)
}

fn is_assign_stmt_start(src, i) => {
  let mut j = skip_ws(src, i);
  if (!(j < stringLen(src))) { yield false; }
  let c0 = stringCharCodeAt(src, j);
  if (!is_ident_start(c0)) { yield false; }
  j = j + 1;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (!is_ident_part(c)) { break; }
    j = j + 1;
  }
  j = skip_ws(src, j);
  j < stringLen(src) && stringCharCodeAt(src, j) == 61 // '='
}

fn parse_main_body(src, i) => {
  let j = skip_ws(src, i);
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 123) { // '{'
    // block main body
    let mut k = j + 1;
    let mut body = "";

    // statements inside block (semicolon required)
    while (true) {
      let t = skip_ws(src, k);

      // let / let mut
      if (starts_with_at(src, t, "let")) {
        k = parse_keyword(src, k, "let");
        let mutOpt = parse_mut_opt(src, k);
        k = mutOpt.v1;
        let name = parse_ident(src, k);
        k = name.v1;
        k = parse_keyword(src, k, "=");
        let expr = parse_expr(src, k);
        k = expr.v1;
        k = parse_required_semicolon(src, k);
        let declKw = if (mutOpt.v0) "let" else "const";
        body = body + (declKw + " " + name.v0 + " = " + expr.v0 + ";\n");
        continue;
      }

      // assignment: <ident> = <expr>;
      if (is_assign_stmt_start(src, t)) {
        let name = parse_ident(src, k);
        k = name.v1;
        k = parse_keyword(src, k, "=");
        let expr = parse_expr(src, k);
        k = expr.v1;
        k = parse_required_semicolon(src, k);
        body = body + (name.v0 + " = " + expr.v0 + ";\n");
        continue;
      }

      break;
    }

    // tail expression
    let tail = parse_expr(src, k);
    k = skip_ws(src, tail.v1);
    if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 125)) { // '}'
      panic("expected '}'");
    }
    yield ParsedMain(body, tail.v0, k + 1);
  }

  // expression main body
  let e = parse_expr(src, i);
  ParsedMain("", e.v0, e.v1)
}

fn compile_tiny(src) => {
  // Parse:
  //   (let <ident> = <expr>;)*
  //   fn main() => <expr>
  let mut i = 0;

  let mut out = "// compiled by selfhost tuffc\n";

  // zero or more let statements
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "let")) {
      i = parse_keyword(src, i, "let");
      let name = parse_ident(src, i);
      i = name.v1;
      i = parse_keyword(src, i, "=");
      let expr = parse_expr(src, i);
      i = expr.v1;
      i = parse_optional_semicolon(src, i);
      out = out + ("const " + name.v0 + " = " + expr.v0 + ";\n");
      continue;
    }
    break;
  }

  // main
  i = parse_keyword(src, i, "fn");
  i = parse_keyword(src, i, "main");
  i = parse_keyword(src, i, "(");
  i = parse_keyword(src, i, ")");
  i = parse_keyword(src, i, "=>");
  let mainBody = parse_main_body(src, i);

  out + ("export function main() {\n" + mainBody.body + "return " + mainBody.expr + ";\n}\n")
}

// When run as a program, compile stdin-like file input.
// We keep it simple: main(argv) where argv = [inPath, outPath]
fn main(argv) => {
  if (vec_len(argv) < 2) {
    println("usage: tuffc <in.tuff> <out.mjs>");
    yield 1;
  }
  let inPath = vec_get(argv, 0);
  let outPath = vec_get(argv, 1);

  let src = readTextFile(inPath);
  let js = compile_tiny(src);
  writeTextFile(outPath, js);
  0
}
