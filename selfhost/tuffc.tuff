// Self-hosted compiler (first whack)
//
// This is a *very* small compiler written in Tuff, intended to prove the loop:
//   bootstrap TS compiler -> emits JS -> JS runs and can compile a tiny subset.
//
// For now, it compiles only a restricted input shape:
//   fn main() => <number>
//   fn main() => { <number> }
//
// Output is ESM that exports `main`.

extern from rt::stdlib use { println, panic, readTextFile, writeTextFile, pathDirname, pathJoin, stringLen, stringSlice, stringCharCodeAt, stringFromCharCode };

extern from rt::vec use { vec_new, vec_len, vec_push, vec_get };

// Tiny record type used to return two values from parsing helpers.
class fn ParsedNumber(v0, v1) => {}
class fn ParsedIdent(v0, v1) => {}
class fn ParsedExpr(v0, v1) => {}
class fn ParsedMain(body, expr, v1) => {}
class fn ParsedBool(v0, v1) => {}
class fn ParsedStmt(v0, v1) => {}
class fn ParsedParams(v0, v1) => {}
class fn ParsedImports(v0, v1) => {}

// Utility: ASCII checks
fn is_digit(code) => { code >= 48 && code <= 57 }
fn is_space(code) => { code == 32 || code == 10 || code == 9 || code == 13 }
fn is_alpha(code) => { (code >= 65 && code <= 90) || (code >= 97 && code <= 122) }
fn is_ident_start(code) => { is_alpha(code) || code == 95 }
fn is_ident_part(code) => { is_ident_start(code) || is_digit(code) }

fn skip_ws(src, i) => {
  let mut j = i;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (!is_space(c)) { break; }
    j = j + 1;
  }
  j
}

fn starts_with_at(src, i, lit) => {
  // compare bytewise
  let mut j = 0;
  while (j < stringLen(lit)) {
    if (i + j >= stringLen(src)) { yield false; }
    if (stringCharCodeAt(src, i + j) != stringCharCodeAt(lit, j)) { yield false; }
    j = j + 1;
  }
  true
}

fn parse_keyword(src, i, lit) => {
  let j = skip_ws(src, i);
  if (!starts_with_at(src, j, lit)) {
    let mut end = j + 16;
    if (end > stringLen(src)) { end = stringLen(src); }
    panic("expected keyword: " + lit + " but got '" + stringSlice(src, j, end) + "'");
  }
  j + stringLen(lit)
}

fn parse_number(src, i) => {
  let mut j = skip_ws(src, i);
  let mut acc = 0;
  let mut saw = false;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (!is_digit(c)) { break; }
    saw = true;
    acc = acc * 10 + (c - 48);
    j = j + 1;
  }
  if (!saw) {
    panic("expected number");
  }
  ParsedNumber(acc, j)
}

fn parse_ident(src, i) => {
  let mut j = skip_ws(src, i);
  if (!(j < stringLen(src))) { panic("expected identifier"); }
  let c0 = stringCharCodeAt(src, j);
  if (!is_ident_start(c0)) { panic("expected identifier"); }
  let start = j;
  j = j + 1;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (!is_ident_part(c)) { break; }
    j = j + 1;
  }
  ParsedIdent(stringSlice(src, start, j), j)
}

fn parse_module_path(src, i) => {
  let mut j = skip_ws(src, i);
  let start = j;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (is_space(c) || c == 59) { break; }
    j = j + 1;
  }
  if (start == j) { panic("expected module path"); }
  ParsedIdent(stringSlice(src, start, j), j)
}

fn parse_expr(src, i) => parse_cmp(src, i)

fn parse_cmp(src, i) => {
  // comparisons: == != < <= > >=
  let mut left = parse_add(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }

    let c0 = stringCharCodeAt(src, j);
    let c1 = if (j + 1 < stringLen(src)) stringCharCodeAt(src, j + 1) else 0;

    let mut op = "";
    let mut adv = 0;

    // ==
    if (c0 == 61 && c1 == 61) { op = "=="; adv = 2; }
    // !=
    if (op == "" && c0 == 33 && c1 == 61) { op = "!="; adv = 2; }
    // <=
    if (op == "" && c0 == 60 && c1 == 61) { op = "<="; adv = 2; }
    // >=
    if (op == "" && c0 == 62 && c1 == 61) { op = ">="; adv = 2; }
    // <
    if (op == "" && c0 == 60) { op = "<"; adv = 1; }
    // >
    if (op == "" && c0 == 62) { op = ">"; adv = 1; }

    if (op == "") { break; }

    let rhs = parse_add(src, j + adv);
    left = ParsedExpr("(" + left.v0 + " " + op + " " + rhs.v0 + ")", rhs.v1);
    j = left.v1;
  }
  left
}

fn parse_add(src, i) => {
  let mut left = parse_mul(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }
    let op = stringCharCodeAt(src, j);
    if (!(op == 43 || op == 45)) { break; } // '+' or '-'
    let rhs = parse_mul(src, j + 1);
    let opStr = if (op == 43) "+" else "-";
    left = ParsedExpr("(" + left.v0 + " " + opStr + " " + rhs.v0 + ")", rhs.v1);
    j = left.v1;
  }
  left
}

fn parse_mul(src, i) => {
  let mut left = parse_postfix(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src))) { break; }
    let op = stringCharCodeAt(src, j);
    if (!(op == 42 || op == 47)) { break; } // '*' or '/'
    let rhs = parse_postfix(src, j + 1);
    let opStr = if (op == 42) "*" else "/";
    left = ParsedExpr("(" + left.v0 + " " + opStr + " " + rhs.v0 + ")", rhs.v1);
    j = left.v1;
  }
  left
}

fn parse_postfix(src, i) => {
  let mut left = parse_primary(src, i);
  let mut j = left.v1;
  while (true) {
    j = skip_ws(src, j);
    if (!(j < stringLen(src) && stringCharCodeAt(src, j) == 40)) { break; } // '('

    let args = parse_arg_list(src, j);
    left = ParsedExpr(left.v0 + "(" + args.v0 + ")", args.v1);
    j = left.v1;
  }
  left
}

fn parse_arg_list(src, i) => {
  // parses: '(' (expr (',' expr)*)? ')'
  let mut k = skip_ws(src, i);
  k = parse_keyword(src, k, "(");

  k = skip_ws(src, k);
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
    yield ParsedParams("", k + 1);
  }

  let mut out = "";
  let mut first = true;
  while (true) {
    let e = parse_expr(src, k);
    k = e.v1;
    if (first) { out = out + e.v0; } else { out = out + ", " + e.v0; }
    first = false;

    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic("expected ')' in arg list"); }
    let c = stringCharCodeAt(src, k);
    if (c == 44) { // ','
      k = k + 1;
      continue;
    }
    if (c == 41) { // ')'
      yield ParsedParams(out, k + 1);
    }
    panic("expected ',' or ')' in arg list")
  }

  // unreachable
  ParsedParams(out, k)
}

fn parse_primary(src, i) => {
  let j = skip_ws(src, i);
  if (!(j < stringLen(src))) { panic("expected expression"); }
  let c = stringCharCodeAt(src, j);
  if (c == 34) { // '"'
    let start = j;
    let mut k = j + 1;
    while (k < stringLen(src)) {
      let ch = stringCharCodeAt(src, k);
      if (ch == 34) { yield ParsedExpr(stringSlice(src, start, k + 1), k + 1); }
      if (ch == 92) { // '\\'
        k = k + 1;
        if (k < stringLen(src)) { k = k + 1; continue; }
        panic("unterminated string");
      }
      k = k + 1;
    }
    panic("unterminated string");
  }
  if (c == 40) { // '('
    let inner = parse_expr(src, j + 1);
    let k = skip_ws(src, inner.v1);
    if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 41)) { // ')'
      panic("expected ')'");
    }
    yield ParsedExpr("(" + inner.v0 + ")", k + 1);
  }
  if (is_digit(c)) {
    let n = parse_number(src, j);
    yield ParsedExpr("" + n.v0, n.v1);
  }
  if (is_ident_start(c)) {
    let id = parse_ident(src, j);
    let mut k = id.v1;
    let mut out = id.v0;
    while (true) {
      let t = skip_ws(src, k);
      if (!(t + 1 < stringLen(src))) { break; }
      if (!(stringCharCodeAt(src, t) == 58 && stringCharCodeAt(src, t + 1) == 58)) { break; } // '::'
      let next = parse_ident(src, t + 2);
      out = out + "." + next.v0;
      k = next.v1;
    }
    yield ParsedExpr(out, k);
  }
  panic("expected expression")
}

fn parse_imports(src, i) => {
  let mut k = i;
  let mut out = "";
  while (true) {
    let j = skip_ws(src, k);
    if (!starts_with_at(src, j, "import")) { break; }
    k = parse_keyword(src, k, "import");
    let mod = parse_ident(src, k);
    k = mod.v1;
    k = parse_optional_semicolon(src, k);
    out = out + ("import * as " + mod.v0 + " from \"./" + mod.v0 + ".mjs\";\n");
  }
  ParsedImports(out, k)
}

fn parse_param_list(src, i) => {
  // parses: '(' (ident (',' ident)*)? ')'
  let mut k = parse_keyword(src, i, "(");
  k = skip_ws(src, k);
  if (k < stringLen(src) && stringCharCodeAt(src, k) == 41) { // ')'
    yield ParsedParams("", k + 1);
  }
  let mut out = "";
  let mut first = true;
  while (true) {
    let id = parse_ident(src, k);
    k = id.v1;
    if (first) { out = out + id.v0; } else { out = out + ", " + id.v0; }
    first = false;

    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic("expected ')' in param list"); }
    let c = stringCharCodeAt(src, k);
    if (c == 44) { // ','
      k = k + 1;
      continue;
    }
    if (c == 41) { // ')'
      yield ParsedParams(out, k + 1);
    }
    panic("expected ',' or ')' in param list")
  }
  ParsedParams(out, k)
}

fn parse_extern_decl(src, i) => {
  let mut k = parse_keyword(src, i, "extern");
  k = parse_keyword(src, k, "from");
  let mod = parse_module_path(src, k);
  k = mod.v1;
  k = parse_keyword(src, k, "use");
  k = parse_keyword(src, k, "{");

  let mut names = "";
  let mut first = true;
  while (true) {
    k = skip_ws(src, k);
    if (!(k < stringLen(src))) { panic("expected '}'"); }
    if (stringCharCodeAt(src, k) == 125) { k = k + 1; break; }
    let id = parse_ident(src, k);
    k = id.v1;
    if (first) { names = names + id.v0; } else { names = names + ", " + id.v0; }
    first = false;
    k = skip_ws(src, k);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 44) { k = k + 1; continue; }
    k = skip_ws(src, k);
    if (k < stringLen(src) && stringCharCodeAt(src, k) == 125) { k = k + 1; break; }
    panic("expected ',' or '}' in extern list");
  }

  k = parse_optional_semicolon(src, k);

  let mut importPath = "";
  if (starts_with_at(mod.v0, 0, "rt::")) { importPath = "./rt/" + stringSlice(mod.v0, 4, stringLen(mod.v0)) + ".mjs"; }
  if (importPath == "" && starts_with_at(mod.v0, 0, "node::")) { importPath = "node:" + stringSlice(mod.v0, 6, stringLen(mod.v0)); }
  if (importPath == "") { panic("unsupported extern module: " + mod.v0); }

  ParsedStmt("import { " + names + " } from \"" + importPath + "\";\n", k)
}

fn parse_fn_decl2(src, i, exportAll) => {
  let mut k = parse_keyword(src, i, "fn");
  let name = parse_ident(src, k);
  k = name.v1;
  let params = parse_param_list(src, k);
  k = params.v1;
  k = parse_keyword(src, k, "=>");
  let body = parse_main_body(src, k);
  k = body.v1;

  let exportKw = if (exportAll || name.v0 == "main") "export " else "";
  let js = exportKw + "function " + name.v0 + "(" + params.v0 + ") {\n" + body.body + "return " + body.expr + ";\n}\n";
  ParsedStmt(js, k)
}

fn parse_fn_decl(src, i) => parse_fn_decl2(src, i, false)

fn parse_optional_semicolon(src, i) => {
  let j = skip_ws(src, i);
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 59) { yield j + 1; }
  i
}

fn parse_required_semicolon(src, i) => {
  let j = skip_ws(src, i);
  if (!(j < stringLen(src) && stringCharCodeAt(src, j) == 59)) { panic("expected ';'"); }
  j + 1
}

fn parse_mut_opt(src, i) => {
  let j = skip_ws(src, i);
  if (starts_with_at(src, j, "mut")) { yield ParsedBool(true, j + 3); }
  ParsedBool(false, i)
}

fn parse_stmt_block(src, i) => {
  let mut k = skip_ws(src, i);
  if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 123)) { panic("expected '{'"); }
  k = k + 1;
  let mut body = "";
  while (true) {
    let t = skip_ws(src, k);
    if (!(t < stringLen(src))) { panic("expected '}'"); }
    if (stringCharCodeAt(src, t) == 125) { yield ParsedExpr(body, t + 1); }

    let st = parse_stmt(src, k);
    body = body + st.v0;
    k = st.v1;
  }
  // unreachable
  ParsedExpr(body, k)
}

fn parse_stmt(src, i) => {
  let mut k = skip_ws(src, i);

  // let / let mut
  if (starts_with_at(src, k, "let")) {
    k = parse_keyword(src, k, "let");
    let mutOpt = parse_mut_opt(src, k);
    k = mutOpt.v1;
    let name = parse_ident(src, k);
    k = name.v1;
    k = parse_keyword(src, k, "=");
    let expr = parse_expr(src, k);
    k = expr.v1;
    k = parse_required_semicolon(src, k);
    let declKw = if (mutOpt.v0) "let" else "const";
    yield ParsedStmt(declKw + " " + name.v0 + " = " + expr.v0 + ";\n", k);
  }

  // while (...) { ... }
  if (starts_with_at(src, k, "while")) {
    k = parse_keyword(src, k, "while");
    k = parse_keyword(src, k, "(");
    let cond = parse_expr(src, k);
    k = cond.v1;
    k = parse_keyword(src, k, ")");
    let body = parse_stmt_block(src, k);
    k = body.v1;
    // optional semicolon after the while block
    k = parse_optional_semicolon(src, k);
    yield ParsedStmt("while (" + cond.v0 + ") {\n" + body.v0 + "}\n", k);
  }

  // if (...) { ... } else { ... }
  if (starts_with_at(src, k, "if")) {
    k = parse_keyword(src, k, "if");
    k = parse_keyword(src, k, "(");
    let cond = parse_expr(src, k);
    k = cond.v1;
    k = parse_keyword(src, k, ")");
    let thenB = parse_stmt_block(src, k);
    k = thenB.v1;
    k = parse_keyword(src, k, "else");
    let elseB = parse_stmt_block(src, k);
    k = elseB.v1;
    // optional semicolon after the if/else
    k = parse_optional_semicolon(src, k);
    yield ParsedStmt("if (" + cond.v0 + ") {\n" + thenB.v0 + "} else {\n" + elseB.v0 + "}\n", k);
  }

  // assignment: <ident> = <expr>;
  if (is_assign_stmt_start(src, k)) {
    let name = parse_ident(src, k);
    k = name.v1;
    k = parse_keyword(src, k, "=");
    let expr = parse_expr(src, k);
    k = expr.v1;
    k = parse_required_semicolon(src, k);
    yield ParsedStmt(name.v0 + " = " + expr.v0 + ";\n", k);
  }

  // expression statement: <expr>;
  let e = parse_expr(src, k);
  k = e.v1;
  k = parse_required_semicolon(src, k);
  yield ParsedStmt(e.v0 + ";\n", k);

  panic("expected statement")
}

fn is_assign_stmt_start(src, i) => {
  let mut j = skip_ws(src, i);
  if (!(j < stringLen(src))) { yield false; }
  let c0 = stringCharCodeAt(src, j);
  if (!is_ident_start(c0)) { yield false; }
  j = j + 1;
  while (j < stringLen(src)) {
    let c = stringCharCodeAt(src, j);
    if (!is_ident_part(c)) { break; }
    j = j + 1;
  }
  j = skip_ws(src, j);
  j < stringLen(src) && stringCharCodeAt(src, j) == 61 // '='
}

fn parse_main_body(src, i) => {
  let j = skip_ws(src, i);
  if (j < stringLen(src) && stringCharCodeAt(src, j) == 123) { // '{'
    // block main body
    let mut k = j + 1;
    let mut body = "";

    // statements inside block
    while (true) {
      let t = skip_ws(src, k);
      if (!(t < stringLen(src))) { panic("expected '}'"); }
      if (stringCharCodeAt(src, t) == 125) { break; }
      // stop before tail expression if next token isn't a statement start
      let isStmt = starts_with_at(src, t, "let") || starts_with_at(src, t, "while") || starts_with_at(src, t, "if") || is_assign_stmt_start(src, t);
      if (isStmt) {
        let st = parse_stmt(src, k);
        body = body + st.v0;
        k = st.v1;
        continue;
      }

      // expression statement vs tail expression: if there's a semicolon, it's a statement; otherwise it's the tail.
      let e = parse_expr(src, k);
      let after = skip_ws(src, e.v1);
      if (after < stringLen(src) && stringCharCodeAt(src, after) == 59) {
        body = body + (e.v0 + ";\n");
        k = after + 1;
        continue;
      }
      break;
    }

    // tail expression
    let tail = parse_expr(src, k);
    k = skip_ws(src, tail.v1);
    if (!(k < stringLen(src) && stringCharCodeAt(src, k) == 125)) { // '}'
      panic("expected '}'");
    }
    yield ParsedMain(body, tail.v0, k + 1);
  }

  // expression main body
  let e = parse_expr(src, i);
  ParsedMain("", e.v0, e.v1)
}

fn compile_tiny2(src, requireMain, exportAll) => {
  // Parse:
  //   (extern from <mod> use { <idents> };)*
  //   (import <ident>;)*
  //   (let <ident> = <expr>;)*
  //   (fn <ident>(<params>) => <expr|block>)*
  let mut i = 0;

  let mut out = "// compiled by selfhost tuffc\n";

  // zero or more extern declarations
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "extern")) {
      let ex = parse_extern_decl(src, i);
      out = out + ex.v0;
      i = ex.v1;
      continue;
    }
    break;
  }

  // zero or more imports
  let imps = parse_imports(src, i);
  out = out + imps.v0;
  i = imps.v1;

  // zero or more let statements
  while (true) {
    let j = skip_ws(src, i);
    if (starts_with_at(src, j, "let")) {
      i = parse_keyword(src, i, "let");
      let name = parse_ident(src, i);
      i = name.v1;
      i = parse_keyword(src, i, "=");
      let expr = parse_expr(src, i);
      i = expr.v1;
      i = parse_optional_semicolon(src, i);
      out = out + ("const " + name.v0 + " = " + expr.v0 + ";\n");
      continue;
    }
    break;
  }

  // main
  let mut sawMain = false;
  while (true) {
    let j = skip_ws(src, i);
    if (!starts_with_at(src, j, "fn")) { break; }
    let f = parse_fn_decl2(src, i, exportAll);
    if (starts_with_at(f.v0, 0, "export function main")) { sawMain = true; }
    out = out + f.v0;
    i = f.v1;
  }
  if (requireMain && !sawMain) { panic("expected fn main"); }
  out
}

fn compile_tiny(src) => compile_tiny2(src, true, false)
fn compile_module(src) => compile_tiny2(src, false, true)

fn compile_project(entryPath, outPath) => {
  // Very small multi-file compiler:
  // - only supports `import <ident>;`
  // - resolves to sibling file: <ident>.tuff in the entry's directory
  // - emits sibling output: <ident>.mjs in outDir

  let outDir = pathDirname(outPath);

  let mut queue = vec_new();
  vec_push(queue, entryPath);

  let mut done = vec_new();

  while (vec_len(queue) > 0) {
    let path = vec_get(queue, vec_len(queue) - 1);
    // pop
    // (no vec_pop; emulate by shrinking via set+len conventions isn't available,
    //  so we'll use a simple index-based loop instead)
    // We'll just process the last item and rebuild the queue without it.
    let mut newQ = vec_new();
    let mut qi = 0;
    while (qi + 1 < vec_len(queue)) {
      vec_push(newQ, vec_get(queue, qi));
      qi = qi + 1;
    }
    queue = newQ;

    // skip if already done
    let mut already = false;
    let mut di = 0;
    while (di < vec_len(done)) {
      if (vec_get(done, di) == path) { already = true; break; }
      di = di + 1;
    }
    if (already) { continue; }
    vec_push(done, path);

    let src = readTextFile(path);

    // discover imports for queueing (same parsing as emitter)
    let mut scan = 0;
    // skip externs
    while (true) {
      let j = skip_ws(src, scan);
      if (starts_with_at(src, j, "extern")) {
        let ex = parse_extern_decl(src, scan);
        scan = ex.v1;
        continue;
      }
      break;
    }
    while (true) {
      let j = skip_ws(src, scan);
      if (!starts_with_at(src, j, "import")) { break; }
      scan = parse_keyword(src, scan, "import");
      let mod = parse_ident(src, scan);
      scan = mod.v1;
      scan = parse_optional_semicolon(src, scan);
      let baseDir = pathDirname(path);
      let depPath = pathJoin(baseDir, mod.v0 + ".tuff");
      vec_push(queue, depPath);
    }

    let js = if (path == entryPath) compile_tiny(src) else compile_module(src);
    // choose output name
    let outFile = if (path == entryPath) outPath else {
      // <ident>.tuff -> <ident>.mjs
      // We only support sibling modules: /dir/name.tuff
      // so compute name by scanning for last path separator and stripping .tuff.
      let mut p = stringLen(path) - 1;
      let mut slash = -1;
      while (p >= 0) {
        let ch = stringCharCodeAt(path, p);
        if (ch == 47 || ch == 92) { slash = p; break; }
        p = p - 1;
      }
      let file = stringSlice(path, slash + 1, stringLen(path));
      // strip .tuff
      let name = stringSlice(file, 0, stringLen(file) - 5);
      pathJoin(outDir, name + ".mjs")
    };
    writeTextFile(outFile, js);
  }
}

// When run as a program, compile stdin-like file input.
// We keep it simple: main(argv) where argv = [inPath, outPath]
fn main(argv) => {
  if (vec_len(argv) < 2) {
    println("usage: tuffc <in.tuff> <out.mjs>");
    yield 1;
  }
  let inPath = vec_get(argv, 0);
  let outPath = vec_get(argv, 1);

  compile_project(inPath, outPath);
  0
}
