// Minimal expression grammar used to incrementally validate generated parsers.
// This is intentionally smaller than full tuff.ebnf.

expr ::= if_expr | match_expr | or_expr ;

if_expr ::= "if" "(" expr ")" expr "else" expr ;

match_expr ::= "match" "(" expr ")" "{" match_arm ((";" | ",") match_arm)* (";" | ",")? "}" ;
match_arm ::= match_pat "=>" expr ;
match_pat ::= "_" | bool_literal | int_literal | string_literal | path ;
path ::= ident ("::" ident)* ;

or_expr ::= and_expr ("||" and_expr)* ;
and_expr ::= eq_expr ("&&" eq_expr)* ;
eq_expr ::= rel_expr (("==" | "!=") rel_expr)* ;
rel_expr ::= add_expr (("<=" | ">=" | "<" | ">") add_expr)* ;

add_expr ::= mul_expr (("+" | "-") mul_expr)* ;
mul_expr ::= unary_expr (("*" | "/") unary_expr)* ;

unary_expr ::= ("-" unary_expr) | ("!" unary_expr) | postfix_expr ;

postfix_expr ::= atom postfix* ;

postfix ::= call | field | index ;
tuple_index ::= "." int_literal ;
call ::= "(" arg_list? ")" ;
arg_list ::= expr ("," expr)* ;
field ::= "." ident ;
index ::= "[" expr "]" ;

atom ::= block | tuple_lit | string_literal | bool_literal | int_literal | ident | "(" expr ")" ;

block ::= "{" (expr ";")* expr "}" ;

tuple_lit ::= "(" expr "," expr ("," expr)* ")" ;

bool_literal ::= "true" | "false" ;

// NOTE: string literal parsing uses a generator fast-path (escape handling),
// so this rule is intentionally permissive.
string_literal ::= "\"" [^\"]* "\"" ;

int_literal ::= [0-9]+ ;
ident ::= [a-zA-Z_][a-zA-Z0-9_]* ;
