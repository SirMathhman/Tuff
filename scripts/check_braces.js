const fs=require('fs');const s=fs.readFileSync('src/interpret.ts','utf8');let inS=false,inD=false,inT=false,inRegex=false,inLine=false,inBlock=false,escaped=false;let stack=[];for(let i=0;i<s.length;i++){const ch=s[i];if(inLine){ if(ch==='\n') inLine=false; continue;} if(inBlock){ if(ch==='*' && s[i+1]=='/') { inBlock=false;i++; } continue;} if(inS){ if(!escaped && ch==="'") inS=false; if(ch==='\\' && !escaped) escaped=true; else escaped=false; continue;} if(inD){ if(!escaped && ch==='"') inD=false; if(ch==='\\' && !escaped) escaped=true; else escaped=false; continue;} if(inT){ if(ch==='`' && !escaped) inT=false; if(ch==='\\' && !escaped) escaped=true; else escaped=false; continue;} if(inRegex){ if(ch==='/' && !escaped){ inRegex=false; } if(ch==='\\' && !escaped) escaped=true; else escaped=false; continue;} if(ch==='/'){ const next=s[i+1]; if(next==='/' ){ inLine=true; i++; continue } if(next==='*'){ inBlock=true; i++; continue} // heuristic: regex if previous nonspace char allows it const j=i-1; let prevNon='\n'; for(let k=j;k>=0;k--){ if(!/\s/.test(s[k])){ prevNon=s[k]; break;}} if(/[=\(,;:\[!&|?{}\n]/.test(prevNon)) { inRegex=true; continue;} } if(ch==="'") { inS=true; continue;} if(ch==='"'){ inD=true; continue;} if(ch==='`'){ inT=true; continue;} if(ch==='{') stack.push({ch,i}); else if(ch==='}') { const top=stack.pop(); if(!top){ console.log('Unmatched } at',i); process.exit(0);} if(top.ch!=='{'){ console.log('Mismatched } at',i, 'top',top); process.exit(0);} } } if(stack.length){ console.log('Unclosed { at EOF count',stack.length, 'examples', stack.slice(-3)); } else console.log('All {} balanced');
